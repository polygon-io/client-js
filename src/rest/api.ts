/* tslint:disable */
/* eslint-disable */
/**
 * Polygon API
 * The future of fintech.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BenzingaEarnings200Response
 */
export interface BenzingaEarnings200Response {
    /**
     * URL for the next page of results, if applicable.
     * @type {string}
     * @memberof BenzingaEarnings200Response
     */
    'next_url'?: string;
    /**
     * Unique identifier for this request.
     * @type {string}
     * @memberof BenzingaEarnings200Response
     */
    'request_id': string;
    /**
     * Records that match the given query.
     * @type {Array<BenzingaEarnings200ResponseResultsInner>}
     * @memberof BenzingaEarnings200Response
     */
    'results': Array<BenzingaEarnings200ResponseResultsInner>;
    /**
     * Status of the request. Usually \'OK\' or \'ERROR\'.
     * @type {string}
     * @memberof BenzingaEarnings200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface BenzingaEarnings200ResponseResultsInner
 */
export interface BenzingaEarnings200ResponseResultsInner {
    /**
     * The actual earnings per share (EPS) reported by the company for the given period.
     * @type {number}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'actual_eps'?: number;
    /**
     * The actual revenue reported by the company for the given fiscal period.
     * @type {number}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'actual_revenue'?: number;
    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * The name of the company releasing earnings.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'company_name'?: string;
    /**
     * The currency in which the earnings and revenue figures are reported.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'date'?: string;
    /**
     * Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'date_status'?: string;
    /**
     * The accounting standard used to calculate EPS.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'earnings_method'?: string;
    /**
     * The difference between the actual and estimated EPS.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'eps_surprise'?: string;
    /**
     * The percentage difference between the actual and estimated EPS.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'eps_surprise_percent'?: string;
    /**
     * The analyst consensus estimate for earnings per share (EPS) for the given period.
     * @type {number}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'estimated_eps'?: number;
    /**
     * The analyst consensus estimate for the company\'s revenue in the given period.
     * @type {number}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'estimated_revenue'?: number;
    /**
     * The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'fiscal_period'?: string;
    /**
     * The fiscal year in which the earnings period falls.
     * @type {number}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'fiscal_year'?: number;
    /**
     * A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest).
     * @type {number}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'importance'?: number;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the earnings record was last updated in the system.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * Additional context, commentary, or clarifying notes related to the earnings event.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'notes'?: string;
    /**
     * The company\'s reported earnings per share (EPS) for the previous comparable period.
     * @type {number}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'previous_eps'?: number;
    /**
     * The company\'s revenue for the previous comparable fiscal period.
     * @type {number}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'previous_revenue'?: number;
    /**
     * The accounting standard used for the revenue figure.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'revenue_method'?: string;
    /**
     * The difference between the actual and estimated revenue.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'revenue_surprise'?: string;
    /**
     * The percentage difference between the actual and estimated revenue.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'revenue_surprise_percent'?: string;
    /**
     * The stock symbol of the company reporting earnings.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The time (formatted as 24-hour HH:MM:SS UTC) when the earnings are scheduled or were reported.
     * @type {string}
     * @memberof BenzingaEarnings200ResponseResultsInner
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface BenzingaNews200Response
 */
export interface BenzingaNews200Response {
    /**
     * URL for the next page of results, if applicable.
     * @type {string}
     * @memberof BenzingaNews200Response
     */
    'next_url'?: string;
    /**
     * Unique identifier for this request.
     * @type {string}
     * @memberof BenzingaNews200Response
     */
    'request_id': string;
    /**
     * Records that match the given query.
     * @type {Array<BenzingaNews200ResponseResultsInner>}
     * @memberof BenzingaNews200Response
     */
    'results': Array<BenzingaNews200ResponseResultsInner>;
    /**
     * Status of the request. Usually \'OK\' or \'ERROR\'.
     * @type {string}
     * @memberof BenzingaNews200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface BenzingaNews200ResponseResultsInner
 */
export interface BenzingaNews200ResponseResultsInner {
    /**
     * The name of the journalist or entity that authored the news article.
     * @type {string}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'author'?: string;
    /**
     * The identifer used by Benzinga for this record.
     * @type {number}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'benzinga_id'?: number;
    /**
     * The full text content of the news article.
     * @type {string}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'body'?: string;
    /**
     * A list of categories or topics that the article belongs to (e.g., \'News\', \'Price Target\').
     * @type {string}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'channels'?: string;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
     * @type {string}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'created'?: string;
    /**
     * A list of images associated with the article.
     * @type {string}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'images'?: string;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
     * @type {string}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * A list of tags that describe the themes or content of the article.
     * @type {string}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'tags'?: string;
    /**
     * A short summary or lead-in to the news article\'s content.
     * @type {string}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'teaser'?: string;
    /**
     * A list of stock or crypto tickers mentioned in the article.
     * @type {string}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'tickers'?: string;
    /**
     * The headline of the news article.
     * @type {string}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'title'?: string;
    /**
     * The direct link to the source of the news article.
     * @type {string}
     * @memberof BenzingaNews200ResponseResultsInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface BenzingaRatings200Response
 */
export interface BenzingaRatings200Response {
    /**
     * URL for the next page of results, if applicable.
     * @type {string}
     * @memberof BenzingaRatings200Response
     */
    'next_url'?: string;
    /**
     * Unique identifier for this request.
     * @type {string}
     * @memberof BenzingaRatings200Response
     */
    'request_id': string;
    /**
     * Records that match the given query.
     * @type {Array<BenzingaRatings200ResponseResultsInner>}
     * @memberof BenzingaRatings200Response
     */
    'results': Array<BenzingaRatings200ResponseResultsInner>;
    /**
     * Status of the request. Usually \'OK\' or \'ERROR\'.
     * @type {string}
     * @memberof BenzingaRatings200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface BenzingaRatings200ResponseResultsInner
 */
export interface BenzingaRatings200ResponseResultsInner {
    /**
     * The current price target adjusted for stock splits and dividends.
     * @type {number}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'adjusted_price_target'?: number;
    /**
     * The name of the individual analyst who issued the rating.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'analyst'?: string;
    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * The name of the company being rated.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'company_name'?: string;
    /**
     * The currency in which the price target is denominated.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'date'?: string;
    /**
     * The name of the research firm or investment bank issuing the rating.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'firm'?: string;
    /**
     * A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest).
     * @type {number}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'importance'?: number;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * Additional context or commentary.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'notes'?: string;
    /**
     * The previous price target adjusted for stock splits and dividends.
     * @type {number}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'previous_adjusted_price_target'?: number;
    /**
     * The previous price target set by the analyst.
     * @type {number}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'previous_price_target'?: number;
    /**
     * The previous rating set by the analyst.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'previous_rating'?: string;
    /**
     * The current price target set by the analyst.
     * @type {number}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'price_target'?: number;
    /**
     * The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'price_target_action'?: string;
    /**
     * The current rating set by the analyst.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'rating'?: string;
    /**
     * The description of the change in rating from the firm\'s last rating. Possible values include: downgrade, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'rating_action'?: string;
    /**
     * The stock symbol of the company being rated.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The time (formatted as 24-hour HH:MM:SS UTC) when the rating was issued.
     * @type {string}
     * @memberof BenzingaRatings200ResponseResultsInner
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface Company
 */
export interface Company {
    /**
     * Indicates if the security is actively listed.  If false, this means the company is no longer listed and cannot be traded.
     * @type {boolean}
     * @memberof Company
     */
    'active'?: boolean;
    /**
     * The Bloomberg guid for the symbol.
     * @type {string}
     * @memberof Company
     */
    'bloomberg'?: string;
    /**
     * The name of the company\'s current CEO.
     * @type {string}
     * @memberof Company
     */
    'ceo'?: string;
    /**
     * The official CIK guid used for SEC database/filings.
     * @type {string}
     * @memberof Company
     */
    'cik'?: string;
    /**
     * The country in which the company is registered.
     * @type {string}
     * @memberof Company
     */
    'country'?: string;
    /**
     * A description of the company and what they do/offer.
     * @type {string}
     * @memberof Company
     */
    'description'?: string;
    /**
     * The approximate number of employees for the company.
     * @type {number}
     * @memberof Company
     */
    'employees'?: number;
    /**
     * The symbol\'s primary exchange.
     * @type {string}
     * @memberof Company
     */
    'exchange'?: string;
    /**
     * The exchange code (id) of the symbol\'s primary exchange.
     * @type {string}
     * @memberof Company
     */
    'exchangeSymbol'?: string;
    /**
     * The OpenFigi project guid for the symbol. (<a rel=\"nofollow\" target=\"_blank\" href=\"https://openfigi.com/\">https://openfigi.com/</a>)
     * @type {string}
     * @memberof Company
     */
    'figi'?: string;
    /**
     * The street address for the company\'s headquarters.
     * @type {string}
     * @memberof Company
     */
    'hq_address'?: string;
    /**
     * The country in which the company\'s headquarters is located.
     * @type {string}
     * @memberof Company
     */
    'hq_country'?: string;
    /**
     * The state in which the company\'s headquarters is located.
     * @type {string}
     * @memberof Company
     */
    'hq_state'?: string;
    /**
     * The industry in which the company operates.
     * @type {string}
     * @memberof Company
     */
    'industry'?: string;
    /**
     * The Legal Entity Identifier (LEI) guid for the symbol. (<a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Legal_Entity_Identifier\">https://en.wikipedia.org/wiki/Legal_Entity_Identifier</a>)
     * @type {string}
     * @memberof Company
     */
    'lei'?: string;
    /**
     * The date that the symbol was listed on the exchange.
     * @type {string}
     * @memberof Company
     */
    'listdate'?: string;
    /**
     * The URL of the entity\'s logo.
     * @type {string}
     * @memberof Company
     */
    'logo'?: string;
    /**
     * The current market cap for the company.
     * @type {number}
     * @memberof Company
     */
    'marketcap'?: number;
    /**
     * The name of the company/entity.
     * @type {string}
     * @memberof Company
     */
    'name'?: string;
    /**
     * The phone number for the company. This is usually a corporate contact number.
     * @type {string}
     * @memberof Company
     */
    'phone'?: string;
    /**
     * The sector of the indsutry in which the symbol operates.
     * @type {string}
     * @memberof Company
     */
    'sector'?: string;
    /**
     * Standard Industrial Classification (SIC) id for the symbol. (<a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Standard_Industrial_Classification\">https://en.wikipedia.org/wiki/Legal_Entity_Identifier</a>)
     * @type {number}
     * @memberof Company
     */
    'sic'?: number;
    /**
     * A list of ticker symbols for similar companies.
     * @type {Array<string>}
     * @memberof Company
     */
    'similar'?: Array<string>;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof Company
     */
    'symbol'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Company
     */
    'tags'?: Array<string>;
    /**
     * The type or class of the security.  (<a alt=\"Full List of Ticker Types\" href=\"https://polygon.io/docs/stocks/get_v3_reference_tickers_types\">Full List of Ticker Types</a>)
     * @type {string}
     * @memberof Company
     */
    'type'?: string;
    /**
     * The last time this company record was updated.
     * @type {string}
     * @memberof Company
     */
    'updated'?: string;
    /**
     * The URL of the company\'s website
     * @type {string}
     * @memberof Company
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ConditionTypeMap
 */
export interface ConditionTypeMap {
    /**
     * Polygon.io\'s mapping for condition codes.  For more information, see our <a href=\"https://polygon.io/glossary/us/stocks/trade-conditions\" alt=\"Trade Conditions Glossary\" target=\"_blank\">Trade Conditions Glossary</a>. 
     * @type {string}
     * @memberof ConditionTypeMap
     */
    'condition'?: string;
}
/**
 * 
 * @export
 * @interface CryptoEMA200Response
 */
export interface CryptoEMA200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof CryptoEMA200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof CryptoEMA200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {CryptoEMA200ResponseResults}
     * @memberof CryptoEMA200Response
     */
    'results'?: CryptoEMA200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof CryptoEMA200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface CryptoEMA200ResponseResults
 */
export interface CryptoEMA200ResponseResults {
    /**
     * 
     * @type {CryptoEMA200ResponseResultsUnderlying}
     * @memberof CryptoEMA200ResponseResults
     */
    'underlying'?: CryptoEMA200ResponseResultsUnderlying;
    /**
     * 
     * @type {Array<CryptoEMA200ResponseResultsValuesInner>}
     * @memberof CryptoEMA200ResponseResults
     */
    'values'?: Array<CryptoEMA200ResponseResultsValuesInner>;
}
/**
 * 
 * @export
 * @interface CryptoEMA200ResponseResultsUnderlying
 */
export interface CryptoEMA200ResponseResultsUnderlying {
    /**
     * 
     * @type {Array<CryptoEMA200ResponseResultsUnderlyingAggregatesInner>}
     * @memberof CryptoEMA200ResponseResultsUnderlying
     */
    'aggregates'?: Array<CryptoEMA200ResponseResultsUnderlyingAggregatesInner>;
    /**
     * The URL which can be used to request the underlying aggregates used in this request.
     * @type {string}
     * @memberof CryptoEMA200ResponseResultsUnderlying
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface CryptoEMA200ResponseResultsUnderlyingAggregatesInner
 */
export interface CryptoEMA200ResponseResultsUnderlyingAggregatesInner {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof CryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof CryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'otc'?: boolean;
    /**
     * The Unix Msec timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof CryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof CryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof CryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface CryptoEMA200ResponseResultsValuesInner
 */
export interface CryptoEMA200ResponseResultsValuesInner {
    /**
     * The Unix Msec timestamp from the last aggregate used in this calculation.
     * @type {number}
     * @memberof CryptoEMA200ResponseResultsValuesInner
     */
    'timestamp'?: number;
    /**
     * The indicator value for this period.
     * @type {number}
     * @memberof CryptoEMA200ResponseResultsValuesInner
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface CryptoExchangeInner
 */
export interface CryptoExchangeInner {
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof CryptoExchangeInner
     */
    'id': number;
    /**
     * Market data type this exchange contains ( crypto only currently )
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'market': string;
    /**
     * Name of the exchange
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'name': string;
    /**
     * Type of exchange feed
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'type': string;
    /**
     * URL of this exchange
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CryptoGroupedResults
 */
export interface CryptoGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner>}
     * @memberof CryptoGroupedResults
     */
    'results'?: Array<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface CryptoHistoricTrades
 */
export interface CryptoHistoricTrades {
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof CryptoHistoricTrades
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof CryptoHistoricTrades
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof CryptoHistoricTrades
     */
    'msLatency': number;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof CryptoHistoricTrades
     */
    'symbol': string;
    /**
     * 
     * @type {Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>}
     * @memberof CryptoHistoricTrades
     */
    'ticks': Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface CryptoLastTrade
 */
export interface CryptoLastTrade {
    /**
     * 
     * @type {CryptoLastTradeLast}
     * @memberof CryptoLastTrade
     */
    'last'?: CryptoLastTradeLast;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof CryptoLastTrade
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface CryptoLastTradeLast
 */
export interface CryptoLastTradeLast {
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof CryptoLastTradeLast
     */
    'conditions': Array<number>;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'exchange': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'price': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'size': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface CryptoMACD200Response
 */
export interface CryptoMACD200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof CryptoMACD200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof CryptoMACD200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {CryptoMACD200ResponseResults}
     * @memberof CryptoMACD200Response
     */
    'results'?: CryptoMACD200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof CryptoMACD200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface CryptoMACD200ResponseResults
 */
export interface CryptoMACD200ResponseResults {
    /**
     * 
     * @type {CryptoEMA200ResponseResultsUnderlying}
     * @memberof CryptoMACD200ResponseResults
     */
    'underlying'?: CryptoEMA200ResponseResultsUnderlying;
    /**
     * 
     * @type {Array<CryptoMACD200ResponseResultsValuesInner>}
     * @memberof CryptoMACD200ResponseResults
     */
    'values'?: Array<CryptoMACD200ResponseResultsValuesInner>;
}
/**
 * 
 * @export
 * @interface CryptoMACD200ResponseResultsValuesInner
 */
export interface CryptoMACD200ResponseResultsValuesInner {
    /**
     * The indicator value for this period.
     * @type {number}
     * @memberof CryptoMACD200ResponseResultsValuesInner
     */
    'histogram'?: number;
    /**
     * The indicator value for this period.
     * @type {number}
     * @memberof CryptoMACD200ResponseResultsValuesInner
     */
    'signal'?: number;
    /**
     * The Unix Msec timestamp from the last aggregate used in this calculation.
     * @type {number}
     * @memberof CryptoMACD200ResponseResultsValuesInner
     */
    'timestamp'?: number;
    /**
     * The indicator value for this period.
     * @type {number}
     * @memberof CryptoMACD200ResponseResultsValuesInner
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface CryptoOpenClose
 */
export interface CryptoOpenClose {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoOpenClose
     */
    'close': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>}
     * @memberof CryptoOpenClose
     */
    'closingTrades': Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>;
    /**
     * The date requested.
     * @type {string}
     * @memberof CryptoOpenClose
     */
    'day': string;
    /**
     * Whether or not the timestamps are in UTC timezone.
     * @type {boolean}
     * @memberof CryptoOpenClose
     */
    'isUTC': boolean;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoOpenClose
     */
    'open': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>}
     * @memberof CryptoOpenClose
     */
    'openTrades': Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof CryptoOpenClose
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface CryptoRSI200Response
 */
export interface CryptoRSI200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof CryptoRSI200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof CryptoRSI200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {CryptoRSI200ResponseResults}
     * @memberof CryptoRSI200Response
     */
    'results'?: CryptoRSI200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof CryptoRSI200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface CryptoRSI200ResponseResults
 */
export interface CryptoRSI200ResponseResults {
    /**
     * 
     * @type {CryptoEMA200ResponseResultsUnderlying}
     * @memberof CryptoRSI200ResponseResults
     */
    'underlying'?: CryptoEMA200ResponseResultsUnderlying;
    /**
     * 
     * @type {Array<CryptoEMA200ResponseResultsValuesInner>}
     * @memberof CryptoRSI200ResponseResults
     */
    'values'?: Array<CryptoEMA200ResponseResultsValuesInner>;
}
/**
 * 
 * @export
 * @interface CryptoSMA200Response
 */
export interface CryptoSMA200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof CryptoSMA200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof CryptoSMA200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {CryptoSMA200ResponseResults}
     * @memberof CryptoSMA200Response
     */
    'results'?: CryptoSMA200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof CryptoSMA200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface CryptoSMA200ResponseResults
 */
export interface CryptoSMA200ResponseResults {
    /**
     * 
     * @type {CryptoEMA200ResponseResultsUnderlying}
     * @memberof CryptoSMA200ResponseResults
     */
    'underlying'?: CryptoEMA200ResponseResultsUnderlying;
    /**
     * 
     * @type {Array<CryptoEMA200ResponseResultsValuesInner>}
     * @memberof CryptoSMA200ResponseResults
     */
    'values'?: Array<CryptoEMA200ResponseResultsValuesInner>;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotMinute
 */
export interface CryptoSnapshotMinute {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotTicker
 */
export interface CryptoSnapshotTicker {
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker}
     * @memberof CryptoSnapshotTicker
     */
    'ticker'?: V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotTickerFullBook
 */
export interface CryptoSnapshotTickerFullBook {
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData}
     * @memberof CryptoSnapshotTickerFullBook
     */
    'data'?: V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotTickers
 */
export interface CryptoSnapshotTickers {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner>}
     * @memberof CryptoSnapshotTickers
     */
    'tickers'?: Array<V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface CryptoTick
 */
export interface CryptoTick {
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof CryptoTick
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof CryptoTick
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof CryptoTick
     */
    'p': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof CryptoTick
     */
    's': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof CryptoTick
     */
    't': number;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof CryptoTick
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface ExchangeInner
 */
export interface ExchangeInner {
    /**
     * A unique identifier for the exchange internal to Polygon.io.  This is not an industry code or ISO standard.
     * @type {string}
     * @memberof ExchangeInner
     */
    'code'?: string;
    /**
     * The ID of the exchange.
     * @type {number}
     * @memberof ExchangeInner
     */
    'id'?: number;
    /**
     * The market data type that this exchange contains.
     * @type {string}
     * @memberof ExchangeInner
     */
    'market'?: string;
    /**
     * The Market Identification Code or MIC as defined in ISO 10383 (<a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Market_Identifier_Code\">https://en.wikipedia.org/wiki/Market_Identifier_Code</a>).
     * @type {string}
     * @memberof ExchangeInner
     */
    'mic'?: string;
    /**
     * The name of the exchange.
     * @type {string}
     * @memberof ExchangeInner
     */
    'name'?: string;
    /**
     * The tape id of the exchange.
     * @type {string}
     * @memberof ExchangeInner
     */
    'tape'?: string;
    /**
     * The type of exchange. - TRF = Trade Reporting Facility - exchange = Reporting exchange on the tape 
     * @type {string}
     * @memberof ExchangeInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Financial
 */
export interface Financial {
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'cashChange'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'cashFlow'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'costOfRevenue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'currentAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'currentCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'currentDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'grossProfit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'netIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingGainsLosses'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingRevenue'?: number;
    /**
     * Report Date
     * @type {string}
     * @memberof Financial
     */
    'reportDate': string;
    /**
     * Report date as non date format
     * @type {string}
     * @memberof Financial
     */
    'reportDateStr': string;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'researchAndDevelopment'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'shareholderEquity'?: number;
    /**
     * Stock Symbol
     * @type {string}
     * @memberof Financial
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalLiabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalRevenue'?: number;
}
/**
 * Financials
 * @export
 * @interface Financials
 */
export interface Financials {
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'EBITDAMargin'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'accumulatedOtherComprehensiveIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'accumulatedRetainedEarningsDeficit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetTurnover'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetsAverage'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetsCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetsNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'averageEquity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'bookValuePerShare'?: number;
    /**
     * 
     * @type {string}
     * @memberof Financials
     */
    'calendarDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'capitalExpenditure'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'cashAndEquivalents'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'cashAndEquivalentsUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'consolidatedIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'costOfRevenue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'currentLiabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'currentRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtToEquityRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'deferredRevenue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'deposits'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'depreciationAmortizationAndAccretion'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'dividendYield'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'dividendsPerBasicCommonShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningBeforeInterestTaxes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningBeforeInterestTaxesUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsBeforeInterestTaxesDepreciationAmortization'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsBeforeInterestTaxesDepreciationAmortizationUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsBeforeTax'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsPerBasicShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsPerBasicShareUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsPerDilutedShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'effectOfExchangeRateChangesOnCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'enterpriseValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'enterpriseValueOverEBIT'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'enterpriseValueOverEBITDA'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'foreignCurrencyUSDExchangeRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'freeCashFlow'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'freeCashFlowPerShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'goodwillAndIntangibleAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'grossMargin'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'grossProfit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'incomeTaxExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'interestExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'inventory'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investedCapital'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investedCapitalAverage'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investments'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investmentsCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investmentsNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'issuanceDebtSecurities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'issuanceEquityShares'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'liabilitiesNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'marketCapitalization'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlow'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowBusinessAcquisitionsDisposals'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowFromFinancing'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowFromInvesting'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowFromOperations'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowInvestmentAcquisitionsDisposals'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncomeCommonStock'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncomeCommonStockUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncomeToNonControllingInterests'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netLossIncomeFromDiscontinuedOperations'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'operatingExpenses'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'operatingIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'paymentDividendsOtherCashDistributions'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'payoutRatio'?: number;
    /**
     * Reporting period.
     * @type {string}
     * @memberof Financials
     */
    'period'?: FinancialsPeriodEnum;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'preferredDividendsIncomeStatementImpact'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceEarnings'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceSales'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceToBookValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceToEarningsRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceToSalesRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'profitMargin'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'propertyPlantEquipmentNet'?: number;
    /**
     * 
     * @type {string}
     * @memberof Financials
     */
    'reportPeriod'?: string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'researchAndDevelopmentExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnAverageAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnAverageEquity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnInvestedCapital'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnSales'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'revenues'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'revenuesUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'salesPerShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'sellingGeneralAndAdministrativeExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareBasedCompensation'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareFactor'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'sharePriceAdjustedClose'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareholdersEquity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareholdersEquityUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shares'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tangibleAssetValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tangibleAssetsBookValuePerShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'taxAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'taxLiabilities'?: number;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof Financials
     */
    'ticker': string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'totalLiabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tradeAndNonTradePayables'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tradeAndNonTradeReceivables'?: number;
    /**
     * 
     * @type {string}
     * @memberof Financials
     */
    'updated'?: string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'weightedAverageShares'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'weightedAverageSharesDiluted'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'workingCapital'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum FinancialsPeriodEnum {
    Q = 'Q',
    T = 'T',
    Qa = 'QA',
    Ta = 'TA',
    Y = 'Y',
    Ya = 'YA'
}

/**
 * 
 * @export
 * @interface ForexConversion
 */
export interface ForexConversion {
    /**
     * The result of the conversion.
     * @type {number}
     * @memberof ForexConversion
     */
    'converted': number;
    /**
     * The \"from\" currency symbol.
     * @type {string}
     * @memberof ForexConversion
     */
    'from': string;
    /**
     * The amount to convert.
     * @type {number}
     * @memberof ForexConversion
     */
    'initialAmount': number;
    /**
     * 
     * @type {ForexConversionLast}
     * @memberof ForexConversion
     */
    'last'?: ForexConversionLast;
    /**
     * The \"to\" currency symbol.
     * @type {string}
     * @memberof ForexConversion
     */
    'to': string;
}
/**
 * 
 * @export
 * @interface ForexConversionLast
 */
export interface ForexConversionLast {
    /**
     * The ask price.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'ask': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'bid': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/forex/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'exchange': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface ForexGroupedResults
 */
export interface ForexGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner>}
     * @memberof ForexGroupedResults
     */
    'results'?: Array<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface ForexHistoricTrades
 */
export interface ForexHistoricTrades {
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof ForexHistoricTrades
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof ForexHistoricTrades
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof ForexHistoricTrades
     */
    'msLatency': number;
    /**
     * The currency pair that was evaluated from the request.
     * @type {string}
     * @memberof ForexHistoricTrades
     */
    'pair': string;
    /**
     * 
     * @type {Array<V1HistoricForexFromToDateGet200ResponseAllOfTicksInner>}
     * @memberof ForexHistoricTrades
     */
    'ticks': Array<V1HistoricForexFromToDateGet200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface ForexPairLastQuote
 */
export interface ForexPairLastQuote {
    /**
     * 
     * @type {ForexConversionLast}
     * @memberof ForexPairLastQuote
     */
    'last'?: ForexConversionLast;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof ForexPairLastQuote
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface ForexPreviousClose
 */
export interface ForexPreviousClose {
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner>}
     * @memberof ForexPreviousClose
     */
    'results'?: Array<V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface ForexSnapshotLastQuote
 */
export interface ForexSnapshotLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    'a': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    'b': number;
    /**
     * The millisecond accuracy timestamp of the quote.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    't': number;
    /**
     * The exchange ID on which this quote happened.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface ForexSnapshotPrevDay
 */
export interface ForexSnapshotPrevDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface ForexSnapshotTicker
 */
export interface ForexSnapshotTicker {
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker}
     * @memberof ForexSnapshotTicker
     */
    'ticker'?: V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker;
}
/**
 * 
 * @export
 * @interface ForexSnapshotTickers
 */
export interface ForexSnapshotTickers {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner>}
     * @memberof ForexSnapshotTickers
     */
    'tickers'?: Array<V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface ForexTickerResults
 */
export interface ForexTickerResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner>}
     * @memberof ForexTickerResults
     */
    'results'?: Array<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetEvents200Response
 */
export interface GetEvents200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetEvents200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {GetEvents200ResponseResults}
     * @memberof GetEvents200Response
     */
    'results'?: GetEvents200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetEvents200Response
     */
    'status'?: string;
}
/**
 * Contains the requested event data for the specified ticker.
 * @export
 * @interface GetEvents200ResponseResults
 */
export interface GetEvents200ResponseResults {
    /**
     * An array of event containing the requested data.
     * @type {Array<GetEvents200ResponseResultsEventsInner>}
     * @memberof GetEvents200ResponseResults
     */
    'events'?: Array<GetEvents200ResponseResultsEventsInner>;
    /**
     * The name of the asset.
     * @type {string}
     * @memberof GetEvents200ResponseResults
     */
    'name'?: string;
}
/**
 * @type GetEvents200ResponseResultsEventsInner
 * @export
 */
export type GetEvents200ResponseResultsEventsInner = GetEvents200ResponseResultsEventsInnerOneOf;

/**
 * 
 * @export
 * @interface GetEvents200ResponseResultsEventsInnerOneOf
 */
export interface GetEvents200ResponseResultsEventsInnerOneOf {
    /**
     * The date the event took place
     * @type {string}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOf
     */
    'date': string;
    /**
     * The type of historical event for the asset
     * @type {string}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOf
     */
    'event_type': string;
    /**
     * 
     * @type {GetEvents200ResponseResultsEventsInnerOneOfTickerChange}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOf
     */
    'ticker_change'?: GetEvents200ResponseResultsEventsInnerOneOfTickerChange;
}
/**
 * Details about a ticker change
 * @export
 * @interface GetEvents200ResponseResultsEventsInnerOneOfTickerChange
 */
export interface GetEvents200ResponseResultsEventsInnerOneOfTickerChange {
    /**
     * A ticker symbol
     * @type {string}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOfTickerChange
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetMarketHolidays200ResponseInner
 */
export interface GetMarketHolidays200ResponseInner {
    /**
     * The market close time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'close'?: string;
    /**
     * The date of the holiday.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'date'?: string;
    /**
     * Which market the record is for.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'exchange'?: string;
    /**
     * The name of the holiday.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'name'?: string;
    /**
     * The market open time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'open'?: string;
    /**
     * The status of the market on the holiday.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetMarketStatus200Response
 */
export interface GetMarketStatus200Response {
    /**
     * Whether or not the market is in post-market hours.
     * @type {boolean}
     * @memberof GetMarketStatus200Response
     */
    'afterHours'?: boolean;
    /**
     * 
     * @type {GetMarketStatus200ResponseCurrencies}
     * @memberof GetMarketStatus200Response
     */
    'currencies'?: GetMarketStatus200ResponseCurrencies;
    /**
     * Whether or not the market is in pre-market hours.
     * @type {boolean}
     * @memberof GetMarketStatus200Response
     */
    'earlyHours'?: boolean;
    /**
     * 
     * @type {GetMarketStatus200ResponseExchanges}
     * @memberof GetMarketStatus200Response
     */
    'exchanges'?: GetMarketStatus200ResponseExchanges;
    /**
     * 
     * @type {GetMarketStatus200ResponseIndicesGroups}
     * @memberof GetMarketStatus200Response
     */
    'indicesGroups'?: GetMarketStatus200ResponseIndicesGroups;
    /**
     * The status of the market as a whole.
     * @type {string}
     * @memberof GetMarketStatus200Response
     */
    'market'?: string;
    /**
     * The current time of the server, returned as a date-time in RFC3339 format.
     * @type {string}
     * @memberof GetMarketStatus200Response
     */
    'serverTime'?: string;
}
/**
 * Contains the status of various currency markets.
 * @export
 * @interface GetMarketStatus200ResponseCurrencies
 */
export interface GetMarketStatus200ResponseCurrencies {
    /**
     * The status of the crypto market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseCurrencies
     */
    'crypto'?: string;
    /**
     * The status of the forex market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseCurrencies
     */
    'fx'?: string;
}
/**
 * Contains the status of different US stock exchanges (e.g., Nasdaq, NYSE).
 * @export
 * @interface GetMarketStatus200ResponseExchanges
 */
export interface GetMarketStatus200ResponseExchanges {
    /**
     * The status of the Nasdaq market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseExchanges
     */
    'nasdaq'?: string;
    /**
     * The status of the NYSE market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseExchanges
     */
    'nyse'?: string;
    /**
     * The status of the OTC market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseExchanges
     */
    'otc'?: string;
}
/**
 * Contains the status of various index groups (e.g., MSCI, FTSE Russell).
 * @export
 * @interface GetMarketStatus200ResponseIndicesGroups
 */
export interface GetMarketStatus200ResponseIndicesGroups {
    /**
     * The status of Cboe Streaming Market Indices Cryptocurrency (\"CCCY\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'cccy'?: string;
    /**
     * The status of Cboe Global Indices (\"CGI\") trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'cgi'?: string;
    /**
     * The status of Dow Jones indices trading hours
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'dow_jones'?: string;
    /**
     * The status of Financial Times Stock Exchange Group (\"FTSE\") Russell indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'ftse_russell'?: string;
    /**
     * The status of Morgan Stanley Capital International (\"MSCI\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'msci'?: string;
    /**
     * The status of Morningstar (\"MSTAR\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'mstar'?: string;
    /**
     * The status of Morningstar Customer (\"MSTARC\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'mstarc'?: string;
    /**
     * The status of National Association of Securities Dealers Automated Quotations (\"Nasdaq\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'nasdaq'?: string;
    /**
     * The status of Standard & Poors\'s (\"S&P\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    's_and_p'?: string;
    /**
     * The status of Societe Generale indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'societe_generale'?: string;
}
/**
 * 
 * @export
 * @interface GetOptionsContract200Response
 */
export interface GetOptionsContract200Response {
    /**
     * 
     * @type {string}
     * @memberof GetOptionsContract200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {ListOptionsContracts200ResponseResultsInner}
     * @memberof GetOptionsContract200Response
     */
    'results'?: ListOptionsContracts200ResponseResultsInner;
    /**
     * 
     * @type {string}
     * @memberof GetOptionsContract200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetRelatedCompanies200Response
 */
export interface GetRelatedCompanies200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetRelatedCompanies200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetRelatedCompanies200ResponseResultsInner>}
     * @memberof GetRelatedCompanies200Response
     */
    'results'?: Array<GetRelatedCompanies200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetRelatedCompanies200Response
     */
    'status'?: string;
    /**
     * The ticker being queried.
     * @type {string}
     * @memberof GetRelatedCompanies200Response
     */
    'ticker'?: string;
}
/**
 * The tickers related to the requested ticker.
 * @export
 * @interface GetRelatedCompanies200ResponseResultsInner
 */
export interface GetRelatedCompanies200ResponseResultsInner {
    /**
     * A ticker related to the requested ticker.
     * @type {string}
     * @memberof GetRelatedCompanies200ResponseResultsInner
     */
    'ticker': string;
}
/**
 * 
 * @export
 * @interface GetTicker200Response
 */
export interface GetTicker200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetTicker200Response
     */
    'count'?: number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetTicker200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {GetTicker200ResponseResults}
     * @memberof GetTicker200Response
     */
    'results'?: GetTicker200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetTicker200Response
     */
    'status'?: string;
}
/**
 * Ticker with details.
 * @export
 * @interface GetTicker200ResponseResults
 */
export interface GetTicker200ResponseResults {
    /**
     * Whether or not the asset is actively traded. False means the asset has been delisted.
     * @type {boolean}
     * @memberof GetTicker200ResponseResults
     */
    'active': boolean;
    /**
     * 
     * @type {GetTicker200ResponseResultsAddress}
     * @memberof GetTicker200ResponseResults
     */
    'address'?: GetTicker200ResponseResultsAddress;
    /**
     * 
     * @type {GetTicker200ResponseResultsBranding}
     * @memberof GetTicker200ResponseResults
     */
    'branding'?: GetTicker200ResponseResultsBranding;
    /**
     * The CIK number for this ticker. Find more information [here](https://en.wikipedia.org/wiki/Central_Index_Key).
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'cik'?: string;
    /**
     * The composite OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'composite_figi'?: string;
    /**
     * The name of the currency that this asset is traded with.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'currency_name': string;
    /**
     * The last date that the asset was traded.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'delisted_utc'?: string;
    /**
     * A description of the company and what they do/offer.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'description'?: string;
    /**
     * The URL of the company\'s website homepage.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'homepage_url'?: string;
    /**
     * The date that the symbol was first publicly listed in the format YYYY-MM-DD.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'list_date'?: string;
    /**
     * The locale of the asset.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'locale': GetTicker200ResponseResultsLocaleEnum;
    /**
     * The market type of the asset.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'market': GetTicker200ResponseResultsMarketEnum;
    /**
     * The most recent close price of the ticker multiplied by weighted outstanding shares.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'market_cap'?: number;
    /**
     * The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'name': string;
    /**
     * The phone number for the company behind this ticker.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'phone_number'?: string;
    /**
     * The ISO code of the primary listing exchange for this asset.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'primary_exchange'?: string;
    /**
     * Round lot size of this security.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'round_lot'?: number;
    /**
     * The share Class OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'share_class_figi'?: string;
    /**
     * The recorded number of outstanding shares for this particular share class.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'share_class_shares_outstanding'?: number;
    /**
     * The standard industrial classification code for this ticker.  For a list of SIC Codes, see the SEC\'s <a rel=\"nofollow\" target=\"_blank\" href=\"https://www.sec.gov/info/edgar/siccodes.htm\">SIC Code List</a>.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'sic_code'?: string;
    /**
     * A description of this ticker\'s SIC code.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'sic_description'?: string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'ticker': string;
    /**
     * The root of a specified ticker. For example, the root of BRK.A is BRK.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'ticker_root'?: string;
    /**
     * The suffix of a specified ticker. For example, the suffix of BRK.A is A.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'ticker_suffix'?: string;
    /**
     * The approximate number of employees for the company.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'total_employees'?: number;
    /**
     * The type of the asset. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types).
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'type'?: string;
    /**
     * The shares outstanding calculated assuming all shares of other share classes are converted to this share class.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'weighted_shares_outstanding'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetTicker200ResponseResultsLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTicker200ResponseResultsMarketEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Fx = 'fx',
    Otc = 'otc',
    Indices = 'indices'
}

/**
 * Company headquarters address details.
 * @export
 * @interface GetTicker200ResponseResultsAddress
 */
export interface GetTicker200ResponseResultsAddress {
    /**
     * The first line of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'address1'?: string;
    /**
     * The second line of the company\'s headquarters address, if applicable.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'address2'?: string;
    /**
     * The city of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'city'?: string;
    /**
     * The postal code of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'postal_code'?: string;
    /**
     * The state of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'state'?: string;
}
/**
 * Provides URLs aiding in visual identification.
 * @export
 * @interface GetTicker200ResponseResultsBranding
 */
export interface GetTicker200ResponseResultsBranding {
    /**
     * A link to this ticker\'s company\'s icon. Icon\'s are generally smaller, square images that represent the company at a glance. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof GetTicker200ResponseResultsBranding
     */
    'icon_url'?: string;
    /**
     * A link to this ticker\'s company\'s logo. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof GetTicker200ResponseResultsBranding
     */
    'logo_url'?: string;
}
/**
 * 
 * @export
 * @interface IndexAggsBase
 */
export interface IndexAggsBase {
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof IndexAggsBase
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof IndexAggsBase
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof IndexAggsBase
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof IndexAggsBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface IndicesGroupedResults
 */
export interface IndicesGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsTickerIndicesTickerPrevGet200ResponseAllOfResultsInner>}
     * @memberof IndicesGroupedResults
     */
    'results'?: Array<V2AggsTickerIndicesTickerPrevGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface IndicesOpenClose
 */
export interface IndicesOpenClose {
    /**
     * The close value of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'afterHours'?: number;
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof IndicesOpenClose
     */
    'from': string;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'high': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'low': number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'open': number;
    /**
     * The open value of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof IndicesOpenClose
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof IndicesOpenClose
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface IndicesSnapshot200Response
 */
export interface IndicesSnapshot200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof IndicesSnapshot200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof IndicesSnapshot200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<IndicesSnapshot200ResponseResultsInner>}
     * @memberof IndicesSnapshot200Response
     */
    'results'?: Array<IndicesSnapshot200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof IndicesSnapshot200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface IndicesSnapshot200ResponseResultsInner
 */
export interface IndicesSnapshot200ResponseResultsInner {
    /**
     * The error while looking for this ticker.
     * @type {string}
     * @memberof IndicesSnapshot200ResponseResultsInner
     */
    'error'?: string;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof IndicesSnapshot200ResponseResultsInner
     */
    'last_updated'?: number;
    /**
     * The market status for the market that trades this ticker.
     * @type {string}
     * @memberof IndicesSnapshot200ResponseResultsInner
     */
    'market_status'?: string;
    /**
     * The error message while looking for this ticker.
     * @type {string}
     * @memberof IndicesSnapshot200ResponseResultsInner
     */
    'message'?: string;
    /**
     * Name of Index.
     * @type {string}
     * @memberof IndicesSnapshot200ResponseResultsInner
     */
    'name'?: string;
    /**
     * 
     * @type {IndicesSnapshot200ResponseResultsInnerSession}
     * @memberof IndicesSnapshot200ResponseResultsInner
     */
    'session'?: IndicesSnapshot200ResponseResultsInnerSession;
    /**
     * Ticker of asset queried.
     * @type {string}
     * @memberof IndicesSnapshot200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof IndicesSnapshot200ResponseResultsInner
     */
    'timeframe'?: IndicesSnapshot200ResponseResultsInnerTimeframeEnum;
    /**
     * The indices market.
     * @type {string}
     * @memberof IndicesSnapshot200ResponseResultsInner
     */
    'type'?: IndicesSnapshot200ResponseResultsInnerTypeEnum;
    /**
     * Value of Index.
     * @type {number}
     * @memberof IndicesSnapshot200ResponseResultsInner
     */
    'value'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum IndicesSnapshot200ResponseResultsInnerTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}
/**
    * @export
    * @enum {string}
    */
export enum IndicesSnapshot200ResponseResultsInnerTypeEnum {
    Indices = 'indices'
}

/**
 * Trading session metrics, detailing change percentages and key price points (open, close, high, low) for the asset within the current trading day.
 * @export
 * @interface IndicesSnapshot200ResponseResultsInnerSession
 */
export interface IndicesSnapshot200ResponseResultsInnerSession {
    /**
     * The value of the change for the index from the previous trading day.
     * @type {number}
     * @memberof IndicesSnapshot200ResponseResultsInnerSession
     */
    'change'?: number;
    /**
     * The percent of the change for the index from the previous trading day.
     * @type {number}
     * @memberof IndicesSnapshot200ResponseResultsInnerSession
     */
    'change_percent'?: number;
    /**
     * The closing value for the index of the day.
     * @type {number}
     * @memberof IndicesSnapshot200ResponseResultsInnerSession
     */
    'close'?: number;
    /**
     * The highest value for the index of the day.
     * @type {number}
     * @memberof IndicesSnapshot200ResponseResultsInnerSession
     */
    'high'?: number;
    /**
     * The lowest value for the index of the day.
     * @type {number}
     * @memberof IndicesSnapshot200ResponseResultsInnerSession
     */
    'low'?: number;
    /**
     * The open value for the index of the day.
     * @type {number}
     * @memberof IndicesSnapshot200ResponseResultsInnerSession
     */
    'open'?: number;
    /**
     * The closing value for the index of previous trading day.
     * @type {number}
     * @memberof IndicesSnapshot200ResponseResultsInnerSession
     */
    'previous_close'?: number;
}
/**
 * 
 * @export
 * @interface IndicesTickerResults
 */
export interface IndicesTickerResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<IndicesTickerResultsResultsInner>}
     * @memberof IndicesTickerResults
     */
    'results'?: Array<IndicesTickerResultsResultsInner>;
}
/**
 * 
 * @export
 * @interface IndicesTickerResultsResultsInner
 */
export interface IndicesTickerResultsResultsInner {
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'c': number;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'h': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'n'?: number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    't': number;
}
/**
 * 
 * @export
 * @interface LastQuote200Response
 */
export interface LastQuote200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof LastQuote200Response
     */
    'request_id': string;
    /**
     * 
     * @type {LastQuote200ResponseResults}
     * @memberof LastQuote200Response
     */
    'results'?: LastQuote200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof LastQuote200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface LastQuote200ResponseResults
 */
export interface LastQuote200ResponseResults {
    /**
     * The ask price.
     * @type {number}
     * @memberof LastQuote200ResponseResults
     */
    'P'?: number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof LastQuote200ResponseResults
     */
    'S'?: number;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof LastQuote200ResponseResults
     */
    'T': string;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof LastQuote200ResponseResults
     */
    'X'?: number;
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof LastQuote200ResponseResults
     */
    'c'?: Array<number>;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof LastQuote200ResponseResults
     */
    'f'?: number;
    /**
     * A list of indicator codes.
     * @type {Array<number>}
     * @memberof LastQuote200ResponseResults
     */
    'i'?: Array<number>;
    /**
     * The bid price.
     * @type {number}
     * @memberof LastQuote200ResponseResults
     */
    'p'?: number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
     * @type {number}
     * @memberof LastQuote200ResponseResults
     */
    'q': number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof LastQuote200ResponseResults
     */
    's'?: number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof LastQuote200ResponseResults
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof LastQuote200ResponseResults
     */
    'x'?: number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof LastQuote200ResponseResults
     */
    'y': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof LastQuote200ResponseResults
     */
    'z'?: number;
}
/**
 * 
 * @export
 * @interface LastQuoteCurrencies200Response
 */
export interface LastQuoteCurrencies200Response {
    /**
     * 
     * @type {RealTimeCurrencyConversion200ResponseLast}
     * @memberof LastQuoteCurrencies200Response
     */
    'last'?: RealTimeCurrencyConversion200ResponseLast;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof LastQuoteCurrencies200Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof LastQuoteCurrencies200Response
     */
    'status': string;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof LastQuoteCurrencies200Response
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface LastTradeCrypto200Response
 */
export interface LastTradeCrypto200Response {
    /**
     * 
     * @type {LastTradeCrypto200ResponseLast}
     * @memberof LastTradeCrypto200Response
     */
    'last'?: LastTradeCrypto200ResponseLast;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof LastTradeCrypto200Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof LastTradeCrypto200Response
     */
    'status': string;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof LastTradeCrypto200Response
     */
    'symbol': string;
}
/**
 * Contains the requested trade data for the specified cryptocurrency pair.
 * @export
 * @interface LastTradeCrypto200ResponseLast
 */
export interface LastTradeCrypto200ResponseLast {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof LastTradeCrypto200ResponseLast
     */
    'conditions'?: Array<number>;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\">Exchanges</a> for a mapping of exchanges to IDs.
     * @type {number}
     * @memberof LastTradeCrypto200ResponseLast
     */
    'exchange': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof LastTradeCrypto200ResponseLast
     */
    'price': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof LastTradeCrypto200ResponseLast
     */
    'size': number;
    /**
     * The Unix millisecond timestamp.
     * @type {number}
     * @memberof LastTradeCrypto200ResponseLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface LastTradeOptions200Response
 */
export interface LastTradeOptions200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof LastTradeOptions200Response
     */
    'request_id': string;
    /**
     * 
     * @type {LastTradeOptions200ResponseResults}
     * @memberof LastTradeOptions200Response
     */
    'results'?: LastTradeOptions200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof LastTradeOptions200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface LastTradeOptions200ResponseResults
 */
export interface LastTradeOptions200ResponseResults {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof LastTradeOptions200ResponseResults
     */
    'T': string;
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof LastTradeOptions200ResponseResults
     */
    'c'?: Array<number>;
    /**
     * The trade correction indicator.
     * @type {number}
     * @memberof LastTradeOptions200ResponseResults
     */
    'e'?: number;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof LastTradeOptions200ResponseResults
     */
    'f'?: number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
     * @type {string}
     * @memberof LastTradeOptions200ResponseResults
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof LastTradeOptions200ResponseResults
     */
    'p': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
     * @type {number}
     * @memberof LastTradeOptions200ResponseResults
     */
    'q': number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place.
     * @type {number}
     * @memberof LastTradeOptions200ResponseResults
     */
    'r'?: number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof LastTradeOptions200ResponseResults
     */
    's'?: number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof LastTradeOptions200ResponseResults
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof LastTradeOptions200ResponseResults
     */
    'x': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof LastTradeOptions200ResponseResults
     */
    'y': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof LastTradeOptions200ResponseResults
     */
    'z'?: number;
}
/**
 * 
 * @export
 * @interface ListConditions200Response
 */
export interface ListConditions200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListConditions200Response
     */
    'count': number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListConditions200Response
     */
    'next_url'?: string;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListConditions200Response
     */
    'request_id': string;
    /**
     * An array of conditions that match your query.
     * @type {Array<ListConditions200ResponseResultsInner>}
     * @memberof ListConditions200Response
     */
    'results': Array<ListConditions200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListConditions200Response
     */
    'status': string;
}
/**
 * A condition generally refers to any extra information passed in a trade or a quote. These conditions may or may not affect the behavior of aggregates.
 * @export
 * @interface ListConditions200ResponseResultsInner
 */
export interface ListConditions200ResponseResultsInner {
    /**
     * A commonly-used abbreviation for this condition.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'abbreviation'?: string;
    /**
     * An identifier for a group of similar financial instruments.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'asset_class': ListConditions200ResponseResultsInnerAssetClassEnum;
    /**
     * Data types that this condition applies to.
     * @type {Array<string>}
     * @memberof ListConditions200ResponseResultsInner
     */
    'data_types': Array<ListConditions200ResponseResultsInnerDataTypesEnum>;
    /**
     * A short description of the semantics of this condition.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'description'?: string;
    /**
     * If present, mapping this condition from a Polygon.io code to a SIP symbol depends on this attribute. In other words, data with this condition attached comes exclusively from the given exchange.
     * @type {number}
     * @memberof ListConditions200ResponseResultsInner
     */
    'exchange'?: number;
    /**
     * An identifier used by Polygon.io for this condition. Unique per data type.
     * @type {number}
     * @memberof ListConditions200ResponseResultsInner
     */
    'id': number;
    /**
     * If true, this condition is from an old version of the SIPs\' specs and no longer is used. Other conditions may or may not reuse the same symbol as this one.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInner
     */
    'legacy'?: boolean;
    /**
     * The name of this condition.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'name': string;
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerSipMapping}
     * @memberof ListConditions200ResponseResultsInner
     */
    'sip_mapping': ListConditions200ResponseResultsInnerSipMapping;
    /**
     * An identifier for a collection of related conditions.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'type': ListConditions200ResponseResultsInnerTypeEnum;
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerUpdateRules}
     * @memberof ListConditions200ResponseResultsInner
     */
    'update_rules'?: ListConditions200ResponseResultsInnerUpdateRules;
}

/**
    * @export
    * @enum {string}
    */
export enum ListConditions200ResponseResultsInnerAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx'
}
/**
    * @export
    * @enum {string}
    */
export enum ListConditions200ResponseResultsInnerDataTypesEnum {
    Trade = 'trade',
    Bbo = 'bbo',
    Nbbo = 'nbbo'
}
/**
    * @export
    * @enum {string}
    */
export enum ListConditions200ResponseResultsInnerTypeEnum {
    SaleCondition = 'sale_condition',
    QuoteCondition = 'quote_condition',
    SipGeneratedFlag = 'sip_generated_flag',
    FinancialStatusIndicator = 'financial_status_indicator',
    ShortSaleRestrictionIndicator = 'short_sale_restriction_indicator',
    SettlementCondition = 'settlement_condition',
    MarketCondition = 'market_condition',
    TradeThruExempt = 'trade_thru_exempt'
}

/**
 * A comprehensive mapping that translates condition codes from individual SIPs (CTA, OPRA, UTP) to a unified code used by Polygon.io. This facilitates consistent interpretation and application of market data conditions across different data streams, ensuring that users can accurately apply these conditions to their data analysis and reporting.
 * @export
 * @interface ListConditions200ResponseResultsInnerSipMapping
 */
export interface ListConditions200ResponseResultsInnerSipMapping {
    /**
     * Condition code from the Consolidated Tape Association (CTA).
     * @type {string}
     * @memberof ListConditions200ResponseResultsInnerSipMapping
     */
    'CTA'?: string;
    /**
     * Condition code from the Options Price Reporting Authority (OPRA).
     * @type {string}
     * @memberof ListConditions200ResponseResultsInnerSipMapping
     */
    'OPRA'?: string;
    /**
     * Condition code from UTP Plan (UTP).
     * @type {string}
     * @memberof ListConditions200ResponseResultsInnerSipMapping
     */
    'UTP'?: string;
}
/**
 * A list of aggregation rules.
 * @export
 * @interface ListConditions200ResponseResultsInnerUpdateRules
 */
export interface ListConditions200ResponseResultsInnerUpdateRules {
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerUpdateRulesConsolidated}
     * @memberof ListConditions200ResponseResultsInnerUpdateRules
     */
    'consolidated': ListConditions200ResponseResultsInnerUpdateRulesConsolidated;
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerUpdateRulesMarketCenter}
     * @memberof ListConditions200ResponseResultsInnerUpdateRules
     */
    'market_center': ListConditions200ResponseResultsInnerUpdateRulesMarketCenter;
}
/**
 * Describes aggregation rules on a consolidated (all exchanges) basis.
 * @export
 * @interface ListConditions200ResponseResultsInnerUpdateRulesConsolidated
 */
export interface ListConditions200ResponseResultsInnerUpdateRulesConsolidated {
    /**
     * Whether or not trades with this condition update the high/low.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesConsolidated
     */
    'updates_high_low': boolean;
    /**
     * Whether or not trades with this condition update the open/close.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesConsolidated
     */
    'updates_open_close': boolean;
    /**
     * Whether or not trades with this condition update the volume.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesConsolidated
     */
    'updates_volume': boolean;
}
/**
 * Describes aggregation rules on a per-market-center basis.
 * @export
 * @interface ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
 */
export interface ListConditions200ResponseResultsInnerUpdateRulesMarketCenter {
    /**
     * Whether or not trades with this condition update the high/low.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
     */
    'updates_high_low': boolean;
    /**
     * Whether or not trades with this condition update the open/close.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
     */
    'updates_open_close': boolean;
    /**
     * Whether or not trades with this condition update the volume.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
     */
    'updates_volume': boolean;
}
/**
 * 
 * @export
 * @interface ListConditions400Response
 */
export interface ListConditions400Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListConditions400Response
     */
    'count': number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListConditions400Response
     */
    'next_url'?: string;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListConditions400Response
     */
    'request_id': string;
    /**
     * An array of conditions that match your query.
     * @type {Array<ListConditions200ResponseResultsInner>}
     * @memberof ListConditions400Response
     */
    'results': Array<ListConditions200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListConditions400Response
     */
    'status': string;
}
/**
 * A list of dividends.
 * @export
 * @interface ListDividends200Response
 */
export interface ListDividends200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListDividends200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListDividends200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListDividends200ResponseResultsInner>}
     * @memberof ListDividends200Response
     */
    'results'?: Array<ListDividends200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListDividends200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListDividends200ResponseResultsInner
 */
export interface ListDividends200ResponseResultsInner {
    /**
     * The cash amount of the dividend per share owned.
     * @type {number}
     * @memberof ListDividends200ResponseResultsInner
     */
    'cash_amount': number;
    /**
     * The currency in which the dividend is paid.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * The date that the dividend was announced.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'declaration_date'?: string;
    /**
     * The type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC. Long-Term and Short-Term capital gain distributions are denoted as LT and ST, respectively.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'dividend_type': ListDividends200ResponseResultsInnerDividendTypeEnum;
    /**
     * The date that the stock first trades without the dividend, determined by the exchange.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'ex_dividend_date': string;
    /**
     * The number of times per year the dividend is paid out. Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
     * @type {number}
     * @memberof ListDividends200ResponseResultsInner
     */
    'frequency': number;
    /**
     * The unique identifier of the dividend.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'id': string;
    /**
     * The date that the dividend is paid out.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'pay_date'?: string;
    /**
     * The date that the stock must be held to receive the dividend, set by the company.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'record_date'?: string;
    /**
     * The ticker symbol of the dividend.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListDividends200ResponseResultsInnerDividendTypeEnum {
    Cd = 'CD',
    Sc = 'SC',
    Lt = 'LT',
    St = 'ST'
}

/**
 * 
 * @export
 * @interface ListExchanges200Response
 */
export interface ListExchanges200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListExchanges200Response
     */
    'count'?: number;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListExchanges200Response
     */
    'request_id': string;
    /**
     * 
     * @type {Array<ListExchanges200ResponseResultsInner>}
     * @memberof ListExchanges200Response
     */
    'results'?: Array<ListExchanges200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListExchanges200Response
     */
    'status': string;
}
/**
 * An entity that reports trades.
 * @export
 * @interface ListExchanges200ResponseResultsInner
 */
export interface ListExchanges200ResponseResultsInner {
    /**
     * A commonly used abbreviation for this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'acronym'?: string;
    /**
     * An identifier for a group of similar financial instruments.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'asset_class': ListExchanges200ResponseResultsInnerAssetClassEnum;
    /**
     * A unique identifier used by Polygon.io for this exchange.
     * @type {number}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'id': number;
    /**
     * An identifier for a geographical location.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'locale': ListExchanges200ResponseResultsInnerLocaleEnum;
    /**
     * The Market Identifier Code of this exchange (see ISO 10383).
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'mic'?: string;
    /**
     * Name of this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'name': string;
    /**
     * The MIC of the entity that operates this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'operating_mic'?: string;
    /**
     * The ID used by SIP\'s to represent this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'participant_id'?: string;
    /**
     * Represents the type of exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'type': ListExchanges200ResponseResultsInnerTypeEnum;
    /**
     * A link to this exchange\'s website, if one exists.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'url'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListExchanges200ResponseResultsInnerAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx'
}
/**
    * @export
    * @enum {string}
    */
export enum ListExchanges200ResponseResultsInnerLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
    * @export
    * @enum {string}
    */
export enum ListExchanges200ResponseResultsInnerTypeEnum {
    Exchange = 'exchange',
    Trf = 'TRF',
    Sip = 'SIP'
}

/**
 * 
 * @export
 * @interface ListExchanges400Response
 */
export interface ListExchanges400Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListExchanges400Response
     */
    'count'?: number;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListExchanges400Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListExchanges400Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ListFinancials200Response
 */
export interface ListFinancials200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListFinancials200Response
     */
    'count': number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListFinancials200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListFinancials200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListFinancials200ResponseResultsInner>}
     * @memberof ListFinancials200Response
     */
    'results': Array<ListFinancials200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListFinancials200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ListFinancials200ResponseResultsInner
 */
export interface ListFinancials200ResponseResultsInner {
    /**
     * The datetime (EST timezone) the filing was accepted by EDGAR in YYYYMMDDHHMMSS format.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'acceptance_datetime'?: string;
    /**
     * The CIK number for the company.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'cik': string;
    /**
     * The company name.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'company_name': string;
    /**
     * The end date of the period that these financials cover in YYYYMMDD format.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'end_date'?: string;
    /**
     * The date that the SEC filing which these financials were derived from was made available. Note that this is not necessarily the date when this information became public, as some companies may publish a press release before filing with the SEC.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'filing_date'?: string;
    /**
     * 
     * @type {ListFinancials200ResponseResultsInnerFinancials}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'financials': ListFinancials200ResponseResultsInnerFinancials;
    /**
     * Fiscal period of the report according to the company (Q1, Q2, Q3, Q4, or FY).
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'fiscal_period': string;
    /**
     * Fiscal year of the report according to the company.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'fiscal_year'?: string;
    /**
     * The Standard Industrial Classification (SIC) code for the company.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'sic'?: string;
    /**
     * The URL of the specific XBRL instance document within the SEC filing that these financials were derived from.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'source_filing_file_url'?: string;
    /**
     * The URL of the SEC filing that these financials were derived from.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'source_filing_url'?: string;
    /**
     * The start date of the period that these financials cover in YYYYMMDD format.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'start_date'?: string;
    /**
     * The list of ticker symbols for the company.
     * @type {Array<string>}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'tickers'?: Array<string>;
    /**
     * The timeframe of the report (quarterly, annual or ttm).
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'timeframe': string;
}
/**
 * Structured financial statements with detailed data points and metadata.
 * @export
 * @interface ListFinancials200ResponseResultsInnerFinancials
 */
export interface ListFinancials200ResponseResultsInnerFinancials {
    /**
     * 
     * @type {ListFinancials200ResponseResultsInnerFinancialsBalanceSheet}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'balance_sheet'?: ListFinancials200ResponseResultsInnerFinancialsBalanceSheet;
    /**
     * Cash flow statement. The keys in this object can be any of the fields listed in the Cash Flow Statement section of the <a target=\"_blank\" href=\"https://polygon.io/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>. See the attributes of the objects within `balance_sheet` for more details.
     * @type {object}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'cash_flow_statement'?: object;
    /**
     * Comprehensive income. The keys in this object can be any of the fields listed in the Comprehensive Income section of the <a target=\"_blank\" href=\"https://polygon.io/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>. See the attributes of the objects within `balance_sheet` for more details.
     * @type {object}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'comprehensive_income'?: object;
    /**
     * Income statement. The keys in this object can be any of the fields listed in the Income Statement section of the <a target=\"_blank\" href=\"https://polygon.io/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>. See the attributes of the objects within `balance_sheet` for more details.
     * @type {object}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'income_statement'?: object;
}
/**
 * Balance sheet. The keys in this object can be any of the fields listed in the Balance Sheet section of the <a target=\"_blank\" href=\"https://polygon.io/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>.
 * @export
 * @interface ListFinancials200ResponseResultsInnerFinancialsBalanceSheet
 */
export interface ListFinancials200ResponseResultsInnerFinancialsBalanceSheet {
    /**
     * 
     * @type {ListFinancials200ResponseResultsInnerFinancialsBalanceSheet}
     * @memberof ListFinancials200ResponseResultsInnerFinancialsBalanceSheet
     */
    '*'?: ListFinancials200ResponseResultsInnerFinancialsBalanceSheet;
}
/**
 * 
 * @export
 * @interface ListIPOs200Response
 */
export interface ListIPOs200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListIPOs200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListIPOs200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListIPOs200ResponseResultsInner>}
     * @memberof ListIPOs200Response
     */
    'results'?: Array<ListIPOs200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListIPOs200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListIPOs200ResponseResultsInner
 */
export interface ListIPOs200ResponseResultsInner {
    /**
     * The date when the IPO event was announced.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'announced_date'?: string;
    /**
     * Underlying currency of the security.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'currency_code'?: string;
    /**
     * The price set by the company and its underwriters before the IPO goes live.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'final_issue_price'?: number;
    /**
     * The highest price within the IPO price range that the company might use to price the shares.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'highest_offer_price'?: number;
    /**
     * The status of the IPO event. IPO events start out as status \"rumor\" or \"pending\". On listing day, the status changes to \"new\". After the listing day, the status changes to \"history\".  The status \"direct_listing_process\" corresponds to a type of offering where, instead of going through all the IPO processes, the company decides to list its shares directly on an exchange, without using an investment bank or other intermediaries. This is called a direct listing, direct placement, or direct public offering (DPO).
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'ipo_status': ListIPOs200ResponseResultsInnerIpoStatusEnum;
    /**
     * International Securities Identification Number. This is a unique twelve-digit code that is assigned to every security issuance in the world.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'isin'?: string;
    /**
     * Name of issuer.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'issuer_name': string;
    /**
     * The date when the IPO event was last modified.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'last_updated': string;
    /**
     * First trading date for the newly listed entity.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'listing_date'?: string;
    /**
     * The minimum number of shares that can be bought or sold in a single transaction.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'lot_size'?: number;
    /**
     * The lowest price within the IPO price range that the company is willing to offer its shares to investors.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'lowest_offer_price'?: number;
    /**
     * The upper limit of the shares that the company is offering to investors.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'max_shares_offered'?: number;
    /**
     * The lower limit of shares that the company is willing to sell in the IPO.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'min_shares_offered'?: number;
    /**
     * Market Identifier Code (MIC) of the primary exchange where the security is listed. The Market Identifier Code (MIC) (ISO 10383) is a unique identification code used to identify securities trading exchanges, regulated and non-regulated trading markets.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'primary_exchange'?: string;
    /**
     * Description of the security.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'security_description'?: string;
    /**
     * The classification of the stock. For example, \"CS\" stands for Common Stock.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'security_type': string;
    /**
     * The total number of shares that the company has issued and are held by investors.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'shares_outstanding'?: number;
    /**
     * The ticker symbol of the IPO event.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The total amount raised by the company for IPO.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'total_offer_size'?: number;
    /**
     * This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'us_code'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListIPOs200ResponseResultsInnerIpoStatusEnum {
    DirectListingProcess = 'direct_listing_process',
    History = 'history',
    New = 'new',
    Pending = 'pending',
    Postponed = 'postponed',
    Rumor = 'rumor',
    Withdrawn = 'withdrawn'
}

/**
 * 
 * @export
 * @interface ListNews200Response
 */
export interface ListNews200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListNews200Response
     */
    'count'?: number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListNews200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListNews200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListNews200ResponseResultsInner>}
     * @memberof ListNews200Response
     */
    'results'?: Array<ListNews200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListNews200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListNews200ResponseResultsInner
 */
export interface ListNews200ResponseResultsInner {
    /**
     * The mobile friendly Accelerated Mobile Page (AMP) URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'amp_url'?: string;
    /**
     * A link to the news article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'article_url': string;
    /**
     * The article\'s author.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'author': string;
    /**
     * A description of the article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'description'?: string;
    /**
     * Unique identifier for the article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'id': string;
    /**
     * The article\'s image URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'image_url'?: string;
    /**
     * The insights related to the article.
     * @type {Array<ListNews200ResponseResultsInnerInsightsInner>}
     * @memberof ListNews200ResponseResultsInner
     */
    'insights'?: Array<ListNews200ResponseResultsInnerInsightsInner>;
    /**
     * The keywords associated with the article (which will vary depending on the publishing source).
     * @type {Array<string>}
     * @memberof ListNews200ResponseResultsInner
     */
    'keywords'?: Array<string>;
    /**
     * The UTC date and time when the article was published, formatted in RFC3339 standard (e.g. YYYY-MM-DDTHH:MM:SSZ).
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'published_utc': string;
    /**
     * 
     * @type {ListNews200ResponseResultsInnerPublisher}
     * @memberof ListNews200ResponseResultsInner
     */
    'publisher': ListNews200ResponseResultsInnerPublisher;
    /**
     * The ticker symbols associated with the article.
     * @type {Array<string>}
     * @memberof ListNews200ResponseResultsInner
     */
    'tickers': Array<string>;
    /**
     * The title of the news article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ListNews200ResponseResultsInnerInsightsInner
 */
export interface ListNews200ResponseResultsInnerInsightsInner {
    /**
     * The sentiment of the insight.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerInsightsInner
     */
    'sentiment': ListNews200ResponseResultsInnerInsightsInnerSentimentEnum;
    /**
     * The reasoning behind the sentiment.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerInsightsInner
     */
    'sentiment_reasoning': string;
    /**
     * The ticker symbol associated with the insight.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerInsightsInner
     */
    'ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListNews200ResponseResultsInnerInsightsInnerSentimentEnum {
    Positive = 'positive',
    Neutral = 'neutral',
    Negative = 'negative'
}

/**
 * Details the source of the news article, including the publisher\'s name, logo, and homepage URLs. This information helps users identify and access the original source of news content.
 * @export
 * @interface ListNews200ResponseResultsInnerPublisher
 */
export interface ListNews200ResponseResultsInnerPublisher {
    /**
     * The publisher\'s homepage favicon URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'favicon_url'?: string;
    /**
     * The publisher\'s homepage URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'homepage_url': string;
    /**
     * The publisher\'s logo URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'logo_url': string;
    /**
     * The publisher\'s name.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'name': string;
}
/**
 * @type ListNewsPublishedUtcParameter
 * @export
 */
export type ListNewsPublishedUtcParameter = string;

/**
 * 
 * @export
 * @interface ListOptionsContracts200Response
 */
export interface ListOptionsContracts200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListOptionsContracts200Response
     */
    'next_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListOptionsContracts200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {Array<ListOptionsContracts200ResponseResultsInner>}
     * @memberof ListOptionsContracts200Response
     */
    'results'?: Array<ListOptionsContracts200ResponseResultsInner>;
    /**
     * 
     * @type {string}
     * @memberof ListOptionsContracts200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListOptionsContracts200ResponseResultsInner
 */
export interface ListOptionsContracts200ResponseResultsInner {
    /**
     * If an option contract has additional underlyings or deliverables associated with it, they will appear here. See <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"https://www.optionseducation.org/referencelibrary/faq/splits-mergers-spinoffs-bankruptcies\">here</a> for some examples of what might cause a contract to have additional underlyings.
     * @type {Array<ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner>}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'additional_underlyings'?: Array<ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner>;
    /**
     * The 6 letter CFI code of the contract (defined in <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/ISO_10962\">ISO 10962</a>)
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'cfi'?: string;
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'contract_type'?: string;
    /**
     * The correction number for this option contract.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'correction'?: number;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'exercise_style'?: ListOptionsContracts200ResponseResultsInnerExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'expiration_date'?: string;
    /**
     * The MIC code of the primary exchange that this contract is listed on.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'primary_exchange'?: string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'shares_per_contract'?: number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'strike_price'?: number;
    /**
     * The ticker for the option contract.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The underlying ticker that the option contract relates to.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'underlying_ticker'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListOptionsContracts200ResponseResultsInnerExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * 
 * @export
 * @interface ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
 */
export interface ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner {
    /**
     * The number of shares per contract of the additional underlying, or the cash-in-lieu amount of the currency.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
     */
    'amount'?: number;
    /**
     * The type of the additional underlying asset, either equity or currency.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
     */
    'type'?: string;
    /**
     * The name of the additional underlying asset.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
     */
    'underlying'?: string;
}
/**
 * 
 * @export
 * @interface ListStockSplits200Response
 */
export interface ListStockSplits200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListStockSplits200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListStockSplits200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListStockSplits200ResponseResultsInner>}
     * @memberof ListStockSplits200Response
     */
    'results'?: Array<ListStockSplits200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListStockSplits200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListStockSplits200ResponseResultsInner
 */
export interface ListStockSplits200ResponseResultsInner {
    /**
     * The execution date of the stock split. On this date the stock split was applied.
     * @type {string}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'execution_date': string;
    /**
     * The unique identifier for this stock split.
     * @type {string}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'id': string;
    /**
     * The second number in the split ratio.  For example: In a 2-for-1 split, split_from would be 1.
     * @type {number}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'split_from': number;
    /**
     * The first number in the split ratio.  For example: In a 2-for-1 split, split_to would be 2.
     * @type {number}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'split_to': number;
    /**
     * The ticker symbol of the stock split.
     * @type {string}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'ticker': string;
}
/**
 * 
 * @export
 * @interface ListTickerTypes200Response
 */
export interface ListTickerTypes200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListTickerTypes200Response
     */
    'count'?: number;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListTickerTypes200Response
     */
    'request_id': string;
    /**
     * 
     * @type {Array<ListTickerTypes200ResponseResultsInner>}
     * @memberof ListTickerTypes200Response
     */
    'results'?: Array<ListTickerTypes200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListTickerTypes200Response
     */
    'status': string;
}
/**
 * Describes the type of financial instrument represented by a ticker.
 * @export
 * @interface ListTickerTypes200ResponseResultsInner
 */
export interface ListTickerTypes200ResponseResultsInner {
    /**
     * An identifier for a group of similar financial instruments.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'asset_class': ListTickerTypes200ResponseResultsInnerAssetClassEnum;
    /**
     * A code used by Polygon.io to refer to this ticker type.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'code': string;
    /**
     * A short description of this ticker type.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'description': string;
    /**
     * An identifier for a geographical location.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'locale': ListTickerTypes200ResponseResultsInnerLocaleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ListTickerTypes200ResponseResultsInnerAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx',
    Indices = 'indices'
}
/**
    * @export
    * @enum {string}
    */
export enum ListTickerTypes200ResponseResultsInnerLocaleEnum {
    Us = 'us',
    Global = 'global'
}

/**
 * 
 * @export
 * @interface ListTickers200Response
 */
export interface ListTickers200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListTickers200Response
     */
    'count'?: number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListTickers200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListTickers200Response
     */
    'request_id'?: string;
    /**
     * An array of tickers that match your query.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
     * @type {Array<ListTickers200ResponseResultsInner>}
     * @memberof ListTickers200Response
     */
    'results'?: Array<ListTickers200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListTickers200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListTickers200ResponseResultsInner
 */
export interface ListTickers200ResponseResultsInner {
    /**
     * Whether or not the asset is actively traded. False means the asset has been delisted.
     * @type {boolean}
     * @memberof ListTickers200ResponseResultsInner
     */
    'active'?: boolean;
    /**
     * The CIK number for this ticker. Find more information [here](https://en.wikipedia.org/wiki/Central_Index_Key).
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'cik'?: string;
    /**
     * The composite OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'composite_figi'?: string;
    /**
     * The name of the currency that this asset is traded with.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'currency_name'?: string;
    /**
     * The last date that the asset was traded.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'delisted_utc'?: string;
    /**
     * The information is accurate up to this time.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'last_updated_utc'?: string;
    /**
     * The locale of the asset.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'locale': ListTickers200ResponseResultsInnerLocaleEnum;
    /**
     * The market type of the asset.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'market': ListTickers200ResponseResultsInnerMarketEnum;
    /**
     * The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'name': string;
    /**
     * The ISO code of the primary listing exchange for this asset.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'primary_exchange'?: string;
    /**
     * The share Class OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'share_class_figi'?: string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The type of the asset. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types).
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'type'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListTickers200ResponseResultsInnerLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
    * @export
    * @enum {string}
    */
export enum ListTickers200ResponseResultsInnerMarketEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Fx = 'fx',
    Otc = 'otc',
    Indices = 'indices'
}

/**
 * 
 * @export
 * @interface Locales
 */
export interface Locales {
    /**
     * 
     * @type {Array<LocalesResultsInner>}
     * @memberof Locales
     */
    'results'?: Array<LocalesResultsInner>;
}
/**
 * 
 * @export
 * @interface LocalesResultsInner
 */
export interface LocalesResultsInner {
    /**
     * An abbreviated country name.
     * @type {string}
     * @memberof LocalesResultsInner
     */
    'locale'?: string;
    /**
     * The name of the country.
     * @type {string}
     * @memberof LocalesResultsInner
     */
    'name'?: string;
}
/**
 * A dynamic key from the results set
 * @export
 * @interface MapKey
 */
export interface MapKey {
    /**
     * The descriptive name of this results key
     * @type {string}
     * @memberof MapKey
     */
    'name'?: string;
    /**
     * The data type of this results key
     * @type {string}
     * @memberof MapKey
     */
    'type'?: MapKeyTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum MapKeyTypeEnum {
    String = 'string',
    Int = 'int',
    Int64 = 'int64',
    Float64 = 'float64'
}

/**
 * 
 * @export
 * @interface MarketHolidayInner
 */
export interface MarketHolidayInner {
    /**
     * The market close time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'close'?: string;
    /**
     * The date of the holiday.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'date': string;
    /**
     * Which market the record is for.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'exchange': string;
    /**
     * The name of the holiday.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'name': string;
    /**
     * The market open time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'open'?: string;
    /**
     * The status of the market on the holiday.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface MarketStatus
 */
export interface MarketStatus {
    /**
     * Whether or not the market is in post-market hours.
     * @type {boolean}
     * @memberof MarketStatus
     */
    'afterHours'?: boolean;
    /**
     * 
     * @type {MarketStatusCurrencies}
     * @memberof MarketStatus
     */
    'currencies'?: MarketStatusCurrencies;
    /**
     * Whether or not the market is in pre-market hours.
     * @type {boolean}
     * @memberof MarketStatus
     */
    'earlyHours'?: boolean;
    /**
     * 
     * @type {MarketStatusExchanges}
     * @memberof MarketStatus
     */
    'exchanges'?: MarketStatusExchanges;
    /**
     * The status of the market as a whole.
     * @type {string}
     * @memberof MarketStatus
     */
    'market'?: string;
    /**
     * The current time of the server.
     * @type {string}
     * @memberof MarketStatus
     */
    'serverTime'?: string;
}
/**
 * 
 * @export
 * @interface MarketStatusCurrencies
 */
export interface MarketStatusCurrencies {
    /**
     * The status of the crypto market.
     * @type {string}
     * @memberof MarketStatusCurrencies
     */
    'crypto'?: string;
    /**
     * The status of the forex market.
     * @type {string}
     * @memberof MarketStatusCurrencies
     */
    'fx'?: string;
}
/**
 * 
 * @export
 * @interface MarketStatusExchanges
 */
export interface MarketStatusExchanges {
    /**
     * The status of the Nasdaq market.
     * @type {string}
     * @memberof MarketStatusExchanges
     */
    'nasdaq'?: string;
    /**
     * The status of the NYSE market.
     * @type {string}
     * @memberof MarketStatusExchanges
     */
    'nyse'?: string;
    /**
     * The status of the OTC market.
     * @type {string}
     * @memberof MarketStatusExchanges
     */
    'otc'?: string;
}
/**
 * 
 * @export
 * @interface Markets
 */
export interface Markets {
    /**
     * A list of supported markets.
     * @type {Array<MarketsResultsInner>}
     * @memberof Markets
     */
    'results'?: Array<MarketsResultsInner>;
}
/**
 * 
 * @export
 * @interface MarketsResultsInner
 */
export interface MarketsResultsInner {
    /**
     * A description of the market.
     * @type {string}
     * @memberof MarketsResultsInner
     */
    'desc'?: string;
    /**
     * The name of the market.
     * @type {string}
     * @memberof MarketsResultsInner
     */
    'market'?: string;
}
/**
 * @type ModelDate
 * @export
 */
export type ModelDate = string;

/**
 * A mapping of the keys returned in the results to their descriptive name and data types.
 * @export
 * @interface ModelMap
 */
export interface ModelMap {
    /**
     * 
     * @type {MapKey}
     * @memberof ModelMap
     */
    'key'?: MapKey;
}
/**
 * 
 * @export
 * @interface NewsInner
 */
export interface NewsInner {
    /**
     * A URL of the image for the news article, if found.
     * @type {string}
     * @memberof NewsInner
     */
    'image'?: string;
    /**
     * A list of common keywords related to the news article.
     * @type {Array<string>}
     * @memberof NewsInner
     */
    'keywords'?: Array<string>;
    /**
     * The publication source of the article.
     * @type {string}
     * @memberof NewsInner
     */
    'source'?: string;
    /**
     * A summary of the news article.
     * @type {string}
     * @memberof NewsInner
     */
    'summary'?: string;
    /**
     * A list of ticker symbols relating to the article.
     * @type {Array<string>}
     * @memberof NewsInner
     */
    'symbols'?: Array<string>;
    /**
     * The timestamp of the news article.
     * @type {string}
     * @memberof NewsInner
     */
    'timestamp'?: string;
    /**
     * The title of the news article.
     * @type {string}
     * @memberof NewsInner
     */
    'title'?: string;
    /**
     * A direct link to the news article from its source publication.
     * @type {string}
     * @memberof NewsInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface OptionContract200Response
 */
export interface OptionContract200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof OptionContract200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof OptionContract200Response
     */
    'request_id': string;
    /**
     * 
     * @type {OptionsChain200ResponseResultsInner}
     * @memberof OptionContract200Response
     */
    'results'?: OptionsChain200ResponseResultsInner;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof OptionContract200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface OptionsChain200Response
 */
export interface OptionsChain200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof OptionsChain200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof OptionsChain200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<OptionsChain200ResponseResultsInner>}
     * @memberof OptionsChain200Response
     */
    'results'?: Array<OptionsChain200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof OptionsChain200Response
     */
    'status': string;
}
/**
 * Contains the requested snapshot data for the specified contract.
 * @export
 * @interface OptionsChain200ResponseResultsInner
 */
export interface OptionsChain200ResponseResultsInner {
    /**
     * The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInner
     */
    'break_even_price': number;
    /**
     * 
     * @type {OptionsChain200ResponseResultsInnerDay}
     * @memberof OptionsChain200ResponseResultsInner
     */
    'day': OptionsChain200ResponseResultsInnerDay;
    /**
     * 
     * @type {OptionsChain200ResponseResultsInnerDetails}
     * @memberof OptionsChain200ResponseResultsInner
     */
    'details': OptionsChain200ResponseResultsInnerDetails;
    /**
     * Fair market value is only available on Business plans. It\'s it our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {Snapshots200ResponseResultsInnerGreeks}
     * @memberof OptionsChain200ResponseResultsInner
     */
    'greeks'?: Snapshots200ResponseResultsInnerGreeks;
    /**
     * The market\'s forecast for the volatility of the underlying asset, based on this option\'s current price.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInner
     */
    'implied_volatility'?: number;
    /**
     * 
     * @type {OptionsChain200ResponseResultsInnerLastQuote}
     * @memberof OptionsChain200ResponseResultsInner
     */
    'last_quote': OptionsChain200ResponseResultsInnerLastQuote;
    /**
     * 
     * @type {OptionsChain200ResponseResultsInnerLastTrade}
     * @memberof OptionsChain200ResponseResultsInner
     */
    'last_trade'?: OptionsChain200ResponseResultsInnerLastTrade;
    /**
     * The quantity of this contract held at the end of the last trading day.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInner
     */
    'open_interest': number;
    /**
     * 
     * @type {Snapshots200ResponseResultsInnerUnderlyingAsset}
     * @memberof OptionsChain200ResponseResultsInner
     */
    'underlying_asset': Snapshots200ResponseResultsInnerUnderlyingAsset;
}
/**
 * The most recent daily bar for this contract.
 * @export
 * @interface OptionsChain200ResponseResultsInnerDay
 */
export interface OptionsChain200ResponseResultsInnerDay {
    /**
     * The value of the price change for the contract from the previous trading day.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDay
     */
    'change': number;
    /**
     * The percent of the price change for the contract from the previous trading day.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDay
     */
    'change_percent': number;
    /**
     * The closing price for the contract of the day.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDay
     */
    'close': number;
    /**
     * The highest price for the contract of the day.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDay
     */
    'high': number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDay
     */
    'last_updated'?: number;
    /**
     * The lowest price for the contract of the day.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDay
     */
    'low': number;
    /**
     * The open price for the contract of the day.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDay
     */
    'open': number;
    /**
     * The closing price for the contract of previous trading day.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDay
     */
    'previous_close': number;
    /**
     * The trading volume for the contract of the day.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDay
     */
    'volume': number;
    /**
     * The trading volume weighted average price for the contract of the day.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDay
     */
    'vwap': number;
}
/**
 * The details for this contract.
 * @export
 * @interface OptionsChain200ResponseResultsInnerDetails
 */
export interface OptionsChain200ResponseResultsInnerDetails {
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof OptionsChain200ResponseResultsInnerDetails
     */
    'contract_type': OptionsChain200ResponseResultsInnerDetailsContractTypeEnum;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof OptionsChain200ResponseResultsInnerDetails
     */
    'exercise_style': OptionsChain200ResponseResultsInnerDetailsExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof OptionsChain200ResponseResultsInnerDetails
     */
    'expiration_date': string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDetails
     */
    'shares_per_contract': number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerDetails
     */
    'strike_price': number;
    /**
     * The ticker symbol for the asset.
     * @type {string}
     * @memberof OptionsChain200ResponseResultsInnerDetails
     */
    'ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum OptionsChain200ResponseResultsInnerDetailsContractTypeEnum {
    Put = 'put',
    Call = 'call',
    Other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum OptionsChain200ResponseResultsInnerDetailsExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * The most recent quote for this contract. This is only returned if your current plan includes quotes.
 * @export
 * @interface OptionsChain200ResponseResultsInnerLastQuote
 */
export interface OptionsChain200ResponseResultsInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastQuote
     */
    'ask': number;
    /**
     * The ask side exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastQuote
     */
    'ask_exchange'?: number;
    /**
     * The ask size.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastQuote
     */
    'ask_size': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastQuote
     */
    'bid': number;
    /**
     * The bid side exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastQuote
     */
    'bid_exchange'?: number;
    /**
     * The bid size.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastQuote
     */
    'bid_size': number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastQuote
     */
    'last_updated'?: number;
    /**
     * The average of the bid and ask price.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastQuote
     */
    'midpoint': number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof OptionsChain200ResponseResultsInnerLastQuote
     */
    'timeframe'?: OptionsChain200ResponseResultsInnerLastQuoteTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OptionsChain200ResponseResultsInnerLastQuoteTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * The most recent trade for this contract. This is only returned if your current plan includes trades.
 * @export
 * @interface OptionsChain200ResponseResultsInnerLastTrade
 */
export interface OptionsChain200ResponseResultsInnerLastTrade {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof OptionsChain200ResponseResultsInnerLastTrade
     */
    'conditions'?: Array<number>;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/options/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastTrade
     */
    'exchange': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastTrade
     */
    'price': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastTrade
     */
    'sip_timestamp': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof OptionsChain200ResponseResultsInnerLastTrade
     */
    'size': number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof OptionsChain200ResponseResultsInnerLastTrade
     */
    'timeframe'?: OptionsChain200ResponseResultsInnerLastTradeTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OptionsChain200ResponseResultsInnerLastTradeTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * 
 * @export
 * @interface PaginationHooksBase
 */
export interface PaginationHooksBase {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof PaginationHooksBase
     */
    'next_url'?: string;
}
/**
 * 
 * @export
 * @interface Quotes200Response
 */
export interface Quotes200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof Quotes200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof Quotes200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<Quotes200ResponseResultsInner>}
     * @memberof Quotes200Response
     */
    'results'?: Array<Quotes200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof Quotes200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface Quotes200ResponseResultsInner
 */
export interface Quotes200ResponseResultsInner {
    /**
     * The ask exchange ID
     * @type {number}
     * @memberof Quotes200ResponseResultsInner
     */
    'ask_exchange'?: number;
    /**
     * The ask price.
     * @type {number}
     * @memberof Quotes200ResponseResultsInner
     */
    'ask_price'?: number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof Quotes200ResponseResultsInner
     */
    'ask_size'?: number;
    /**
     * The bid exchange ID
     * @type {number}
     * @memberof Quotes200ResponseResultsInner
     */
    'bid_exchange'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof Quotes200ResponseResultsInner
     */
    'bid_price'?: number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof Quotes200ResponseResultsInner
     */
    'bid_size'?: number;
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof Quotes200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * A list of indicator codes.
     * @type {Array<number>}
     * @memberof Quotes200ResponseResultsInner
     */
    'indicators'?: Array<number>;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof Quotes200ResponseResultsInner
     */
    'participant_timestamp': number;
    /**
     * The sequence number represents the sequence in which quote events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
     * @type {number}
     * @memberof Quotes200ResponseResultsInner
     */
    'sequence_number': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
     * @type {number}
     * @memberof Quotes200ResponseResultsInner
     */
    'sip_timestamp': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof Quotes200ResponseResultsInner
     */
    'tape'?: number;
    /**
     * The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this quote.
     * @type {number}
     * @memberof Quotes200ResponseResultsInner
     */
    'trf_timestamp'?: number;
}
/**
 * 
 * @export
 * @interface QuotesFx200Response
 */
export interface QuotesFx200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof QuotesFx200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof QuotesFx200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<QuotesFx200ResponseResultsInner>}
     * @memberof QuotesFx200Response
     */
    'results'?: Array<QuotesFx200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof QuotesFx200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface QuotesFx200ResponseResultsInner
 */
export interface QuotesFx200ResponseResultsInner {
    /**
     * The ask exchange ID
     * @type {number}
     * @memberof QuotesFx200ResponseResultsInner
     */
    'ask_exchange'?: number;
    /**
     * The ask price.
     * @type {number}
     * @memberof QuotesFx200ResponseResultsInner
     */
    'ask_price'?: number;
    /**
     * The bid exchange ID
     * @type {number}
     * @memberof QuotesFx200ResponseResultsInner
     */
    'bid_exchange'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof QuotesFx200ResponseResultsInner
     */
    'bid_price'?: number;
    /**
     * The nanosecond Exchange Unix Timestamp. This is the timestamp of when the quote was generated at the exchange.
     * @type {number}
     * @memberof QuotesFx200ResponseResultsInner
     */
    'participant_timestamp': number;
}
/**
 * 
 * @export
 * @interface QuotesOptions200Response
 */
export interface QuotesOptions200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof QuotesOptions200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof QuotesOptions200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<QuotesOptions200ResponseResultsInner>}
     * @memberof QuotesOptions200Response
     */
    'results'?: Array<QuotesOptions200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof QuotesOptions200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface QuotesOptions200ResponseResultsInner
 */
export interface QuotesOptions200ResponseResultsInner {
    /**
     * The ask exchange ID
     * @type {number}
     * @memberof QuotesOptions200ResponseResultsInner
     */
    'ask_exchange'?: number;
    /**
     * The ask price.
     * @type {number}
     * @memberof QuotesOptions200ResponseResultsInner
     */
    'ask_price'?: number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof QuotesOptions200ResponseResultsInner
     */
    'ask_size'?: number;
    /**
     * The bid exchange ID
     * @type {number}
     * @memberof QuotesOptions200ResponseResultsInner
     */
    'bid_exchange'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof QuotesOptions200ResponseResultsInner
     */
    'bid_price'?: number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof QuotesOptions200ResponseResultsInner
     */
    'bid_size'?: number;
    /**
     * The sequence number represents the sequence in which quote events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
     * @type {number}
     * @memberof QuotesOptions200ResponseResultsInner
     */
    'sequence_number': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
     * @type {number}
     * @memberof QuotesOptions200ResponseResultsInner
     */
    'sip_timestamp': number;
}
/**
 * 
 * @export
 * @interface RatingSection
 */
export interface RatingSection {
    /**
     * Analyst Rating at current month
     * @type {number}
     * @memberof RatingSection
     */
    'current': number;
    /**
     * Analyst Ratings at 1 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month1': number;
    /**
     * Analyst Ratings at 2 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month2': number;
    /**
     * Analyst Ratings at 3 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month3': number;
    /**
     * Analyst Ratings at 4 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month4'?: number;
    /**
     * Analyst Ratings at 5 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month5'?: number;
}
/**
 * 
 * @export
 * @interface RealTimeCurrencyConversion200Response
 */
export interface RealTimeCurrencyConversion200Response {
    /**
     * The result of the conversion.
     * @type {number}
     * @memberof RealTimeCurrencyConversion200Response
     */
    'converted': number;
    /**
     * The \"from\" currency symbol.
     * @type {string}
     * @memberof RealTimeCurrencyConversion200Response
     */
    'from': string;
    /**
     * The amount to convert.
     * @type {number}
     * @memberof RealTimeCurrencyConversion200Response
     */
    'initialAmount': number;
    /**
     * 
     * @type {RealTimeCurrencyConversion200ResponseLast}
     * @memberof RealTimeCurrencyConversion200Response
     */
    'last'?: RealTimeCurrencyConversion200ResponseLast;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof RealTimeCurrencyConversion200Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof RealTimeCurrencyConversion200Response
     */
    'status': string;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof RealTimeCurrencyConversion200Response
     */
    'symbol': string;
    /**
     * The \"to\" currency symbol.
     * @type {string}
     * @memberof RealTimeCurrencyConversion200Response
     */
    'to': string;
}
/**
 * Contains the requested quote data for the specified forex currency pair.
 * @export
 * @interface RealTimeCurrencyConversion200ResponseLast
 */
export interface RealTimeCurrencyConversion200ResponseLast {
    /**
     * The ask price.
     * @type {number}
     * @memberof RealTimeCurrencyConversion200ResponseLast
     */
    'ask': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof RealTimeCurrencyConversion200ResponseLast
     */
    'bid': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/forex/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof RealTimeCurrencyConversion200ResponseLast
     */
    'exchange': number;
    /**
     * The Unix millisecond timestamp.
     * @type {number}
     * @memberof RealTimeCurrencyConversion200ResponseLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface RequestIdBase
 */
export interface RequestIdBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof RequestIdBase
     */
    'request_id': string;
}
/**
 * 
 * @export
 * @interface SnapshotMinOHLCV
 */
export interface SnapshotMinOHLCV {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'c'?: number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'h'?: number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'l'?: number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'o'?: number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    't'?: number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'v'?: number;
}
/**
 * 
 * @export
 * @interface SnapshotOHLCV
 */
export interface SnapshotOHLCV {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'v': number;
}
/**
 * 
 * @export
 * @interface SnapshotOHLCVVW
 */
export interface SnapshotOHLCVVW {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface SnapshotOHLCVVWOtc
 */
export interface SnapshotOHLCVVWOtc {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof SnapshotOHLCVVWOtc
     */
    'otc'?: boolean;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface SnapshotSummary200Response
 */
export interface SnapshotSummary200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof SnapshotSummary200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<SnapshotSummary200ResponseResultsInner>}
     * @memberof SnapshotSummary200Response
     */
    'results'?: Array<SnapshotSummary200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof SnapshotSummary200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface SnapshotSummary200ResponseResultsInner
 */
export interface SnapshotSummary200ResponseResultsInner {
    /**
     * 
     * @type {SnapshotSummary200ResponseResultsInnerBranding}
     * @memberof SnapshotSummary200ResponseResultsInner
     */
    'branding'?: SnapshotSummary200ResponseResultsInnerBranding;
    /**
     * The error while looking for this ticker.
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInner
     */
    'error'?: string;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInner
     */
    'last_updated'?: number;
    /**
     * The market status for the market that trades this ticker.
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInner
     */
    'market_status'?: string;
    /**
     * The error message while looking for this ticker.
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInner
     */
    'message'?: string;
    /**
     * Name of ticker, forex, or crypto asset.
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInner
     */
    'name'?: string;
    /**
     * 
     * @type {SnapshotSummary200ResponseResultsInnerOptions}
     * @memberof SnapshotSummary200ResponseResultsInner
     */
    'options'?: SnapshotSummary200ResponseResultsInnerOptions;
    /**
     * The most up to date ticker price.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInner
     */
    'price'?: number;
    /**
     * 
     * @type {SnapshotSummary200ResponseResultsInnerSession}
     * @memberof SnapshotSummary200ResponseResultsInner
     */
    'session'?: SnapshotSummary200ResponseResultsInnerSession;
    /**
     * Ticker of asset queried.
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The market for this ticker of stock, crypto, fx, option.
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInner
     */
    'type'?: SnapshotSummary200ResponseResultsInnerTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SnapshotSummary200ResponseResultsInnerTypeEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Options = 'options',
    Fx = 'fx'
}

/**
 * 
 * @export
 * @interface SnapshotSummary200ResponseResultsInnerBranding
 */
export interface SnapshotSummary200ResponseResultsInnerBranding {
    /**
     * A link to this ticker\'s company\'s icon. Icon\'s are generally smaller, square images that represent the company at a glance. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInnerBranding
     */
    'icon_url'?: string;
    /**
     * A link to this ticker\'s company\'s logo. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInnerBranding
     */
    'logo_url'?: string;
}
/**
 * 
 * @export
 * @interface SnapshotSummary200ResponseResultsInnerOptions
 */
export interface SnapshotSummary200ResponseResultsInnerOptions {
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInnerOptions
     */
    'contract_type': SnapshotSummary200ResponseResultsInnerOptionsContractTypeEnum;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInnerOptions
     */
    'exercise_style': SnapshotSummary200ResponseResultsInnerOptionsExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInnerOptions
     */
    'expiration_date': string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerOptions
     */
    'shares_per_contract': number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerOptions
     */
    'strike_price': number;
    /**
     * The ticker for the option contract.
     * @type {string}
     * @memberof SnapshotSummary200ResponseResultsInnerOptions
     */
    'underlying_ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum SnapshotSummary200ResponseResultsInnerOptionsContractTypeEnum {
    Put = 'put',
    Call = 'call',
    Other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum SnapshotSummary200ResponseResultsInnerOptionsExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * Comprehensive trading session metrics, detailing price changes, trading volume, and key price points (open, close, high, low) for the asset within the current trading day. Includes specific changes during early, regular, and late trading periods to enable detailed performance analysis and trend tracking.
 * @export
 * @interface SnapshotSummary200ResponseResultsInnerSession
 */
export interface SnapshotSummary200ResponseResultsInnerSession {
    /**
     * The value of the price change for the asset from the previous trading day.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'change': number;
    /**
     * The percent of the price change for the asset from the previous trading day.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'change_percent': number;
    /**
     * The closing price of the asset for the day.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'close': number;
    /**
     * Today\'s early trading change amount, difference between price and previous close if in early trading hours, otherwise difference between last price during early trading and previous close.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'early_trading_change'?: number;
    /**
     * Today\'s early trading change as a percentage.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'early_trading_change_percent'?: number;
    /**
     * The highest price of the asset for the day.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'high': number;
    /**
     * Today\'s late trading change amount, difference between price and today\'s close if in late trading hours, otherwise difference between last price during late trading and today\'s close.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'late_trading_change'?: number;
    /**
     * Today\'s late trading change as a percentage.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'late_trading_change_percent'?: number;
    /**
     * The lowest price of the asset for the day.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'low': number;
    /**
     * The open price of the asset for the day.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'open': number;
    /**
     * The closing price of the asset for the previous trading day.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'previous_close': number;
    /**
     * The price of the most recent trade or bid price for this asset.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'price'?: number;
    /**
     * Today\'s change in regular trading hours, difference between current price and previous trading day\'s close, otherwise difference between today\'s close and previous day\'s close.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'regular_trading_change'?: number;
    /**
     * Today\'s regular trading change as a percentage.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'regular_trading_change_percent'?: number;
    /**
     * The trading volume for the asset for the day.
     * @type {number}
     * @memberof SnapshotSummary200ResponseResultsInnerSession
     */
    'volume'?: number;
}
/**
 * 
 * @export
 * @interface Snapshots200Response
 */
export interface Snapshots200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof Snapshots200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof Snapshots200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<Snapshots200ResponseResultsInner>}
     * @memberof Snapshots200Response
     */
    'results'?: Array<Snapshots200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof Snapshots200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface Snapshots200ResponseResultsInner
 */
export interface Snapshots200ResponseResultsInner {
    /**
     * The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
     * @type {number}
     * @memberof Snapshots200ResponseResultsInner
     */
    'break_even_price'?: number;
    /**
     * 
     * @type {Snapshots200ResponseResultsInnerDetails}
     * @memberof Snapshots200ResponseResultsInner
     */
    'details'?: Snapshots200ResponseResultsInnerDetails;
    /**
     * The error while looking for this ticker.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInner
     */
    'error'?: string;
    /**
     * Fair market value is only available on Business plans. It\'s it our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {Snapshots200ResponseResultsInnerGreeks}
     * @memberof Snapshots200ResponseResultsInner
     */
    'greeks'?: Snapshots200ResponseResultsInnerGreeks;
    /**
     * The market\'s forecast for the volatility of the underlying asset, based on this option\'s current price.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInner
     */
    'implied_volatility'?: number;
    /**
     * 
     * @type {Snapshots200ResponseResultsInnerLastQuote}
     * @memberof Snapshots200ResponseResultsInner
     */
    'last_quote'?: Snapshots200ResponseResultsInnerLastQuote;
    /**
     * 
     * @type {Snapshots200ResponseResultsInnerLastTrade}
     * @memberof Snapshots200ResponseResultsInner
     */
    'last_trade'?: Snapshots200ResponseResultsInnerLastTrade;
    /**
     * The market status for the market that trades this ticker. Possible values for stocks, options, crypto, and forex snapshots are open, closed, early_trading, or late_trading. Possible values for indices snapshots are regular_trading, closed, early_trading, and late_trading.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInner
     */
    'market_status'?: string;
    /**
     * The error message while looking for this ticker.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInner
     */
    'message'?: string;
    /**
     * The name of this contract.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInner
     */
    'name'?: string;
    /**
     * The quantity of this contract held at the end of the last trading day.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInner
     */
    'open_interest'?: number;
    /**
     * 
     * @type {SnapshotSummary200ResponseResultsInnerSession}
     * @memberof Snapshots200ResponseResultsInner
     */
    'session'?: SnapshotSummary200ResponseResultsInnerSession;
    /**
     * The ticker symbol for the asset.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The asset class for this ticker.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInner
     */
    'type'?: Snapshots200ResponseResultsInnerTypeEnum;
    /**
     * 
     * @type {Snapshots200ResponseResultsInnerUnderlyingAsset}
     * @memberof Snapshots200ResponseResultsInner
     */
    'underlying_asset'?: Snapshots200ResponseResultsInnerUnderlyingAsset;
    /**
     * Value of Index.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInner
     */
    'value'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum Snapshots200ResponseResultsInnerTypeEnum {
    Stocks = 'stocks',
    Options = 'options',
    Fx = 'fx',
    Crypto = 'crypto',
    Indices = 'indices'
}

/**
 * The details for this contract.
 * @export
 * @interface Snapshots200ResponseResultsInnerDetails
 */
export interface Snapshots200ResponseResultsInnerDetails {
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof Snapshots200ResponseResultsInnerDetails
     */
    'contract_type': Snapshots200ResponseResultsInnerDetailsContractTypeEnum;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInnerDetails
     */
    'exercise_style': Snapshots200ResponseResultsInnerDetailsExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInnerDetails
     */
    'expiration_date': string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerDetails
     */
    'shares_per_contract': number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerDetails
     */
    'strike_price': number;
}

/**
    * @export
    * @enum {string}
    */
export enum Snapshots200ResponseResultsInnerDetailsContractTypeEnum {
    Put = 'put',
    Call = 'call',
    Other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum Snapshots200ResponseResultsInnerDetailsExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * The greeks for this contract. There are certain circumstances where greeks will not be returned, such as options contracts that are deep in the money. See this <a href=\"https://polygon.io/blog/greeks-and-implied-volatility/#testing\" alt=\"link\">article</a> for more information.
 * @export
 * @interface Snapshots200ResponseResultsInnerGreeks
 */
export interface Snapshots200ResponseResultsInnerGreeks {
    /**
     * The change in the option\'s price per $0.01 increment in the price of the underlying asset.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerGreeks
     */
    'delta': number;
    /**
     * The change in delta per $0.01 change in the price of the underlying asset.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerGreeks
     */
    'gamma': number;
    /**
     * The change in the option\'s price per day.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerGreeks
     */
    'theta': number;
    /**
     * The change in the option\'s price per 1% increment in volatility.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerGreeks
     */
    'vega': number;
}
/**
 * The most recent quote for this contract. This is only returned if your current plan includes quotes.
 * @export
 * @interface Snapshots200ResponseResultsInnerLastQuote
 */
export interface Snapshots200ResponseResultsInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastQuote
     */
    'ask': number;
    /**
     * The ask side exchange ID. See <a href=\"https://polygon.io/docs/options/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastQuote
     */
    'ask_exchange'?: number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastQuote
     */
    'ask_size'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastQuote
     */
    'bid': number;
    /**
     * The bid side exchange ID. See <a href=\"https://polygon.io/docs/options/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastQuote
     */
    'bid_exchange'?: number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastQuote
     */
    'bid_size'?: number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastQuote
     */
    'last_updated': number;
    /**
     * The average of the bid and ask price.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastQuote
     */
    'midpoint'?: number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInnerLastQuote
     */
    'timeframe': Snapshots200ResponseResultsInnerLastQuoteTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Snapshots200ResponseResultsInnerLastQuoteTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * The most recent quote for this contract. This is only returned if your current plan includes trades.
 * @export
 * @interface Snapshots200ResponseResultsInnerLastTrade
 */
export interface Snapshots200ResponseResultsInnerLastTrade {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof Snapshots200ResponseResultsInnerLastTrade
     */
    'conditions'?: Array<number>;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastTrade
     */
    'exchange'?: number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInnerLastTrade
     */
    'id'?: string;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastTrade
     */
    'last_updated'?: number;
    /**
     * The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastTrade
     */
    'participant_timestamp'?: number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastTrade
     */
    'price': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastTrade
     */
    'sip_timestamp'?: number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerLastTrade
     */
    'size': number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInnerLastTrade
     */
    'timeframe'?: Snapshots200ResponseResultsInnerLastTradeTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Snapshots200ResponseResultsInnerLastTradeTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * Information on the underlying stock for this options contract.  The market data returned depends on your current stocks plan.
 * @export
 * @interface Snapshots200ResponseResultsInnerUnderlyingAsset
 */
export interface Snapshots200ResponseResultsInnerUnderlyingAsset {
    /**
     * The change in price for the contract to break even.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerUnderlyingAsset
     */
    'change_to_break_even': number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerUnderlyingAsset
     */
    'last_updated'?: number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerUnderlyingAsset
     */
    'price'?: number;
    /**
     * The ticker symbol for the contract\'s underlying asset.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInnerUnderlyingAsset
     */
    'ticker': string;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof Snapshots200ResponseResultsInnerUnderlyingAsset
     */
    'timeframe'?: Snapshots200ResponseResultsInnerUnderlyingAssetTimeframeEnum;
    /**
     * The value of the underlying index.
     * @type {number}
     * @memberof Snapshots200ResponseResultsInnerUnderlyingAsset
     */
    'value'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum Snapshots200ResponseResultsInnerUnderlyingAssetTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * 
 * @export
 * @interface StandardBase
 */
export interface StandardBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof StandardBase
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof StandardBase
     */
    'count'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StandardBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface StatusBase
 */
export interface StatusBase {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StatusBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface StatusCountBase
 */
export interface StatusCountBase {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof StatusCountBase
     */
    'count'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StatusCountBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface StocksGroupedResults
 */
export interface StocksGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner>}
     * @memberof StocksGroupedResults
     */
    'results'?: Array<V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface StocksOpenClose
 */
export interface StocksOpenClose {
    /**
     * The close price of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'afterHours'?: number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof StocksOpenClose
     */
    'from': string;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'high': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'low': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'open': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof StocksOpenClose
     */
    'otc'?: boolean;
    /**
     * The open price of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StocksOpenClose
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksOpenClose
     */
    'symbol': string;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'volume': number;
}
/**
 * 
 * @export
 * @interface StocksShortInterest200Response
 */
export interface StocksShortInterest200Response {
    /**
     * URL for the next page of results, if applicable.
     * @type {string}
     * @memberof StocksShortInterest200Response
     */
    'next_url'?: string;
    /**
     * Unique identifier for this request.
     * @type {string}
     * @memberof StocksShortInterest200Response
     */
    'request_id': string;
    /**
     * Records that match the given query.
     * @type {Array<StocksShortInterest200ResponseResultsInner>}
     * @memberof StocksShortInterest200Response
     */
    'results': Array<StocksShortInterest200ResponseResultsInner>;
    /**
     * Status of the request. Usually \'OK\' or \'ERROR\'.
     * @type {string}
     * @memberof StocksShortInterest200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface StocksShortInterest200ResponseResultsInner
 */
export interface StocksShortInterest200ResponseResultsInner {
    /**
     * The average daily trading volume for the stock over a specified period, typically used to contextualize short interest.
     * @type {number}
     * @memberof StocksShortInterest200ResponseResultsInner
     */
    'avg_daily_volume'?: number;
    /**
     * Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume.
     * @type {number}
     * @memberof StocksShortInterest200ResponseResultsInner
     */
    'days_to_cover'?: number;
    /**
     * The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
     * @type {string}
     * @memberof StocksShortInterest200ResponseResultsInner
     */
    'settlement_date'?: string;
    /**
     * The total number of shares that have been sold short but have not yet been covered or closed out.
     * @type {number}
     * @memberof StocksShortInterest200ResponseResultsInner
     */
    'short_interest'?: number;
    /**
     * The primary ticker symbol for the stock.
     * @type {string}
     * @memberof StocksShortInterest200ResponseResultsInner
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface StocksShortVolume200Response
 */
export interface StocksShortVolume200Response {
    /**
     * URL for the next page of results, if applicable.
     * @type {string}
     * @memberof StocksShortVolume200Response
     */
    'next_url'?: string;
    /**
     * Unique identifier for this request.
     * @type {string}
     * @memberof StocksShortVolume200Response
     */
    'request_id': string;
    /**
     * Records that match the given query.
     * @type {Array<StocksShortVolume200ResponseResultsInner>}
     * @memberof StocksShortVolume200Response
     */
    'results': Array<StocksShortVolume200ResponseResultsInner>;
    /**
     * Status of the request. Usually \'OK\' or \'ERROR\'.
     * @type {string}
     * @memberof StocksShortVolume200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface StocksShortVolume200ResponseResultsInner
 */
export interface StocksShortVolume200ResponseResultsInner {
    /**
     * Short volume reported via the Alternative Display Facility (ADF), excluding exempt volume.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'adf_short_volume'?: number;
    /**
     * Short volume reported via ADF that was marked as exempt.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'adf_short_volume_exempt'?: number;
    /**
     * The date of trade activity reported in the format YYYY-MM-DD
     * @type {string}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'date'?: string;
    /**
     * Portion of short volume that was marked as exempt from regulation SHO.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'exempt_volume'?: number;
    /**
     * Short volume reported from Nasdaq\'s Carteret facility, excluding exempt volume.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'nasdaq_carteret_short_volume'?: number;
    /**
     * Short volume from Nasdaq Carteret that was marked as exempt.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'nasdaq_carteret_short_volume_exempt'?: number;
    /**
     * Short volume reported from Nasdaq\'s Chicago facility, excluding exempt volume.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'nasdaq_chicago_short_volume'?: number;
    /**
     * Short volume from Nasdaq Chicago that was marked as exempt.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'nasdaq_chicago_short_volume_exempt'?: number;
    /**
     * Portion of short volume that was not exempt from regulation SHO (i.e., short_volume - exempt_volume).
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'non_exempt_volume'?: number;
    /**
     * Short volume reported from NYSE facilities, excluding exempt volume.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'nyse_short_volume'?: number;
    /**
     * Short volume from NYSE facilities that was marked as exempt.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'nyse_short_volume_exempt'?: number;
    /**
     * Total number of shares sold short across all venues for the ticker on the given date.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'short_volume'?: number;
    /**
     * The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'short_volume_ratio'?: number;
    /**
     * The primary ticker symbol for the stock.
     * @type {string}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * Total reported volume across all venues for the ticker on the given date.
     * @type {number}
     * @memberof StocksShortVolume200ResponseResultsInner
     */
    'total_volume'?: number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotLastQuote
 */
export interface StocksSnapshotLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    'P': number;
    /**
     * The ask size in lots.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    'S': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    'p': number;
    /**
     * The bid size in lots.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    's': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    't': number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotMinute
 */
export interface StocksSnapshotMinute {
    /**
     * The accumulated volume.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'av': number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotMinuteOTC
 */
export interface StocksSnapshotMinuteOTC {
    /**
     * The accumulated volume.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'av': number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof StocksSnapshotMinuteOTC
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotTicker
 */
export interface StocksSnapshotTicker {
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker}
     * @memberof StocksSnapshotTicker
     */
    'ticker'?: V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker;
}
/**
 * 
 * @export
 * @interface StocksSnapshotTickers
 */
export interface StocksSnapshotTickers {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner>}
     * @memberof StocksSnapshotTickers
     */
    'tickers'?: Array<V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface StocksTickerResultsOTC
 */
export interface StocksTickerResultsOTC {
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner>}
     * @memberof StocksTickerResultsOTC
     */
    'results'?: Array<V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface StocksV2Base
 */
export interface StocksV2Base {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksV2Base
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof StocksV2Base
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof StocksV2Base
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksV2Base
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof StocksV2Base
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface StocksV2NBBO
 */
export interface StocksV2NBBO {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksV2NBBO
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'y': number;
    /**
     * The ask price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'P': number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'S': number;
    /**
     * The ask exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'X': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof StocksV2NBBO
     */
    'c': Array<number>;
    /**
     * The indicators. For more information, see our glossary of [Conditions and Indicators](https://polygon.io/glossary/us/stocks/conditions-indicators). 
     * @type {Array<number>}
     * @memberof StocksV2NBBO
     */
    'i': Array<number>;
    /**
     * The bid price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'p': number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    's': number;
    /**
     * The bid exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface StocksV2NBBOs
 */
export interface StocksV2NBBOs {
    /**
     * 
     * @type {Array<V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner>}
     * @memberof StocksV2NBBOs
     */
    'results'?: Array<V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface StocksV2Trade
 */
export interface StocksV2Trade {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksV2Trade
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof StocksV2Trade
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksV2Trade
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof StocksV2Trade
     */
    'y': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof StocksV2Trade
     */
    'c': Array<number>;
    /**
     * The trade correction indicator. 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'e': number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof StocksV2Trade
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'p': number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place. 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'r': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof StocksV2Trade
     */
    's': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof StocksV2Trade
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface StocksV2Trades
 */
export interface StocksV2Trades {
    /**
     * 
     * @type {Array<V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner>}
     * @memberof StocksV2Trades
     */
    'results'?: Array<V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface TickerBase
 */
export interface TickerBase {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof TickerBase
     */
    'ticker': string;
}
/**
 * 
 * @export
 * @interface TickerResults
 */
export interface TickerResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner>}
     * @memberof TickerResults
     */
    'results'?: Array<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface TradeDetailsMapItem
 */
export interface TradeDetailsMapItem {
    /**
     * Name of the trade detail item
     * @type {string}
     * @memberof TradeDetailsMapItem
     */
    'name'?: string;
    /**
     * Actual type of the trade detail item
     * @type {string}
     * @memberof TradeDetailsMapItem
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Trades200Response
 */
export interface Trades200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof Trades200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof Trades200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<Trades200ResponseResultsInner>}
     * @memberof Trades200Response
     */
    'results'?: Array<Trades200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof Trades200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface Trades200ResponseResultsInner
 */
export interface Trades200ResponseResultsInner {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof Trades200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * The trade correction indicator.
     * @type {number}
     * @memberof Trades200ResponseResultsInner
     */
    'correction'?: number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof Trades200ResponseResultsInner
     */
    'exchange': number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
     * @type {string}
     * @memberof Trades200ResponseResultsInner
     */
    'id': string;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
     * @type {number}
     * @memberof Trades200ResponseResultsInner
     */
    'participant_timestamp': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof Trades200ResponseResultsInner
     */
    'price': number;
    /**
     * The sequence number represents the sequence in which trade events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
     * @type {number}
     * @memberof Trades200ResponseResultsInner
     */
    'sequence_number': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof Trades200ResponseResultsInner
     */
    'sip_timestamp': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof Trades200ResponseResultsInner
     */
    'size': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof Trades200ResponseResultsInner
     */
    'tape'?: number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place.
     * @type {number}
     * @memberof Trades200ResponseResultsInner
     */
    'trf_id'?: number;
    /**
     * The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this trade.
     * @type {number}
     * @memberof Trades200ResponseResultsInner
     */
    'trf_timestamp'?: number;
}
/**
 * 
 * @export
 * @interface TradesCrypto200Response
 */
export interface TradesCrypto200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof TradesCrypto200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof TradesCrypto200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<TradesCrypto200ResponseResultsInner>}
     * @memberof TradesCrypto200Response
     */
    'results'?: Array<TradesCrypto200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof TradesCrypto200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface TradesCrypto200ResponseResultsInner
 */
export interface TradesCrypto200ResponseResultsInner {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof TradesCrypto200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof TradesCrypto200ResponseResultsInner
     */
    'exchange': number;
    /**
     * The Trade ID which uniquely identifies a trade on the exchange that the trade happened on.
     * @type {string}
     * @memberof TradesCrypto200ResponseResultsInner
     */
    'id': string;
    /**
     * The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
     * @type {number}
     * @memberof TradesCrypto200ResponseResultsInner
     */
    'participant_timestamp'?: number;
    /**
     * The price of the trade in the base currency of the crypto pair.
     * @type {number}
     * @memberof TradesCrypto200ResponseResultsInner
     */
    'price': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof TradesCrypto200ResponseResultsInner
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface TradesOptions200Response
 */
export interface TradesOptions200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof TradesOptions200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof TradesOptions200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<TradesOptions200ResponseResultsInner>}
     * @memberof TradesOptions200Response
     */
    'results'?: Array<TradesOptions200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof TradesOptions200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface TradesOptions200ResponseResultsInner
 */
export interface TradesOptions200ResponseResultsInner {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof TradesOptions200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * The trade correction indicator.
     * @type {number}
     * @memberof TradesOptions200ResponseResultsInner
     */
    'correction'?: number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/options/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof TradesOptions200ResponseResultsInner
     */
    'exchange': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
     * @type {number}
     * @memberof TradesOptions200ResponseResultsInner
     */
    'participant_timestamp'?: number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof TradesOptions200ResponseResultsInner
     */
    'price': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof TradesOptions200ResponseResultsInner
     */
    'sip_timestamp': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof TradesOptions200ResponseResultsInner
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface V1HistoricCryptoFromToDateGet200Response
 */
export interface V1HistoricCryptoFromToDateGet200Response {
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof V1HistoricCryptoFromToDateGet200Response
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof V1HistoricCryptoFromToDateGet200Response
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof V1HistoricCryptoFromToDateGet200Response
     */
    'msLatency': number;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof V1HistoricCryptoFromToDateGet200Response
     */
    'symbol': string;
    /**
     * 
     * @type {Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>}
     * @memberof V1HistoricCryptoFromToDateGet200Response
     */
    'ticks': Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner
 */
export interface V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner {
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner
     */
    'p': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner
     */
    's': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner
     */
    't': number;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface V1HistoricForexFromToDateGet200Response
 */
export interface V1HistoricForexFromToDateGet200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V1HistoricForexFromToDateGet200Response
     */
    'status': string;
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof V1HistoricForexFromToDateGet200Response
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof V1HistoricForexFromToDateGet200Response
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof V1HistoricForexFromToDateGet200Response
     */
    'msLatency': number;
    /**
     * The currency pair that was evaluated from the request.
     * @type {string}
     * @memberof V1HistoricForexFromToDateGet200Response
     */
    'pair': string;
    /**
     * 
     * @type {Array<V1HistoricForexFromToDateGet200ResponseAllOfTicksInner>}
     * @memberof V1HistoricForexFromToDateGet200Response
     */
    'ticks': Array<V1HistoricForexFromToDateGet200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface V1HistoricForexFromToDateGet200ResponseAllOfTicksInner
 */
export interface V1HistoricForexFromToDateGet200ResponseAllOfTicksInner {
    /**
     * The ask price.
     * @type {number}
     * @memberof V1HistoricForexFromToDateGet200ResponseAllOfTicksInner
     */
    'a': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof V1HistoricForexFromToDateGet200ResponseAllOfTicksInner
     */
    'b': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof V1HistoricForexFromToDateGet200ResponseAllOfTicksInner
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/forex/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof V1HistoricForexFromToDateGet200ResponseAllOfTicksInner
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface V1LastBase
 */
export interface V1LastBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V1LastBase
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V1LastBase
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V1LastBase
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface V1OpenCloseCryptoFromToDateGet200Response
 */
export interface V1OpenCloseCryptoFromToDateGet200Response {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V1OpenCloseCryptoFromToDateGet200Response
     */
    'close': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>}
     * @memberof V1OpenCloseCryptoFromToDateGet200Response
     */
    'closingTrades': Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>;
    /**
     * The date requested.
     * @type {string}
     * @memberof V1OpenCloseCryptoFromToDateGet200Response
     */
    'day': string;
    /**
     * Whether or not the timestamps are in UTC timezone.
     * @type {boolean}
     * @memberof V1OpenCloseCryptoFromToDateGet200Response
     */
    'isUTC': boolean;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V1OpenCloseCryptoFromToDateGet200Response
     */
    'open': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>}
     * @memberof V1OpenCloseCryptoFromToDateGet200Response
     */
    'openTrades': Array<V1HistoricCryptoFromToDateGet200ResponseAllOfTicksInner>;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof V1OpenCloseCryptoFromToDateGet200Response
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface V1OpenCloseIndicesTickerDateGet200Response
 */
export interface V1OpenCloseIndicesTickerDateGet200Response {
    /**
     * The close value of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof V1OpenCloseIndicesTickerDateGet200Response
     */
    'afterHours'?: number;
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof V1OpenCloseIndicesTickerDateGet200Response
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof V1OpenCloseIndicesTickerDateGet200Response
     */
    'from': string;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof V1OpenCloseIndicesTickerDateGet200Response
     */
    'high': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof V1OpenCloseIndicesTickerDateGet200Response
     */
    'low': number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof V1OpenCloseIndicesTickerDateGet200Response
     */
    'open': number;
    /**
     * The open value of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof V1OpenCloseIndicesTickerDateGet200Response
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V1OpenCloseIndicesTickerDateGet200Response
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V1OpenCloseIndicesTickerDateGet200Response
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface V1OpenCloseOptionsTickerDateGet200Response
 */
export interface V1OpenCloseOptionsTickerDateGet200Response {
    /**
     * The close price of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof V1OpenCloseOptionsTickerDateGet200Response
     */
    'afterHours'?: number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V1OpenCloseOptionsTickerDateGet200Response
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof V1OpenCloseOptionsTickerDateGet200Response
     */
    'from': string;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V1OpenCloseOptionsTickerDateGet200Response
     */
    'high': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V1OpenCloseOptionsTickerDateGet200Response
     */
    'low': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V1OpenCloseOptionsTickerDateGet200Response
     */
    'open': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof V1OpenCloseOptionsTickerDateGet200Response
     */
    'otc'?: boolean;
    /**
     * The open price of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof V1OpenCloseOptionsTickerDateGet200Response
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V1OpenCloseOptionsTickerDateGet200Response
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V1OpenCloseOptionsTickerDateGet200Response
     */
    'symbol': string;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V1OpenCloseOptionsTickerDateGet200Response
     */
    'volume': number;
}
/**
 * 
 * @export
 * @interface V2AggsBase
 */
export interface V2AggsBase {
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof V2AggsBase
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof V2AggsBase
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2AggsBase
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2AggsBase
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2AggsBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response
 */
export interface V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response {
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner>}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response
     */
    'results'?: Array<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner
 */
export interface V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the end of the aggregate window.
     * @type {number}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface V2AggsGroupedLocaleUsMarketStocksDateGet200Response
 */
export interface V2AggsGroupedLocaleUsMarketStocksDateGet200Response {
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner>}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200Response
     */
    'results'?: Array<V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner
 */
export interface V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the end of the aggregate window.
     * @type {number}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof V2AggsGroupedLocaleUsMarketStocksDateGet200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface V2AggsTickerCryptoTickerPrevGet200Response
 */
export interface V2AggsTickerCryptoTickerPrevGet200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2AggsTickerCryptoTickerPrevGet200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof V2AggsTickerCryptoTickerPrevGet200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerPrevGet200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2AggsTickerCryptoTickerPrevGet200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerPrevGet200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2AggsTickerCryptoTickerPrevGet200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner>}
     * @memberof V2AggsTickerCryptoTickerPrevGet200Response
     */
    'results'?: Array<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response
 */
export interface V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner>}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response
     */
    'results'?: Array<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
 */
export interface V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface V2AggsTickerForexTickerPrevGet200Response
 */
export interface V2AggsTickerForexTickerPrevGet200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2AggsTickerForexTickerPrevGet200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof V2AggsTickerForexTickerPrevGet200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof V2AggsTickerForexTickerPrevGet200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2AggsTickerForexTickerPrevGet200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2AggsTickerForexTickerPrevGet200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2AggsTickerForexTickerPrevGet200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner>}
     * @memberof V2AggsTickerForexTickerPrevGet200Response
     */
    'results'?: Array<V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner
 */
export interface V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof V2AggsTickerForexTickerPrevGet200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface V2AggsTickerIndicesTickerPrevGet200Response
 */
export interface V2AggsTickerIndicesTickerPrevGet200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2AggsTickerIndicesTickerPrevGet200Response
     */
    'ticker': string;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof V2AggsTickerIndicesTickerPrevGet200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2AggsTickerIndicesTickerPrevGet200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2AggsTickerIndicesTickerPrevGet200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2AggsTickerIndicesTickerPrevGet200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsTickerIndicesTickerPrevGet200ResponseAllOfResultsInner>}
     * @memberof V2AggsTickerIndicesTickerPrevGet200Response
     */
    'results'?: Array<V2AggsTickerIndicesTickerPrevGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface V2AggsTickerIndicesTickerPrevGet200ResponseAllOfResultsInner
 */
export interface V2AggsTickerIndicesTickerPrevGet200ResponseAllOfResultsInner {
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerIndicesTickerPrevGet200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerIndicesTickerPrevGet200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerIndicesTickerPrevGet200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerIndicesTickerPrevGet200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof V2AggsTickerIndicesTickerPrevGet200ResponseAllOfResultsInner
     */
    't': number;
}
/**
 * 
 * @export
 * @interface V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response
 */
export interface V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner>}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response
     */
    'results'?: Array<V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner>;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response
     */
    'next_url'?: string;
}
/**
 * 
 * @export
 * @interface V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
 */
export interface V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface V2LastBase
 */
export interface V2LastBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2LastBase
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2LastBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoDirectionGet200Response
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoDirectionGet200Response {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner>}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoDirectionGet200Response
     */
    'tickers'?: Array<V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200Response
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner>}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200Response
     */
    'tickers'?: Array<V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner {
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner
     */
    'day': V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner
     */
    'lastTrade': V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner
     */
    'min': V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner
     */
    'prevDay': V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInner
     */
    'updated': number;
}
/**
 * The most recent daily bar for this ticker.
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay
     */
    'vw': number;
}
/**
 * The most recent trade for this ticker.
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade {
    /**
     * The trade conditions.
     * @type {Array<number>}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    'p': number;
    /**
     * The size (volume) of the trade.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    's': number;
    /**
     * The millisecond accuracy timestamp. This is the timestamp of when the trade was generated at the exchange.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    't': number;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    'x': number;
}
/**
 * The most recent minute bar for this ticker.
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin
     */
    'vw': number;
}
/**
 * The previous day\'s bar for this ticker.
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200Response
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200Response {
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200Response
     */
    'data'?: V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData {
    /**
     * The combined total number of asks in the book.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData
     */
    'askCount': number;
    /**
     * 
     * @type {Array<V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfDataAsksInner>}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData
     */
    'asks': Array<V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfDataAsksInner>;
    /**
     * The combined total number of bids in the book.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData
     */
    'bidCount': number;
    /**
     * 
     * @type {Array<V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfDataAsksInner>}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData
     */
    'bids': Array<V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfDataAsksInner>;
    /**
     * The difference between the best bid and the best ask price across exchanges.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData
     */
    'spread': number;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData
     */
    'ticker': string;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfData
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfDataAsksInner
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfDataAsksInner {
    /**
     * The price of this book level.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfDataAsksInner
     */
    'p': number;
    /**
     * A map of the exchange ID to number of shares at this price level. <br /> <br /> **Example:** <br /> `{   \"p\": 16302.94,   \"x\": {     \"1\": 0.02859424,     \"6\": 0.023455   } }` <br /> <br /> In this example, exchange ID 1 has 0.02859424 shares available at $16,302.94, and exchange ID 6 has 0.023455 shares at the same price level. 
     * @type {object}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200ResponseAllOfDataAsksInner
     */
    'x': object;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200Response
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200Response
     */
    'status': string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200Response
     */
    'request_id': string;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200Response
     */
    'ticker'?: V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker;
}
/**
 * Contains the requested snapshot data for the specified ticker.
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker
 */
export interface V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker {
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker
     */
    'day': V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker
     */
    'fmv'?: number;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker
     */
    'lastTrade': V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker
     */
    'min': V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker
     */
    'prevDay': V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200ResponseAllOfTicker
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsForexTickersGet200Response
 */
export interface V2SnapshotLocaleGlobalMarketsForexTickersGet200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner>}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200Response
     */
    'tickers'?: Array<V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner
 */
export interface V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner {
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerDay}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner
     */
    'day': V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerLastQuote}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner
     */
    'lastQuote': V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner
     */
    'min': V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner
     */
    'prevDay': V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInner
     */
    'updated': number;
}
/**
 * The most recent daily bar for this ticker.
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerDay
 */
export interface V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerDay
     */
    'v': number;
}
/**
 * The most recent quote for this ticker.
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerLastQuote
 */
export interface V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerLastQuote
     */
    'a': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerLastQuote
     */
    'b': number;
    /**
     * The millisecond accuracy timestamp of the quote.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerLastQuote
     */
    't': number;
    /**
     * The exchange ID on which this quote happened.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerLastQuote
     */
    'x': number;
}
/**
 * The most recent minute bar for this ticker.
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin
 */
export interface V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin
     */
    'c'?: number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin
     */
    'h'?: number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin
     */
    'l'?: number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin
     */
    'o'?: number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin
     */
    't'?: number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin
     */
    'v'?: number;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200Response
 */
export interface V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200Response
     */
    'status': string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200Response
     */
    'request_id': string;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200Response
     */
    'ticker'?: V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker;
}
/**
 * Contains the requested snapshot data for the specified ticker.
 * @export
 * @interface V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker
 */
export interface V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker {
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerDay}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker
     */
    'day': V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker
     */
    'fmv'?: number;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerLastQuote}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker
     */
    'lastQuote': V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker
     */
    'min': V2SnapshotLocaleGlobalMarketsForexTickersGet200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker
     */
    'prevDay': V2SnapshotLocaleGlobalMarketsCryptoTickersGet200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200ResponseAllOfTicker
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleUsMarketsStocksDirectionGet200Response
 */
export interface V2SnapshotLocaleUsMarketsStocksDirectionGet200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2SnapshotLocaleUsMarketsStocksDirectionGet200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner>}
     * @memberof V2SnapshotLocaleUsMarketsStocksDirectionGet200Response
     */
    'tickers'?: Array<V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleUsMarketsStocksTickersGet200Response
 */
export interface V2SnapshotLocaleUsMarketsStocksTickersGet200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200Response
     */
    'count'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner>}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200Response
     */
    'tickers'?: Array<V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner
 */
export interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner {
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner
     */
    'day'?: V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastQuote}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner
     */
    'lastQuote'?: V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner
     */
    'lastTrade'?: V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner
     */
    'min'?: V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner
     */
    'prevDay'?: V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner
     */
    'ticker'?: string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner
     */
    'todaysChange'?: number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner
     */
    'todaysChangePerc'?: number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInner
     */
    'updated'?: number;
}
/**
 * The most recent daily bar for this ticker.
 * @export
 * @interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay
 */
export interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay
     */
    'otc'?: boolean;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay
     */
    'vw': number;
}
/**
 * The most recent quote for this ticker.  This is only returned if your current plan includes quotes.
 * @export
 * @interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastQuote
 */
export interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastQuote
     */
    'P': number;
    /**
     * The ask size in lots.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastQuote
     */
    'S': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastQuote
     */
    'p': number;
    /**
     * The bid size in lots.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastQuote
     */
    's': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastQuote
     */
    't': number;
}
/**
 * The most recent trade for this ticker.  This is only returned if your current plan includes trades.
 * @export
 * @interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade
 */
export interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade {
    /**
     * The trade conditions.
     * @type {Array<number>}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    'p': number;
    /**
     * The size (volume) of the trade.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    's': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade
     */
    'x': number;
}
/**
 * The most recent minute bar for this ticker.
 * @export
 * @interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin
 */
export interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin {
    /**
     * The accumulated volume.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin
     */
    'av': number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin
     */
    'vw': number;
}
/**
 * The previous day\'s bar for this ticker.
 * @export
 * @interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay
 */
export interface V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'otc'?: boolean;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200Response
 */
export interface V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200Response
     */
    'status': string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200Response
     */
    'request_id': string;
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200Response
     */
    'ticker'?: V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker;
}
/**
 * Contains the requested snapshot data for the specified ticker.
 * @export
 * @interface V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker
 */
export interface V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker {
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker
     */
    'day'?: V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker
     */
    'fmv'?: number;
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastQuote}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker
     */
    'lastQuote'?: V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker
     */
    'lastTrade'?: V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker
     */
    'min'?: V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker
     */
    'prevDay'?: V2SnapshotLocaleUsMarketsStocksTickersGet200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker
     */
    'ticker'?: string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker
     */
    'todaysChange'?: number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker
     */
    'todaysChangePerc'?: number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200ResponseAllOfTicker
     */
    'updated'?: number;
}
/**
 * 
 * @export
 * @interface V2TicksBase
 */
export interface V2TicksBase {
    /**
     * Latency in milliseconds for the query results from the database.
     * @type {number}
     * @memberof V2TicksBase
     */
    'db_latency'?: number;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2TicksBase
     */
    'results_count'?: number;
    /**
     * Whether or not this query was executed successfully.
     * @type {boolean}
     * @memberof V2TicksBase
     */
    'success'?: boolean;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2TicksBase
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface V2TicksStocksNbboTickerDateGet200Response
 */
export interface V2TicksStocksNbboTickerDateGet200Response {
    /**
     * Latency in milliseconds for the query results from the database.
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200Response
     */
    'db_latency'?: number;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200Response
     */
    'results_count'?: number;
    /**
     * Whether or not this query was executed successfully.
     * @type {boolean}
     * @memberof V2TicksStocksNbboTickerDateGet200Response
     */
    'success'?: boolean;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2TicksStocksNbboTickerDateGet200Response
     */
    'ticker'?: string;
    /**
     * 
     * @type {Array<V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner>}
     * @memberof V2TicksStocksNbboTickerDateGet200Response
     */
    'results'?: Array<V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
 */
export interface V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'y': number;
    /**
     * The ask price.
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'P': number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'S': number;
    /**
     * The ask exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'X': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'c': Array<number>;
    /**
     * The indicators. For more information, see our glossary of [Conditions and Indicators](https://polygon.io/glossary/us/stocks/conditions-indicators). 
     * @type {Array<number>}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'i': Array<number>;
    /**
     * The bid price.
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'p': number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    's': number;
    /**
     * The bid exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof V2TicksStocksNbboTickerDateGet200ResponseAllOfResultsInner
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface V2TicksStocksTradesTickerDateGet200Response
 */
export interface V2TicksStocksTradesTickerDateGet200Response {
    /**
     * Latency in milliseconds for the query results from the database.
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200Response
     */
    'db_latency'?: number;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200Response
     */
    'results_count'?: number;
    /**
     * Whether or not this query was executed successfully.
     * @type {boolean}
     * @memberof V2TicksStocksTradesTickerDateGet200Response
     */
    'success'?: boolean;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2TicksStocksTradesTickerDateGet200Response
     */
    'ticker'?: string;
    /**
     * 
     * @type {Array<V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner>}
     * @memberof V2TicksStocksTradesTickerDateGet200Response
     */
    'results'?: Array<V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
 */
export interface V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    'y': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    'c': Array<number>;
    /**
     * The trade correction indicator. 
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    'e': number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    'p': number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place. 
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    'r': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    's': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof V2TicksStocksTradesTickerDateGet200ResponseAllOfResultsInner
     */
    'z': number;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve earnings_v1 data via API.
         * @summary earnings_v1 API
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
         * @param {string} [ticker] The stock symbol of the company reporting earnings.
         * @param {string} [dateGte] Range by date.
         * @param {string} [dateGt] Range by date.
         * @param {string} [dateLte] Range by date.
         * @param {string} [dateLt] Range by date.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {BenzingaEarningsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
         * @param {BenzingaEarningsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        benzingaEarnings: async (date?: string, ticker?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: BenzingaEarningsOrderEnum, limit?: number, sort?: BenzingaEarningsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/vX/earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve news_v1 data via API.
         * @summary news_v1 API
         * @param {string} [created] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
         * @param {string} [tickers] A list of stock or crypto tickers mentioned in the article.
         * @param {string} [createdGte] Range by created.
         * @param {string} [createdGt] Range by created.
         * @param {string} [createdLte] Range by created.
         * @param {string} [createdLt] Range by created.
         * @param {string} [tickersGte] Range by tickers.
         * @param {string} [tickersGt] Range by tickers.
         * @param {string} [tickersLte] Range by tickers.
         * @param {string} [tickersLt] Range by tickers.
         * @param {BenzingaNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
         * @param {BenzingaNewsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        benzingaNews: async (created?: string, tickers?: string, createdGte?: string, createdGt?: string, createdLte?: string, createdLt?: string, tickersGte?: string, tickersGt?: string, tickersLte?: string, tickersLt?: string, order?: BenzingaNewsOrderEnum, limit?: number, sort?: BenzingaNewsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/vX/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (tickers !== undefined) {
                localVarQueryParameter['tickers'] = tickers;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created.gte'] = createdGte;
            }

            if (createdGt !== undefined) {
                localVarQueryParameter['created.gt'] = createdGt;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created.lte'] = createdLte;
            }

            if (createdLt !== undefined) {
                localVarQueryParameter['created.lt'] = createdLt;
            }

            if (tickersGte !== undefined) {
                localVarQueryParameter['tickers.gte'] = tickersGte;
            }

            if (tickersGt !== undefined) {
                localVarQueryParameter['tickers.gt'] = tickersGt;
            }

            if (tickersLte !== undefined) {
                localVarQueryParameter['tickers.lte'] = tickersLte;
            }

            if (tickersLt !== undefined) {
                localVarQueryParameter['tickers.lt'] = tickersLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve ratings_v1 data via API.
         * @summary ratings_v1 API
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrade, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
         * @param {string} [priceTargetAction] The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
         * @param {string} [rating] The current rating set by the analyst.
         * @param {string} [firm] The name of the research firm or investment bank issuing the rating.
         * @param {string} [dateGte] Range by date.
         * @param {string} [dateGt] Range by date.
         * @param {string} [dateLte] Range by date.
         * @param {string} [dateLt] Range by date.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [ratingActionGte] Range by rating_action.
         * @param {string} [ratingActionGt] Range by rating_action.
         * @param {string} [ratingActionLte] Range by rating_action.
         * @param {string} [ratingActionLt] Range by rating_action.
         * @param {string} [priceTargetActionGte] Range by price_target_action.
         * @param {string} [priceTargetActionGt] Range by price_target_action.
         * @param {string} [priceTargetActionLte] Range by price_target_action.
         * @param {string} [priceTargetActionLt] Range by price_target_action.
         * @param {string} [ratingGte] Range by rating.
         * @param {string} [ratingGt] Range by rating.
         * @param {string} [ratingLte] Range by rating.
         * @param {string} [ratingLt] Range by rating.
         * @param {string} [firmGte] Range by firm.
         * @param {string} [firmGt] Range by firm.
         * @param {string} [firmLte] Range by firm.
         * @param {string} [firmLt] Range by firm.
         * @param {BenzingaRatingsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
         * @param {BenzingaRatingsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        benzingaRatings: async (date?: string, ticker?: string, ratingAction?: string, priceTargetAction?: string, rating?: string, firm?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, ratingActionGte?: string, ratingActionGt?: string, ratingActionLte?: string, ratingActionLt?: string, priceTargetActionGte?: string, priceTargetActionGt?: string, priceTargetActionLte?: string, priceTargetActionLt?: string, ratingGte?: string, ratingGt?: string, ratingLte?: string, ratingLt?: string, firmGte?: string, firmGt?: string, firmLte?: string, firmLt?: string, order?: BenzingaRatingsOrderEnum, limit?: number, sort?: BenzingaRatingsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/vX/ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (ratingAction !== undefined) {
                localVarQueryParameter['rating_action'] = ratingAction;
            }

            if (priceTargetAction !== undefined) {
                localVarQueryParameter['price_target_action'] = priceTargetAction;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            if (firm !== undefined) {
                localVarQueryParameter['firm'] = firm;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (ratingActionGte !== undefined) {
                localVarQueryParameter['rating_action.gte'] = ratingActionGte;
            }

            if (ratingActionGt !== undefined) {
                localVarQueryParameter['rating_action.gt'] = ratingActionGt;
            }

            if (ratingActionLte !== undefined) {
                localVarQueryParameter['rating_action.lte'] = ratingActionLte;
            }

            if (ratingActionLt !== undefined) {
                localVarQueryParameter['rating_action.lt'] = ratingActionLt;
            }

            if (priceTargetActionGte !== undefined) {
                localVarQueryParameter['price_target_action.gte'] = priceTargetActionGte;
            }

            if (priceTargetActionGt !== undefined) {
                localVarQueryParameter['price_target_action.gt'] = priceTargetActionGt;
            }

            if (priceTargetActionLte !== undefined) {
                localVarQueryParameter['price_target_action.lte'] = priceTargetActionLte;
            }

            if (priceTargetActionLt !== undefined) {
                localVarQueryParameter['price_target_action.lt'] = priceTargetActionLt;
            }

            if (ratingGte !== undefined) {
                localVarQueryParameter['rating.gte'] = ratingGte;
            }

            if (ratingGt !== undefined) {
                localVarQueryParameter['rating.gt'] = ratingGt;
            }

            if (ratingLte !== undefined) {
                localVarQueryParameter['rating.lte'] = ratingLte;
            }

            if (ratingLt !== undefined) {
                localVarQueryParameter['rating.lt'] = ratingLt;
            }

            if (firmGte !== undefined) {
                localVarQueryParameter['firm.gte'] = firmGte;
            }

            if (firmGt !== undefined) {
                localVarQueryParameter['firm.gt'] = firmGt;
            }

            if (firmLte !== undefined) {
                localVarQueryParameter['firm.lte'] = firmLte;
            }

            if (firmLt !== undefined) {
                localVarQueryParameter['firm.lt'] = firmLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {CryptoEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cryptoEMA: async (cryptoTicker: string, timestamp?: string, timespan?: CryptoEMATimespanEnum, window?: number, seriesType?: CryptoEMASeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('cryptoEMA', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/ema/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} cryptoTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {CryptoMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate MACD data. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cryptoMACD: async (cryptoTicker: string, timestamp?: string, timespan?: CryptoMACDTimespanEnum, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: CryptoMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('cryptoMACD', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/macd/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {CryptoRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cryptoRSI: async (cryptoTicker: string, timestamp?: string, timespan?: CryptoRSITimespanEnum, window?: number, seriesType?: CryptoRSISeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('cryptoRSI', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/rsi/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {CryptoSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cryptoSMA: async (cryptoTicker: string, timestamp?: string, timespan?: CryptoSMATimespanEnum, window?: number, seriesType?: CryptoSMASeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('cryptoSMA', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/sma/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {EMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {EMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {EMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eMA: async (stockTicker: string, timestamp?: string, timespan?: EMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: EMASeriesTypeEnum, expandUnderlying?: boolean, order?: EMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('eMA', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/ema/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {ForexEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forexEMA: async (fxTicker: string, timestamp?: string, timespan?: ForexEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexEMASeriesTypeEnum, expandUnderlying?: boolean, order?: ForexEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('forexEMA', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/ema/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} fxTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {ForexMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forexMACD: async (fxTicker: string, timestamp?: string, timespan?: ForexMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: ForexMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: ForexMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('forexMACD', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/macd/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} fxTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {ForexRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forexRSI: async (fxTicker: string, timestamp?: string, timespan?: ForexRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexRSISeriesTypeEnum, expandUnderlying?: boolean, order?: ForexRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('forexRSI', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/rsi/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} fxTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {ForexSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forexSMA: async (fxTicker: string, timestamp?: string, timespan?: ForexSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexSMASeriesTypeEnum, expandUnderlying?: boolean, order?: ForexSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('forexSMA', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/sma/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
         * @summary Ticker Events
         * @param {string} id Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the  [Ticker Details Endpoint](https://polygon.io/docs/stocks/get_v3_reference_tickers__ticker)
         * @param {string} [types] A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (id: string, types?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEvents', 'id', id)
            const localVarPath = `/vX/reference/tickers/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get upcoming market holidays and their open/close times.
         * @summary Market Holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketHolidays: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketstatus/upcoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current trading status of the exchanges and overall financial markets.
         * @summary Market Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketstatus/now`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an options contract
         * @summary Options Contract
         * @param {string} optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://polygon.io/blog/how-to-read-a-stock-options-ticker/).
         * @param {string} [asOf] Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsContract: async (optionsTicker: string, asOf?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsContract', 'optionsTicker', optionsTicker)
            const localVarPath = `/v3/reference/options/contracts/{options_ticker}`
                .replace(`{${"options_ticker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (asOf !== undefined) {
                localVarQueryParameter['as_of'] = asOf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of tickers related to the queried ticker based on News and Returns data.
         * @summary Related Companies
         * @param {string} ticker The ticker symbol to search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedCompanies: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getRelatedCompanies', 'ticker', ticker)
            const localVarPath = `/v1/related-companies/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
         * @summary Ticker Details v3
         * @param {string} ticker The ticker symbol of the asset.
         * @param {string} [date] Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker: async (ticker: string, date?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getTicker', 'ticker', ticker)
            const localVarPath = `/v3/reference/tickers/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {IndicesEMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indicesEMA: async (indicesTicker: string, timestamp?: string, timespan?: IndicesEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesEMASeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('indicesEMA', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/ema/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} indicesTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {IndicesMACDSeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close values to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indicesMACD: async (indicesTicker: string, timestamp?: string, timespan?: IndicesMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: IndicesMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('indicesMACD', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/macd/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {IndicesRSISeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close values to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indicesRSI: async (indicesTicker: string, timestamp?: string, timespan?: IndicesRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesRSISeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('indicesRSI', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/rsi/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {IndicesSMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indicesSMA: async (indicesTicker: string, timestamp?: string, timespan?: IndicesSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesSMASeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('indicesSMA', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/sma/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Snapshot of indices data for said tickers
         * @summary Indices Snapshot
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {IndicesSnapshotOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {IndicesSnapshotSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indicesSnapshot: async (tickerAnyOf?: string, ticker?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: IndicesSnapshotOrderEnum, limit?: number, sort?: IndicesSnapshotSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/snapshot/indices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent NBBO (Quote) tick for a given stock.
         * @summary Last Quote
         * @param {string} stocksTicker The ticker symbol of the stock/equity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastQuote: async (stocksTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('lastQuote', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/last/nbbo/{stocksTicker}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the last quote tick for a forex currency pair.
         * @summary Last Quote for a Currency Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastQuoteCurrencies: async (from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('lastQuoteCurrencies', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('lastQuoteCurrencies', 'to', to)
            const localVarPath = `/v1/last_quote/currencies/{from}/{to}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent trade for a given stock.
         * @summary Last Trade
         * @param {string} stocksTicker The ticker symbol of the stock/equity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastTrade: async (stocksTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('lastTrade', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/last/trade/{stocksTicker}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the last trade tick for a cryptocurrency pair.
         * @summary Last Trade for a Crypto Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastTradeCrypto: async (from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('lastTradeCrypto', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('lastTradeCrypto', 'to', to)
            const localVarPath = `/v1/last/crypto/{from}/{to}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent trade for a given options contract.
         * @summary Last Trade
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastTradeOptions: async (optionsTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('lastTradeOptions', 'optionsTicker', optionsTicker)
            const localVarPath = `/v2/last/trade/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all conditions that Polygon.io uses.
         * @summary Conditions
         * @param {ListConditionsAssetClassEnum} [assetClass] Filter for conditions within a given asset class.
         * @param {ListConditionsDataTypeEnum} [dataType] Filter by data type.
         * @param {number} [id] Filter for conditions with a given ID.
         * @param {ListConditionsSipEnum} [sip] Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
         * @param {ListConditionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListConditionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConditions: async (assetClass?: ListConditionsAssetClassEnum, dataType?: ListConditionsDataTypeEnum, id?: number, sip?: ListConditionsSipEnum, order?: ListConditionsOrderEnum, limit?: number, sort?: ListConditionsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/conditions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (assetClass !== undefined) {
                localVarQueryParameter['asset_class'] = assetClass;
            }

            if (dataType !== undefined) {
                localVarQueryParameter['data_type'] = dataType;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (sip !== undefined) {
                localVarQueryParameter['sip'] = sip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
         * @summary Dividends v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [exDividendDate] Query by ex-dividend date with the format YYYY-MM-DD.
         * @param {string} [recordDate] Query by record date with the format YYYY-MM-DD.
         * @param {string} [declarationDate] Query by declaration date with the format YYYY-MM-DD.
         * @param {string} [payDate] Query by pay date with the format YYYY-MM-DD.
         * @param {ListDividendsFrequencyEnum} [frequency] Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
         * @param {number} [cashAmount] Query by the cash amount of the dividend.
         * @param {ListDividendsDividendTypeEnum} [dividendType] Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [exDividendDateGte] Range by ex_dividend_date.
         * @param {string} [exDividendDateGt] Range by ex_dividend_date.
         * @param {string} [exDividendDateLte] Range by ex_dividend_date.
         * @param {string} [exDividendDateLt] Range by ex_dividend_date.
         * @param {string} [recordDateGte] Range by record_date.
         * @param {string} [recordDateGt] Range by record_date.
         * @param {string} [recordDateLte] Range by record_date.
         * @param {string} [recordDateLt] Range by record_date.
         * @param {string} [declarationDateGte] Range by declaration_date.
         * @param {string} [declarationDateGt] Range by declaration_date.
         * @param {string} [declarationDateLte] Range by declaration_date.
         * @param {string} [declarationDateLt] Range by declaration_date.
         * @param {string} [payDateGte] Range by pay_date.
         * @param {string} [payDateGt] Range by pay_date.
         * @param {string} [payDateLte] Range by pay_date.
         * @param {string} [payDateLt] Range by pay_date.
         * @param {number} [cashAmountGte] Range by cash_amount.
         * @param {number} [cashAmountGt] Range by cash_amount.
         * @param {number} [cashAmountLte] Range by cash_amount.
         * @param {number} [cashAmountLt] Range by cash_amount.
         * @param {ListDividendsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListDividendsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDividends: async (ticker?: string, exDividendDate?: string, recordDate?: string, declarationDate?: string, payDate?: string, frequency?: ListDividendsFrequencyEnum, cashAmount?: number, dividendType?: ListDividendsDividendTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, exDividendDateGte?: string, exDividendDateGt?: string, exDividendDateLte?: string, exDividendDateLt?: string, recordDateGte?: string, recordDateGt?: string, recordDateLte?: string, recordDateLt?: string, declarationDateGte?: string, declarationDateGt?: string, declarationDateLte?: string, declarationDateLt?: string, payDateGte?: string, payDateGt?: string, payDateLte?: string, payDateLt?: string, cashAmountGte?: number, cashAmountGt?: number, cashAmountLte?: number, cashAmountLt?: number, order?: ListDividendsOrderEnum, limit?: number, sort?: ListDividendsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/dividends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (exDividendDate !== undefined) {
                localVarQueryParameter['ex_dividend_date'] = (exDividendDate as any instanceof Date) ?
                    (exDividendDate as any).toISOString().substring(0,10) :
                    exDividendDate;
            }

            if (recordDate !== undefined) {
                localVarQueryParameter['record_date'] = (recordDate as any instanceof Date) ?
                    (recordDate as any).toISOString().substring(0,10) :
                    recordDate;
            }

            if (declarationDate !== undefined) {
                localVarQueryParameter['declaration_date'] = (declarationDate as any instanceof Date) ?
                    (declarationDate as any).toISOString().substring(0,10) :
                    declarationDate;
            }

            if (payDate !== undefined) {
                localVarQueryParameter['pay_date'] = (payDate as any instanceof Date) ?
                    (payDate as any).toISOString().substring(0,10) :
                    payDate;
            }

            if (frequency !== undefined) {
                localVarQueryParameter['frequency'] = frequency;
            }

            if (cashAmount !== undefined) {
                localVarQueryParameter['cash_amount'] = cashAmount;
            }

            if (dividendType !== undefined) {
                localVarQueryParameter['dividend_type'] = dividendType;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (exDividendDateGte !== undefined) {
                localVarQueryParameter['ex_dividend_date.gte'] = (exDividendDateGte as any instanceof Date) ?
                    (exDividendDateGte as any).toISOString().substring(0,10) :
                    exDividendDateGte;
            }

            if (exDividendDateGt !== undefined) {
                localVarQueryParameter['ex_dividend_date.gt'] = (exDividendDateGt as any instanceof Date) ?
                    (exDividendDateGt as any).toISOString().substring(0,10) :
                    exDividendDateGt;
            }

            if (exDividendDateLte !== undefined) {
                localVarQueryParameter['ex_dividend_date.lte'] = (exDividendDateLte as any instanceof Date) ?
                    (exDividendDateLte as any).toISOString().substring(0,10) :
                    exDividendDateLte;
            }

            if (exDividendDateLt !== undefined) {
                localVarQueryParameter['ex_dividend_date.lt'] = (exDividendDateLt as any instanceof Date) ?
                    (exDividendDateLt as any).toISOString().substring(0,10) :
                    exDividendDateLt;
            }

            if (recordDateGte !== undefined) {
                localVarQueryParameter['record_date.gte'] = (recordDateGte as any instanceof Date) ?
                    (recordDateGte as any).toISOString().substring(0,10) :
                    recordDateGte;
            }

            if (recordDateGt !== undefined) {
                localVarQueryParameter['record_date.gt'] = (recordDateGt as any instanceof Date) ?
                    (recordDateGt as any).toISOString().substring(0,10) :
                    recordDateGt;
            }

            if (recordDateLte !== undefined) {
                localVarQueryParameter['record_date.lte'] = (recordDateLte as any instanceof Date) ?
                    (recordDateLte as any).toISOString().substring(0,10) :
                    recordDateLte;
            }

            if (recordDateLt !== undefined) {
                localVarQueryParameter['record_date.lt'] = (recordDateLt as any instanceof Date) ?
                    (recordDateLt as any).toISOString().substring(0,10) :
                    recordDateLt;
            }

            if (declarationDateGte !== undefined) {
                localVarQueryParameter['declaration_date.gte'] = (declarationDateGte as any instanceof Date) ?
                    (declarationDateGte as any).toISOString().substring(0,10) :
                    declarationDateGte;
            }

            if (declarationDateGt !== undefined) {
                localVarQueryParameter['declaration_date.gt'] = (declarationDateGt as any instanceof Date) ?
                    (declarationDateGt as any).toISOString().substring(0,10) :
                    declarationDateGt;
            }

            if (declarationDateLte !== undefined) {
                localVarQueryParameter['declaration_date.lte'] = (declarationDateLte as any instanceof Date) ?
                    (declarationDateLte as any).toISOString().substring(0,10) :
                    declarationDateLte;
            }

            if (declarationDateLt !== undefined) {
                localVarQueryParameter['declaration_date.lt'] = (declarationDateLt as any instanceof Date) ?
                    (declarationDateLt as any).toISOString().substring(0,10) :
                    declarationDateLt;
            }

            if (payDateGte !== undefined) {
                localVarQueryParameter['pay_date.gte'] = (payDateGte as any instanceof Date) ?
                    (payDateGte as any).toISOString().substring(0,10) :
                    payDateGte;
            }

            if (payDateGt !== undefined) {
                localVarQueryParameter['pay_date.gt'] = (payDateGt as any instanceof Date) ?
                    (payDateGt as any).toISOString().substring(0,10) :
                    payDateGt;
            }

            if (payDateLte !== undefined) {
                localVarQueryParameter['pay_date.lte'] = (payDateLte as any instanceof Date) ?
                    (payDateLte as any).toISOString().substring(0,10) :
                    payDateLte;
            }

            if (payDateLt !== undefined) {
                localVarQueryParameter['pay_date.lt'] = (payDateLt as any instanceof Date) ?
                    (payDateLt as any).toISOString().substring(0,10) :
                    payDateLt;
            }

            if (cashAmountGte !== undefined) {
                localVarQueryParameter['cash_amount.gte'] = cashAmountGte;
            }

            if (cashAmountGt !== undefined) {
                localVarQueryParameter['cash_amount.gt'] = cashAmountGt;
            }

            if (cashAmountLte !== undefined) {
                localVarQueryParameter['cash_amount.lte'] = cashAmountLte;
            }

            if (cashAmountLt !== undefined) {
                localVarQueryParameter['cash_amount.lt'] = cashAmountLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all exchanges that Polygon.io knows about.
         * @summary Exchanges
         * @param {ListExchangesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListExchangesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExchanges: async (assetClass?: ListExchangesAssetClassEnum, locale?: ListExchangesLocaleEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (assetClass !== undefined) {
                localVarQueryParameter['asset_class'] = assetClass;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
         * @summary Stock Financials vX
         * @param {string} [ticker] Query by company ticker.
         * @param {string} [cik] Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number
         * @param {string} [companyName] Query by company name.
         * @param {string} [sic] Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;)
         * @param {string} [filingDate] Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01
         * @param {string} [periodOfReportDate] The period of report for the filing with financials data in YYYY-MM-DD format.
         * @param {ListFinancialsTimeframeEnum} [timeframe] Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
         * @param {boolean} [includeSources] Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default.
         * @param {string} [companyNameSearch] Search by company_name.
         * @param {string} [filingDateGte] Search by filing_date.
         * @param {string} [filingDateGt] Search by filing_date.
         * @param {string} [filingDateLte] Search by filing_date.
         * @param {string} [filingDateLt] Search by filing_date.
         * @param {string} [periodOfReportDateGte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateGt] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLt] Search by period_of_report_date.
         * @param {ListFinancialsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 100.
         * @param {ListFinancialsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFinancials: async (ticker?: string, cik?: string, companyName?: string, sic?: string, filingDate?: string, periodOfReportDate?: string, timeframe?: ListFinancialsTimeframeEnum, includeSources?: boolean, companyNameSearch?: string, filingDateGte?: string, filingDateGt?: string, filingDateLte?: string, filingDateLt?: string, periodOfReportDateGte?: string, periodOfReportDateGt?: string, periodOfReportDateLte?: string, periodOfReportDateLt?: string, order?: ListFinancialsOrderEnum, limit?: number, sort?: ListFinancialsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vX/reference/financials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (companyName !== undefined) {
                localVarQueryParameter['company_name'] = companyName;
            }

            if (sic !== undefined) {
                localVarQueryParameter['sic'] = sic;
            }

            if (filingDate !== undefined) {
                localVarQueryParameter['filing_date'] = (filingDate as any instanceof Date) ?
                    (filingDate as any).toISOString().substring(0,10) :
                    filingDate;
            }

            if (periodOfReportDate !== undefined) {
                localVarQueryParameter['period_of_report_date'] = (periodOfReportDate as any instanceof Date) ?
                    (periodOfReportDate as any).toISOString().substring(0,10) :
                    periodOfReportDate;
            }

            if (timeframe !== undefined) {
                localVarQueryParameter['timeframe'] = timeframe;
            }

            if (includeSources !== undefined) {
                localVarQueryParameter['include_sources'] = includeSources;
            }

            if (companyNameSearch !== undefined) {
                localVarQueryParameter['company_name.search'] = companyNameSearch;
            }

            if (filingDateGte !== undefined) {
                localVarQueryParameter['filing_date.gte'] = (filingDateGte as any instanceof Date) ?
                    (filingDateGte as any).toISOString().substring(0,10) :
                    filingDateGte;
            }

            if (filingDateGt !== undefined) {
                localVarQueryParameter['filing_date.gt'] = (filingDateGt as any instanceof Date) ?
                    (filingDateGt as any).toISOString().substring(0,10) :
                    filingDateGt;
            }

            if (filingDateLte !== undefined) {
                localVarQueryParameter['filing_date.lte'] = (filingDateLte as any instanceof Date) ?
                    (filingDateLte as any).toISOString().substring(0,10) :
                    filingDateLte;
            }

            if (filingDateLt !== undefined) {
                localVarQueryParameter['filing_date.lt'] = (filingDateLt as any instanceof Date) ?
                    (filingDateLt as any).toISOString().substring(0,10) :
                    filingDateLt;
            }

            if (periodOfReportDateGte !== undefined) {
                localVarQueryParameter['period_of_report_date.gte'] = (periodOfReportDateGte as any instanceof Date) ?
                    (periodOfReportDateGte as any).toISOString().substring(0,10) :
                    periodOfReportDateGte;
            }

            if (periodOfReportDateGt !== undefined) {
                localVarQueryParameter['period_of_report_date.gt'] = (periodOfReportDateGt as any instanceof Date) ?
                    (periodOfReportDateGt as any).toISOString().substring(0,10) :
                    periodOfReportDateGt;
            }

            if (periodOfReportDateLte !== undefined) {
                localVarQueryParameter['period_of_report_date.lte'] = (periodOfReportDateLte as any instanceof Date) ?
                    (periodOfReportDateLte as any).toISOString().substring(0,10) :
                    periodOfReportDateLte;
            }

            if (periodOfReportDateLt !== undefined) {
                localVarQueryParameter['period_of_report_date.lt'] = (periodOfReportDateLt as any instanceof Date) ?
                    (periodOfReportDateLt as any).toISOString().substring(0,10) :
                    periodOfReportDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
         * @summary IPOs
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [usCode] Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
         * @param {string} [isin] Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
         * @param {string} [listingDate] Specify a listing date. This is the first trading date for the newly listed entity.
         * @param {ListIPOsIpoStatusEnum} [ipoStatus] Specify an IPO status.
         * @param {string} [listingDateGte] Range by listing_date.
         * @param {string} [listingDateGt] Range by listing_date.
         * @param {string} [listingDateLte] Range by listing_date.
         * @param {string} [listingDateLt] Range by listing_date.
         * @param {ListIPOsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListIPOsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIPOs: async (ticker?: string, usCode?: string, isin?: string, listingDate?: string, ipoStatus?: ListIPOsIpoStatusEnum, listingDateGte?: string, listingDateGt?: string, listingDateLte?: string, listingDateLt?: string, order?: ListIPOsOrderEnum, limit?: number, sort?: ListIPOsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vX/reference/ipos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (usCode !== undefined) {
                localVarQueryParameter['us_code'] = usCode;
            }

            if (isin !== undefined) {
                localVarQueryParameter['isin'] = isin;
            }

            if (listingDate !== undefined) {
                localVarQueryParameter['listing_date'] = (listingDate as any instanceof Date) ?
                    (listingDate as any).toISOString().substring(0,10) :
                    listingDate;
            }

            if (ipoStatus !== undefined) {
                localVarQueryParameter['ipo_status'] = ipoStatus;
            }

            if (listingDateGte !== undefined) {
                localVarQueryParameter['listing_date.gte'] = (listingDateGte as any instanceof Date) ?
                    (listingDateGte as any).toISOString().substring(0,10) :
                    listingDateGte;
            }

            if (listingDateGt !== undefined) {
                localVarQueryParameter['listing_date.gt'] = (listingDateGt as any instanceof Date) ?
                    (listingDateGt as any).toISOString().substring(0,10) :
                    listingDateGt;
            }

            if (listingDateLte !== undefined) {
                localVarQueryParameter['listing_date.lte'] = (listingDateLte as any instanceof Date) ?
                    (listingDateLte as any).toISOString().substring(0,10) :
                    listingDateLte;
            }

            if (listingDateLt !== undefined) {
                localVarQueryParameter['listing_date.lt'] = (listingDateLt as any instanceof Date) ?
                    (listingDateLt as any).toISOString().substring(0,10) :
                    listingDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
         * @summary Ticker News
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtc] Return results published on, before, or after this date.
         * @param {string} [tickerGte] Search by ticker.
         * @param {string} [tickerGt] Search by ticker.
         * @param {string} [tickerLte] Search by ticker.
         * @param {string} [tickerLt] Search by ticker.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGt] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLt] Search by published_utc.
         * @param {ListNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListNewsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNews: async (ticker?: string, publishedUtc?: ListNewsPublishedUtcParameter, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, publishedUtcGte?: ListNewsPublishedUtcParameter, publishedUtcGt?: ListNewsPublishedUtcParameter, publishedUtcLte?: ListNewsPublishedUtcParameter, publishedUtcLt?: ListNewsPublishedUtcParameter, order?: ListNewsOrderEnum, limit?: number, sort?: ListNewsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/reference/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (publishedUtc !== undefined) {
                for (const [key, value] of Object.entries(publishedUtc)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (publishedUtcGte !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcGte)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (publishedUtcGt !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcGt)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (publishedUtcLte !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcLte)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (publishedUtcLt !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcLt)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for historical options contracts. This provides both active and expired options contracts.
         * @summary Options Contracts
         * @param {string} [ticker] This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://polygon.io/docs/options/get_v3_reference_options_contracts__options_ticker).
         * @param {string} [underlyingTicker] Query for contracts relating to an underlying stock ticker.
         * @param {ListOptionsContractsContractTypeEnum} [contractType] Query by the type of contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {string} [asOf] Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {boolean} [expired] Query for expired contracts. Default is false.
         * @param {string} [underlyingTickerGte] Range by underlying_ticker.
         * @param {string} [underlyingTickerGt] Range by underlying_ticker.
         * @param {string} [underlyingTickerLte] Range by underlying_ticker.
         * @param {string} [underlyingTickerLt] Range by underlying_ticker.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {ListOptionsContractsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListOptionsContractsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOptionsContracts: async (ticker?: string, underlyingTicker?: string, contractType?: ListOptionsContractsContractTypeEnum, expirationDate?: string, asOf?: string, strikePrice?: number, expired?: boolean, underlyingTickerGte?: string, underlyingTickerGt?: string, underlyingTickerLte?: string, underlyingTickerLt?: string, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, order?: ListOptionsContractsOrderEnum, limit?: number, sort?: ListOptionsContractsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/options/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (underlyingTicker !== undefined) {
                localVarQueryParameter['underlying_ticker'] = underlyingTicker;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contract_type'] = contractType;
            }

            if (expirationDate !== undefined) {
                localVarQueryParameter['expiration_date'] = expirationDate;
            }

            if (asOf !== undefined) {
                localVarQueryParameter['as_of'] = asOf;
            }

            if (strikePrice !== undefined) {
                localVarQueryParameter['strike_price'] = strikePrice;
            }

            if (expired !== undefined) {
                localVarQueryParameter['expired'] = expired;
            }

            if (underlyingTickerGte !== undefined) {
                localVarQueryParameter['underlying_ticker.gte'] = underlyingTickerGte;
            }

            if (underlyingTickerGt !== undefined) {
                localVarQueryParameter['underlying_ticker.gt'] = underlyingTickerGt;
            }

            if (underlyingTickerLte !== undefined) {
                localVarQueryParameter['underlying_ticker.lte'] = underlyingTickerLte;
            }

            if (underlyingTickerLt !== undefined) {
                localVarQueryParameter['underlying_ticker.lt'] = underlyingTickerLt;
            }

            if (expirationDateGte !== undefined) {
                localVarQueryParameter['expiration_date.gte'] = expirationDateGte;
            }

            if (expirationDateGt !== undefined) {
                localVarQueryParameter['expiration_date.gt'] = expirationDateGt;
            }

            if (expirationDateLte !== undefined) {
                localVarQueryParameter['expiration_date.lte'] = expirationDateLte;
            }

            if (expirationDateLt !== undefined) {
                localVarQueryParameter['expiration_date.lt'] = expirationDateLt;
            }

            if (strikePriceGte !== undefined) {
                localVarQueryParameter['strike_price.gte'] = strikePriceGte;
            }

            if (strikePriceGt !== undefined) {
                localVarQueryParameter['strike_price.gt'] = strikePriceGt;
            }

            if (strikePriceLte !== undefined) {
                localVarQueryParameter['strike_price.lte'] = strikePriceLte;
            }

            if (strikePriceLt !== undefined) {
                localVarQueryParameter['strike_price.lt'] = strikePriceLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
         * @summary Stock Splits v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [executionDate] Query by execution date with the format YYYY-MM-DD.
         * @param {boolean | null} [reverseSplit] Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [executionDateGte] Range by execution_date.
         * @param {string} [executionDateGt] Range by execution_date.
         * @param {string} [executionDateLte] Range by execution_date.
         * @param {string} [executionDateLt] Range by execution_date.
         * @param {ListStockSplitsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListStockSplitsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStockSplits: async (ticker?: string, executionDate?: string, reverseSplit?: boolean | null, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, executionDateGte?: string, executionDateGt?: string, executionDateLte?: string, executionDateLt?: string, order?: ListStockSplitsOrderEnum, limit?: number, sort?: ListStockSplitsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/splits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (executionDate !== undefined) {
                localVarQueryParameter['execution_date'] = (executionDate as any instanceof Date) ?
                    (executionDate as any).toISOString().substring(0,10) :
                    executionDate;
            }

            if (reverseSplit !== undefined) {
                localVarQueryParameter['reverse_split'] = reverseSplit;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (executionDateGte !== undefined) {
                localVarQueryParameter['execution_date.gte'] = (executionDateGte as any instanceof Date) ?
                    (executionDateGte as any).toISOString().substring(0,10) :
                    executionDateGte;
            }

            if (executionDateGt !== undefined) {
                localVarQueryParameter['execution_date.gt'] = (executionDateGt as any instanceof Date) ?
                    (executionDateGt as any).toISOString().substring(0,10) :
                    executionDateGt;
            }

            if (executionDateLte !== undefined) {
                localVarQueryParameter['execution_date.lte'] = (executionDateLte as any instanceof Date) ?
                    (executionDateLte as any).toISOString().substring(0,10) :
                    executionDateLte;
            }

            if (executionDateLt !== undefined) {
                localVarQueryParameter['execution_date.lt'] = (executionDateLt as any instanceof Date) ?
                    (executionDateLt as any).toISOString().substring(0,10) :
                    executionDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all ticker types that Polygon.io has.
         * @summary Ticker Types
         * @param {ListTickerTypesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListTickerTypesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickerTypes: async (assetClass?: ListTickerTypesAssetClassEnum, locale?: ListTickerTypesLocaleEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/tickers/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (assetClass !== undefined) {
                localVarQueryParameter['asset_class'] = assetClass;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
         * @summary Tickers
         * @param {string} [ticker] Specify a ticker symbol. Defaults to empty string which queries all tickers.
         * @param {ListTickersTypeEnum} [type] Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types). Defaults to empty string which queries all types.
         * @param {ListTickersMarketEnum} [market] Filter by market type. By default all markets are included.
         * @param {string} [exchange] Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes [at the ISO org website](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges.
         * @param {string} [cusip] Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
         * @param {string} [cik] Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs.
         * @param {string} [date] Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.
         * @param {string} [search] Search for terms within the ticker and/or company name.
         * @param {boolean} [active] Specify if the tickers returned should be actively traded on the queried date. Default is true.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {ListTickersOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 1000.
         * @param {ListTickersSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickers: async (ticker?: string, type?: ListTickersTypeEnum, market?: ListTickersMarketEnum, exchange?: string, cusip?: string, cik?: string, date?: string, search?: string, active?: boolean, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: ListTickersOrderEnum, limit?: number, sort?: ListTickersSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (exchange !== undefined) {
                localVarQueryParameter['exchange'] = exchange;
            }

            if (cusip !== undefined) {
                localVarQueryParameter['cusip'] = cusip;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {MACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {MACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {MACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mACD: async (stockTicker: string, timestamp?: string, timespan?: MACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: MACDSeriesTypeEnum, expandUnderlying?: boolean, order?: MACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('mACD', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/macd/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the snapshot of an option contract for a stock equity.
         * @summary Option Contract
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {string} optionContract The option contract identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionContract: async (underlyingAsset: string, optionContract: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'underlyingAsset' is not null or undefined
            assertParamExists('optionContract', 'underlyingAsset', underlyingAsset)
            // verify required parameter 'optionContract' is not null or undefined
            assertParamExists('optionContract', 'optionContract', optionContract)
            const localVarPath = `/v3/snapshot/options/{underlyingAsset}/{optionContract}`
                .replace(`{${"underlyingAsset"}}`, encodeURIComponent(String(underlyingAsset)))
                .replace(`{${"optionContract"}}`, encodeURIComponent(String(optionContract)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the snapshot of all options contracts for an underlying ticker.
         * @summary Options Chain
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {OptionsChainContractTypeEnum} [contractType] Query by the type of contract.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {OptionsChainOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {OptionsChainSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsChain: async (underlyingAsset: string, strikePrice?: number, expirationDate?: string, contractType?: OptionsChainContractTypeEnum, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, order?: OptionsChainOrderEnum, limit?: number, sort?: OptionsChainSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'underlyingAsset' is not null or undefined
            assertParamExists('optionsChain', 'underlyingAsset', underlyingAsset)
            const localVarPath = `/v3/snapshot/options/{underlyingAsset}`
                .replace(`{${"underlyingAsset"}}`, encodeURIComponent(String(underlyingAsset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (strikePrice !== undefined) {
                localVarQueryParameter['strike_price'] = strikePrice;
            }

            if (expirationDate !== undefined) {
                localVarQueryParameter['expiration_date'] = expirationDate;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contract_type'] = contractType;
            }

            if (strikePriceGte !== undefined) {
                localVarQueryParameter['strike_price.gte'] = strikePriceGte;
            }

            if (strikePriceGt !== undefined) {
                localVarQueryParameter['strike_price.gt'] = strikePriceGt;
            }

            if (strikePriceLte !== undefined) {
                localVarQueryParameter['strike_price.lte'] = strikePriceLte;
            }

            if (strikePriceLt !== undefined) {
                localVarQueryParameter['strike_price.lt'] = strikePriceLt;
            }

            if (expirationDateGte !== undefined) {
                localVarQueryParameter['expiration_date.gte'] = expirationDateGte;
            }

            if (expirationDateGt !== undefined) {
                localVarQueryParameter['expiration_date.gt'] = expirationDateGt;
            }

            if (expirationDateLte !== undefined) {
                localVarQueryParameter['expiration_date.lte'] = expirationDateLte;
            }

            if (expirationDateLt !== undefined) {
                localVarQueryParameter['expiration_date.lt'] = expirationDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {OptionsEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsEMA: async (optionsTicker: string, timestamp?: string, timespan?: OptionsEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsEMASeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('optionsEMA', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/ema/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} optionsTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {OptionsMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsMACD: async (optionsTicker: string, timestamp?: string, timespan?: OptionsMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: OptionsMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('optionsMACD', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/macd/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {OptionsRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsRSI: async (optionsTicker: string, timestamp?: string, timespan?: OptionsRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsRSISeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('optionsRSI', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/rsi/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {OptionsSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsSMA: async (optionsTicker: string, timestamp?: string, timespan?: OptionsSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsSMASeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('optionsSMA', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/sma/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get NBBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (NBBO)
         * @param {string} stockTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {QuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {QuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotes: async (stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesOrderEnum, limit?: number, sort?: QuotesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('quotes', 'stockTicker', stockTicker)
            const localVarPath = `/v3/quotes/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get BBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (BBO)
         * @param {string} fxTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {QuotesFxOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {QuotesFxSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesFx: async (fxTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesFxOrderEnum, limit?: number, sort?: QuotesFxSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('quotesFx', 'fxTicker', fxTicker)
            const localVarPath = `/v3/quotes/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get quotes for an options ticker symbol in a given time range.
         * @summary Quotes
         * @param {string} optionsTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {QuotesOptionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {QuotesOptionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesOptions: async (optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesOptionsOrderEnum, limit?: number, sort?: QuotesOptionsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('quotesOptions', 'optionsTicker', optionsTicker)
            const localVarPath = `/v3/quotes/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {RSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {RSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {RSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rSI: async (stockTicker: string, timestamp?: string, timespan?: RSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: RSISeriesTypeEnum, expandUnderlying?: boolean, order?: RSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('rSI', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/rsi/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
         * @summary Real-time Currency Conversion
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {number} [amount] The amount to convert, with a decimal.
         * @param {RealTimeCurrencyConversionPrecisionEnum} [precision] The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        realTimeCurrencyConversion: async (from: string, to: string, amount?: number, precision?: RealTimeCurrencyConversionPrecisionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('realTimeCurrencyConversion', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('realTimeCurrencyConversion', 'to', to)
            const localVarPath = `/v1/conversion/{from}/{to}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (precision !== undefined) {
                localVarQueryParameter['precision'] = precision;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {SMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {SMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {SMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sMA: async (stockTicker: string, timestamp?: string, timespan?: SMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: SMASeriesTypeEnum, expandUnderlying?: boolean, order?: SMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('sMA', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/sma/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
         * @summary Summaries
         * @param {string} [tickerAnyOf] Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://polygon.io/docs/stocks/get_v3_reference_tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotSummary: async (tickerAnyOf?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/summaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get snapshots for assets of all types
         * @summary Universal Snapshot
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {SnapshotsTypeEnum} [type] Query by the type of asset.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. 
         * @param {SnapshotsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {SnapshotsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshots: async (ticker?: string, type?: SnapshotsTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, tickerAnyOf?: string, order?: SnapshotsOrderEnum, limit?: number, sort?: SnapshotsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/snapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve finra_short_interest_v1 data via API.
         * @summary finra_short_interest_v1 API
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [daysToCover] Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume.
         * @param {string} [settlementDate] The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
         * @param {string} [avgDailyVolume] The average daily trading volume for the stock over a specified period, typically used to contextualize short interest.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [daysToCoverGte] Range by days_to_cover.
         * @param {string} [daysToCoverGt] Range by days_to_cover.
         * @param {string} [daysToCoverLte] Range by days_to_cover.
         * @param {string} [daysToCoverLt] Range by days_to_cover.
         * @param {string} [settlementDateGte] Range by settlement_date.
         * @param {string} [settlementDateGt] Range by settlement_date.
         * @param {string} [settlementDateLte] Range by settlement_date.
         * @param {string} [settlementDateLt] Range by settlement_date.
         * @param {string} [avgDailyVolumeGte] Range by avg_daily_volume.
         * @param {string} [avgDailyVolumeGt] Range by avg_daily_volume.
         * @param {string} [avgDailyVolumeLte] Range by avg_daily_volume.
         * @param {string} [avgDailyVolumeLt] Range by avg_daily_volume.
         * @param {StocksShortInterestOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 50000.
         * @param {StocksShortInterestSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stocksShortInterest: async (ticker?: string, daysToCover?: string, settlementDate?: string, avgDailyVolume?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, daysToCoverGte?: string, daysToCoverGt?: string, daysToCoverLte?: string, daysToCoverLt?: string, settlementDateGte?: string, settlementDateGt?: string, settlementDateLte?: string, settlementDateLt?: string, avgDailyVolumeGte?: string, avgDailyVolumeGt?: string, avgDailyVolumeLte?: string, avgDailyVolumeLt?: string, order?: StocksShortInterestOrderEnum, limit?: number, sort?: StocksShortInterestSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/vX/short-interest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (daysToCover !== undefined) {
                localVarQueryParameter['days_to_cover'] = daysToCover;
            }

            if (settlementDate !== undefined) {
                localVarQueryParameter['settlement_date'] = settlementDate;
            }

            if (avgDailyVolume !== undefined) {
                localVarQueryParameter['avg_daily_volume'] = avgDailyVolume;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (daysToCoverGte !== undefined) {
                localVarQueryParameter['days_to_cover.gte'] = daysToCoverGte;
            }

            if (daysToCoverGt !== undefined) {
                localVarQueryParameter['days_to_cover.gt'] = daysToCoverGt;
            }

            if (daysToCoverLte !== undefined) {
                localVarQueryParameter['days_to_cover.lte'] = daysToCoverLte;
            }

            if (daysToCoverLt !== undefined) {
                localVarQueryParameter['days_to_cover.lt'] = daysToCoverLt;
            }

            if (settlementDateGte !== undefined) {
                localVarQueryParameter['settlement_date.gte'] = settlementDateGte;
            }

            if (settlementDateGt !== undefined) {
                localVarQueryParameter['settlement_date.gt'] = settlementDateGt;
            }

            if (settlementDateLte !== undefined) {
                localVarQueryParameter['settlement_date.lte'] = settlementDateLte;
            }

            if (settlementDateLt !== undefined) {
                localVarQueryParameter['settlement_date.lt'] = settlementDateLt;
            }

            if (avgDailyVolumeGte !== undefined) {
                localVarQueryParameter['avg_daily_volume.gte'] = avgDailyVolumeGte;
            }

            if (avgDailyVolumeGt !== undefined) {
                localVarQueryParameter['avg_daily_volume.gt'] = avgDailyVolumeGt;
            }

            if (avgDailyVolumeLte !== undefined) {
                localVarQueryParameter['avg_daily_volume.lte'] = avgDailyVolumeLte;
            }

            if (avgDailyVolumeLt !== undefined) {
                localVarQueryParameter['avg_daily_volume.lt'] = avgDailyVolumeLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve finra_short_volume_v1 data via API.
         * @summary finra_short_volume_v1 API
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [date] The date of trade activity reported in the format YYYY-MM-DD
         * @param {string} [shortVolumeRatio] The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100.
         * @param {string} [totalVolume] Total reported volume across all venues for the ticker on the given date.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [dateGte] Range by date.
         * @param {string} [dateGt] Range by date.
         * @param {string} [dateLte] Range by date.
         * @param {string} [dateLt] Range by date.
         * @param {string} [shortVolumeRatioGte] Range by short_volume_ratio.
         * @param {string} [shortVolumeRatioGt] Range by short_volume_ratio.
         * @param {string} [shortVolumeRatioLte] Range by short_volume_ratio.
         * @param {string} [shortVolumeRatioLt] Range by short_volume_ratio.
         * @param {string} [totalVolumeGte] Range by total_volume.
         * @param {string} [totalVolumeGt] Range by total_volume.
         * @param {string} [totalVolumeLte] Range by total_volume.
         * @param {string} [totalVolumeLt] Range by total_volume.
         * @param {StocksShortVolumeOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 50000.
         * @param {StocksShortVolumeSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stocksShortVolume: async (ticker?: string, date?: string, shortVolumeRatio?: string, totalVolume?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, shortVolumeRatioGte?: string, shortVolumeRatioGt?: string, shortVolumeRatioLte?: string, shortVolumeRatioLt?: string, totalVolumeGte?: string, totalVolumeGt?: string, totalVolumeLte?: string, totalVolumeLt?: string, order?: StocksShortVolumeOrderEnum, limit?: number, sort?: StocksShortVolumeSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/vX/short-volume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (shortVolumeRatio !== undefined) {
                localVarQueryParameter['short_volume_ratio'] = shortVolumeRatio;
            }

            if (totalVolume !== undefined) {
                localVarQueryParameter['total_volume'] = totalVolume;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (shortVolumeRatioGte !== undefined) {
                localVarQueryParameter['short_volume_ratio.gte'] = shortVolumeRatioGte;
            }

            if (shortVolumeRatioGt !== undefined) {
                localVarQueryParameter['short_volume_ratio.gt'] = shortVolumeRatioGt;
            }

            if (shortVolumeRatioLte !== undefined) {
                localVarQueryParameter['short_volume_ratio.lte'] = shortVolumeRatioLte;
            }

            if (shortVolumeRatioLt !== undefined) {
                localVarQueryParameter['short_volume_ratio.lt'] = shortVolumeRatioLt;
            }

            if (totalVolumeGte !== undefined) {
                localVarQueryParameter['total_volume.gte'] = totalVolumeGte;
            }

            if (totalVolumeGt !== undefined) {
                localVarQueryParameter['total_volume.gt'] = totalVolumeGt;
            }

            if (totalVolumeLte !== undefined) {
                localVarQueryParameter['total_volume.lte'] = totalVolumeLte;
            }

            if (totalVolumeLt !== undefined) {
                localVarQueryParameter['total_volume.lt'] = totalVolumeLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a ticker symbol in a given time range.
         * @summary Trades
         * @param {string} stockTicker The ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {TradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {TradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trades: async (stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesOrderEnum, limit?: number, sort?: TradesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('trades', 'stockTicker', stockTicker)
            const localVarPath = `/v3/trades/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a crypto ticker symbol in a given time range.
         * @summary Trades
         * @param {string} cryptoTicker The ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {TradesCryptoOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {TradesCryptoSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradesCrypto: async (cryptoTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesCryptoOrderEnum, limit?: number, sort?: TradesCryptoSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('tradesCrypto', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v3/trades/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for an options ticker symbol in a given time range.
         * @summary Trades
         * @param {string} optionsTicker The options ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {TradesOptionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {TradesOptionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradesOptions: async (optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesOptionsOrderEnum, limit?: number, sort?: TradesOptionsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('tradesOptions', 'optionsTicker', optionsTicker)
            const localVarPath = `/v3/trades/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historic trade ticks for a cryptocurrency pair. 
         * @summary Historic Crypto Trades
         * @param {string} from The \&quot;from\&quot; symbol of the crypto pair.
         * @param {string} to The \&quot;to\&quot; symbol of the crypto pair.
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1HistoricCryptoFromToDateGet: async (from: string, to: string, date: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('v1HistoricCryptoFromToDateGet', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('v1HistoricCryptoFromToDateGet', 'to', to)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('v1HistoricCryptoFromToDateGet', 'date', date)
            const localVarPath = `/v1/historic/crypto/{from}/{to}/{date}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historic ticks for a forex currency pair. 
         * @summary Historic Forex Ticks
         * @param {string} from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
         * @param {string} to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1HistoricForexFromToDateGet: async (from: string, to: string, date: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('v1HistoricForexFromToDateGet', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('v1HistoricForexFromToDateGet', 'to', to)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('v1HistoricForexFromToDateGet', 'date', date)
            const localVarPath = `/v1/historic/forex/{from}/{to}/{date}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close prices of a cryptocurrency symbol on a certain day. 
         * @summary Daily Open/Close
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OpenCloseCryptoFromToDateGet: async (from: string, to: string, date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('v1OpenCloseCryptoFromToDateGet', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('v1OpenCloseCryptoFromToDateGet', 'to', to)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('v1OpenCloseCryptoFromToDateGet', 'date', date)
            const localVarPath = `/v1/open-close/crypto/{from}/{to}/{date}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close and afterhours values of a index symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OpenCloseIndicesTickerDateGet: async (indicesTicker: string, date: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('v1OpenCloseIndicesTickerDateGet', 'indicesTicker', indicesTicker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('v1OpenCloseIndicesTickerDateGet', 'date', date)
            const localVarPath = `/v1/open-close/{indicesTicker}/{date}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close and afterhours prices of an options contract on a certain date. 
         * @summary Daily Open/Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OpenCloseOptionsTickerDateGet: async (optionsTicker: string, date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('v1OpenCloseOptionsTickerDateGet', 'optionsTicker', optionsTicker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('v1OpenCloseOptionsTickerDateGet', 'date', date)
            const localVarPath = `/v1/open-close/{optionsTicker}/{date}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close and afterhours prices of a stock symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OpenCloseStocksTickerDateGet: async (stocksTicker: string, date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('v1OpenCloseStocksTickerDateGet', 'stocksTicker', stocksTicker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('v1OpenCloseStocksTickerDateGet', 'date', date)
            const localVarPath = `/v1/open-close/{stocksTicker}/{date}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsGroupedLocaleGlobalMarketCryptoDateGet: async (date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('v2AggsGroupedLocaleGlobalMarketCryptoDateGet', 'date', date)
            const localVarPath = `/v2/aggs/grouped/locale/global/market/crypto/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsGroupedLocaleGlobalMarketFxDateGet: async (date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('v2AggsGroupedLocaleGlobalMarketFxDateGet', 'date', date)
            const localVarPath = `/v2/aggs/grouped/locale/global/market/fx/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsGroupedLocaleUsMarketStocksDateGet: async (date: string, adjusted?: boolean, includeOtc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('v2AggsGroupedLocaleUsMarketStocksDateGet', 'date', date)
            const localVarPath = `/v2/aggs/grouped/locale/us/market/stocks/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (includeOtc !== undefined) {
                localVarQueryParameter['include_otc'] = includeOtc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
         * @summary Previous Close
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerCryptoTickerPrevGet: async (cryptoTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('v2AggsTickerCryptoTickerPrevGet', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v2/aggs/ticker/{cryptoTicker}/prev`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet: async (cryptoTicker: string, multiplier: number, timespan: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet', 'cryptoTicker', cryptoTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{cryptoTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
         * @summary Previous Close
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerForexTickerPrevGet: async (forexTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forexTicker' is not null or undefined
            assertParamExists('v2AggsTickerForexTickerPrevGet', 'forexTicker', forexTicker)
            const localVarPath = `/v2/aggs/ticker/{forexTicker}/prev`
                .replace(`{${"forexTicker"}}`, encodeURIComponent(String(forexTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet: async (forexTicker: string, multiplier: number, timespan: V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forexTicker' is not null or undefined
            assertParamExists('v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet', 'forexTicker', forexTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{forexTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"forexTicker"}}`, encodeURIComponent(String(forexTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
         * @summary Previous Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerIndicesTickerPrevGet: async (indicesTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('v2AggsTickerIndicesTickerPrevGet', 'indicesTicker', indicesTicker)
            const localVarPath = `/v2/aggs/ticker/{indicesTicker}/prev`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet: async (indicesTicker: string, multiplier: number, timespan: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, sort?: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet', 'indicesTicker', indicesTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{indicesTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
         * @summary Previous Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerOptionsTickerPrevGet: async (optionsTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('v2AggsTickerOptionsTickerPrevGet', 'optionsTicker', optionsTicker)
            const localVarPath = `/v2/aggs/ticker/{optionsTicker}/prev`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet: async (optionsTicker: string, multiplier: number, timespan: V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet', 'optionsTicker', optionsTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{optionsTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
         * @summary Previous Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerStocksTickerPrevGet: async (stocksTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('v2AggsTickerStocksTickerPrevGet', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/aggs/ticker/{stocksTicker}/prev`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet: async (stocksTicker: string, multiplier: number, timespan: V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet', 'stocksTicker', stocksTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {V2SnapshotLocaleGlobalMarketsCryptoDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsCryptoDirectionGet: async (direction: V2SnapshotLocaleGlobalMarketsCryptoDirectionGetDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('v2SnapshotLocaleGlobalMarketsCryptoDirectionGet', 'direction', direction)
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/{direction}`
                .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsCryptoTickersGet: async (tickers?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickers) {
                localVarQueryParameter['tickers'] = tickers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker Full Book (L2)
         * @param {string} ticker The cryptocurrency ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('v2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet', 'ticker', ticker)
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}/book`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker Ticker of the snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('v2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet', 'ticker', ticker)
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {V2SnapshotLocaleGlobalMarketsForexDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsForexDirectionGet: async (direction: V2SnapshotLocaleGlobalMarketsForexDirectionGetDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('v2SnapshotLocaleGlobalMarketsForexDirectionGet', 'direction', direction)
            const localVarPath = `/v2/snapshot/locale/global/markets/forex/{direction}`
                .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsForexTickersGet: async (tickers?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/snapshot/locale/global/markets/forex/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickers) {
                localVarQueryParameter['tickers'] = tickers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker The forex ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsForexTickersTickerGet: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('v2SnapshotLocaleGlobalMarketsForexTickersTickerGet', 'ticker', ticker)
            const localVarPath = `/v2/snapshot/locale/global/markets/forex/tickers/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {V2SnapshotLocaleUsMarketsStocksDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleUsMarketsStocksDirectionGet: async (direction: V2SnapshotLocaleUsMarketsStocksDirectionGetDirectionEnum, includeOtc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('v2SnapshotLocaleUsMarketsStocksDirectionGet', 'direction', direction)
            const localVarPath = `/v2/snapshot/locale/us/markets/stocks/{direction}`
                .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (includeOtc !== undefined) {
                localVarQueryParameter['include_otc'] = includeOtc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleUsMarketsStocksTickersGet: async (tickers?: Array<string>, includeOtc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/snapshot/locale/us/markets/stocks/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickers) {
                localVarQueryParameter['tickers'] = tickers;
            }

            if (includeOtc !== undefined) {
                localVarQueryParameter['include_otc'] = includeOtc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary Ticker
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet: async (stocksTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('v2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/snapshot/locale/us/markets/stocks/tickers/{stocksTicker}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get NBBO quotes for a given ticker symbol on a specified date. 
         * @summary Quotes (NBBO)
         * @param {string} ticker The ticker symbol we want quotes for.
         * @param {string} date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TicksStocksNbboTickerDateGet: async (ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('v2TicksStocksNbboTickerDateGet', 'ticker', ticker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('v2TicksStocksNbboTickerDateGet', 'date', date)
            const localVarPath = `/v2/ticks/stocks/nbbo/{ticker}/{date}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampLimit !== undefined) {
                localVarQueryParameter['timestampLimit'] = timestampLimit;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a given ticker symbol on a specified date. 
         * @summary Trades
         * @param {string} ticker The ticker symbol we want trades for.
         * @param {string} date The date/day of the trades to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TicksStocksTradesTickerDateGet: async (ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('v2TicksStocksTradesTickerDateGet', 'ticker', ticker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('v2TicksStocksTradesTickerDateGet', 'date', date)
            const localVarPath = `/v2/ticks/stocks/trades/{ticker}/{date}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampLimit !== undefined) {
                localVarQueryParameter['timestampLimit'] = timestampLimit;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve earnings_v1 data via API.
         * @summary earnings_v1 API
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
         * @param {string} [ticker] The stock symbol of the company reporting earnings.
         * @param {string} [dateGte] Range by date.
         * @param {string} [dateGt] Range by date.
         * @param {string} [dateLte] Range by date.
         * @param {string} [dateLt] Range by date.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {BenzingaEarningsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
         * @param {BenzingaEarningsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async benzingaEarnings(date?: string, ticker?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: BenzingaEarningsOrderEnum, limit?: number, sort?: BenzingaEarningsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BenzingaEarnings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.benzingaEarnings(date, ticker, dateGte, dateGt, dateLte, dateLt, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.benzingaEarnings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve news_v1 data via API.
         * @summary news_v1 API
         * @param {string} [created] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
         * @param {string} [tickers] A list of stock or crypto tickers mentioned in the article.
         * @param {string} [createdGte] Range by created.
         * @param {string} [createdGt] Range by created.
         * @param {string} [createdLte] Range by created.
         * @param {string} [createdLt] Range by created.
         * @param {string} [tickersGte] Range by tickers.
         * @param {string} [tickersGt] Range by tickers.
         * @param {string} [tickersLte] Range by tickers.
         * @param {string} [tickersLt] Range by tickers.
         * @param {BenzingaNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
         * @param {BenzingaNewsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async benzingaNews(created?: string, tickers?: string, createdGte?: string, createdGt?: string, createdLte?: string, createdLt?: string, tickersGte?: string, tickersGt?: string, tickersLte?: string, tickersLt?: string, order?: BenzingaNewsOrderEnum, limit?: number, sort?: BenzingaNewsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BenzingaNews200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.benzingaNews(created, tickers, createdGte, createdGt, createdLte, createdLt, tickersGte, tickersGt, tickersLte, tickersLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.benzingaNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve ratings_v1 data via API.
         * @summary ratings_v1 API
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrade, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
         * @param {string} [priceTargetAction] The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
         * @param {string} [rating] The current rating set by the analyst.
         * @param {string} [firm] The name of the research firm or investment bank issuing the rating.
         * @param {string} [dateGte] Range by date.
         * @param {string} [dateGt] Range by date.
         * @param {string} [dateLte] Range by date.
         * @param {string} [dateLt] Range by date.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [ratingActionGte] Range by rating_action.
         * @param {string} [ratingActionGt] Range by rating_action.
         * @param {string} [ratingActionLte] Range by rating_action.
         * @param {string} [ratingActionLt] Range by rating_action.
         * @param {string} [priceTargetActionGte] Range by price_target_action.
         * @param {string} [priceTargetActionGt] Range by price_target_action.
         * @param {string} [priceTargetActionLte] Range by price_target_action.
         * @param {string} [priceTargetActionLt] Range by price_target_action.
         * @param {string} [ratingGte] Range by rating.
         * @param {string} [ratingGt] Range by rating.
         * @param {string} [ratingLte] Range by rating.
         * @param {string} [ratingLt] Range by rating.
         * @param {string} [firmGte] Range by firm.
         * @param {string} [firmGt] Range by firm.
         * @param {string} [firmLte] Range by firm.
         * @param {string} [firmLt] Range by firm.
         * @param {BenzingaRatingsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
         * @param {BenzingaRatingsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async benzingaRatings(date?: string, ticker?: string, ratingAction?: string, priceTargetAction?: string, rating?: string, firm?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, ratingActionGte?: string, ratingActionGt?: string, ratingActionLte?: string, ratingActionLt?: string, priceTargetActionGte?: string, priceTargetActionGt?: string, priceTargetActionLte?: string, priceTargetActionLt?: string, ratingGte?: string, ratingGt?: string, ratingLte?: string, ratingLt?: string, firmGte?: string, firmGt?: string, firmLte?: string, firmLt?: string, order?: BenzingaRatingsOrderEnum, limit?: number, sort?: BenzingaRatingsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BenzingaRatings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.benzingaRatings(date, ticker, ratingAction, priceTargetAction, rating, firm, dateGte, dateGt, dateLte, dateLt, tickerGte, tickerGt, tickerLte, tickerLt, ratingActionGte, ratingActionGt, ratingActionLte, ratingActionLt, priceTargetActionGte, priceTargetActionGt, priceTargetActionLte, priceTargetActionLt, ratingGte, ratingGt, ratingLte, ratingLt, firmGte, firmGt, firmLte, firmLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.benzingaRatings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {CryptoEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cryptoEMA(cryptoTicker: string, timestamp?: string, timespan?: CryptoEMATimespanEnum, window?: number, seriesType?: CryptoEMASeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cryptoEMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cryptoEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} cryptoTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {CryptoMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate MACD data. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cryptoMACD(cryptoTicker: string, timestamp?: string, timespan?: CryptoMACDTimespanEnum, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: CryptoMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cryptoMACD(cryptoTicker, timestamp, timespan, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cryptoMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {CryptoRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cryptoRSI(cryptoTicker: string, timestamp?: string, timespan?: CryptoRSITimespanEnum, window?: number, seriesType?: CryptoRSISeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cryptoRSI(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cryptoRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {CryptoSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cryptoSMA(cryptoTicker: string, timestamp?: string, timespan?: CryptoSMATimespanEnum, window?: number, seriesType?: CryptoSMASeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cryptoSMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cryptoSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {EMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {EMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {EMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eMA(stockTicker: string, timestamp?: string, timespan?: EMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: EMASeriesTypeEnum, expandUnderlying?: boolean, order?: EMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.eMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {ForexEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forexEMA(fxTicker: string, timestamp?: string, timespan?: ForexEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexEMASeriesTypeEnum, expandUnderlying?: boolean, order?: ForexEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forexEMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forexEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} fxTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {ForexMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forexMACD(fxTicker: string, timestamp?: string, timespan?: ForexMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: ForexMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: ForexMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forexMACD(fxTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forexMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} fxTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {ForexRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forexRSI(fxTicker: string, timestamp?: string, timespan?: ForexRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexRSISeriesTypeEnum, expandUnderlying?: boolean, order?: ForexRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forexRSI(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forexRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} fxTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {ForexSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forexSMA(fxTicker: string, timestamp?: string, timespan?: ForexSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexSMASeriesTypeEnum, expandUnderlying?: boolean, order?: ForexSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forexSMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forexSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
         * @summary Ticker Events
         * @param {string} id Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the  [Ticker Details Endpoint](https://polygon.io/docs/stocks/get_v3_reference_tickers__ticker)
         * @param {string} [types] A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(id: string, types?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(id, types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get upcoming market holidays and their open/close times.
         * @summary Market Holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketHolidays(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarketHolidays200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketHolidays(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMarketHolidays']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current trading status of the exchanges and overall financial markets.
         * @summary Market Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarketStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMarketStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an options contract
         * @summary Options Contract
         * @param {string} optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://polygon.io/blog/how-to-read-a-stock-options-ticker/).
         * @param {string} [asOf] Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsContract(optionsTicker: string, asOf?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOptionsContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsContract(optionsTicker, asOf, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of tickers related to the queried ticker based on News and Returns data.
         * @summary Related Companies
         * @param {string} ticker The ticker symbol to search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelatedCompanies(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRelatedCompanies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelatedCompanies(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRelatedCompanies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
         * @summary Ticker Details v3
         * @param {string} ticker The ticker symbol of the asset.
         * @param {string} [date] Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicker(ticker: string, date?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicker200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicker(ticker, date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {IndicesEMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indicesEMA(indicesTicker: string, timestamp?: string, timespan?: IndicesEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesEMASeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indicesEMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.indicesEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} indicesTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {IndicesMACDSeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close values to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indicesMACD(indicesTicker: string, timestamp?: string, timespan?: IndicesMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: IndicesMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indicesMACD(indicesTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.indicesMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {IndicesRSISeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close values to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indicesRSI(indicesTicker: string, timestamp?: string, timespan?: IndicesRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesRSISeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indicesRSI(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.indicesRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {IndicesSMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indicesSMA(indicesTicker: string, timestamp?: string, timespan?: IndicesSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesSMASeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indicesSMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.indicesSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Snapshot of indices data for said tickers
         * @summary Indices Snapshot
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {IndicesSnapshotOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {IndicesSnapshotSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indicesSnapshot(tickerAnyOf?: string, ticker?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: IndicesSnapshotOrderEnum, limit?: number, sort?: IndicesSnapshotSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndicesSnapshot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indicesSnapshot(tickerAnyOf, ticker, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.indicesSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent NBBO (Quote) tick for a given stock.
         * @summary Last Quote
         * @param {string} stocksTicker The ticker symbol of the stock/equity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lastQuote(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastQuote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lastQuote(stocksTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.lastQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the last quote tick for a forex currency pair.
         * @summary Last Quote for a Currency Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lastQuoteCurrencies(from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastQuoteCurrencies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lastQuoteCurrencies(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.lastQuoteCurrencies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent trade for a given stock.
         * @summary Last Trade
         * @param {string} stocksTicker The ticker symbol of the stock/equity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lastTrade(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastTradeOptions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lastTrade(stocksTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.lastTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the last trade tick for a cryptocurrency pair.
         * @summary Last Trade for a Crypto Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lastTradeCrypto(from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastTradeCrypto200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lastTradeCrypto(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.lastTradeCrypto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent trade for a given options contract.
         * @summary Last Trade
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lastTradeOptions(optionsTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastTradeOptions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lastTradeOptions(optionsTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.lastTradeOptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all conditions that Polygon.io uses.
         * @summary Conditions
         * @param {ListConditionsAssetClassEnum} [assetClass] Filter for conditions within a given asset class.
         * @param {ListConditionsDataTypeEnum} [dataType] Filter by data type.
         * @param {number} [id] Filter for conditions with a given ID.
         * @param {ListConditionsSipEnum} [sip] Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
         * @param {ListConditionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListConditionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConditions(assetClass?: ListConditionsAssetClassEnum, dataType?: ListConditionsDataTypeEnum, id?: number, sip?: ListConditionsSipEnum, order?: ListConditionsOrderEnum, limit?: number, sort?: ListConditionsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConditions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConditions(assetClass, dataType, id, sip, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listConditions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
         * @summary Dividends v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [exDividendDate] Query by ex-dividend date with the format YYYY-MM-DD.
         * @param {string} [recordDate] Query by record date with the format YYYY-MM-DD.
         * @param {string} [declarationDate] Query by declaration date with the format YYYY-MM-DD.
         * @param {string} [payDate] Query by pay date with the format YYYY-MM-DD.
         * @param {ListDividendsFrequencyEnum} [frequency] Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
         * @param {number} [cashAmount] Query by the cash amount of the dividend.
         * @param {ListDividendsDividendTypeEnum} [dividendType] Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [exDividendDateGte] Range by ex_dividend_date.
         * @param {string} [exDividendDateGt] Range by ex_dividend_date.
         * @param {string} [exDividendDateLte] Range by ex_dividend_date.
         * @param {string} [exDividendDateLt] Range by ex_dividend_date.
         * @param {string} [recordDateGte] Range by record_date.
         * @param {string} [recordDateGt] Range by record_date.
         * @param {string} [recordDateLte] Range by record_date.
         * @param {string} [recordDateLt] Range by record_date.
         * @param {string} [declarationDateGte] Range by declaration_date.
         * @param {string} [declarationDateGt] Range by declaration_date.
         * @param {string} [declarationDateLte] Range by declaration_date.
         * @param {string} [declarationDateLt] Range by declaration_date.
         * @param {string} [payDateGte] Range by pay_date.
         * @param {string} [payDateGt] Range by pay_date.
         * @param {string} [payDateLte] Range by pay_date.
         * @param {string} [payDateLt] Range by pay_date.
         * @param {number} [cashAmountGte] Range by cash_amount.
         * @param {number} [cashAmountGt] Range by cash_amount.
         * @param {number} [cashAmountLte] Range by cash_amount.
         * @param {number} [cashAmountLt] Range by cash_amount.
         * @param {ListDividendsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListDividendsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDividends(ticker?: string, exDividendDate?: string, recordDate?: string, declarationDate?: string, payDate?: string, frequency?: ListDividendsFrequencyEnum, cashAmount?: number, dividendType?: ListDividendsDividendTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, exDividendDateGte?: string, exDividendDateGt?: string, exDividendDateLte?: string, exDividendDateLt?: string, recordDateGte?: string, recordDateGt?: string, recordDateLte?: string, recordDateLt?: string, declarationDateGte?: string, declarationDateGt?: string, declarationDateLte?: string, declarationDateLt?: string, payDateGte?: string, payDateGt?: string, payDateLte?: string, payDateLt?: string, cashAmountGte?: number, cashAmountGt?: number, cashAmountLte?: number, cashAmountLt?: number, order?: ListDividendsOrderEnum, limit?: number, sort?: ListDividendsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDividends200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDividends(ticker, exDividendDate, recordDate, declarationDate, payDate, frequency, cashAmount, dividendType, tickerGte, tickerGt, tickerLte, tickerLt, exDividendDateGte, exDividendDateGt, exDividendDateLte, exDividendDateLt, recordDateGte, recordDateGt, recordDateLte, recordDateLt, declarationDateGte, declarationDateGt, declarationDateLte, declarationDateLt, payDateGte, payDateGt, payDateLte, payDateLt, cashAmountGte, cashAmountGt, cashAmountLte, cashAmountLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listDividends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all exchanges that Polygon.io knows about.
         * @summary Exchanges
         * @param {ListExchangesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListExchangesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExchanges(assetClass?: ListExchangesAssetClassEnum, locale?: ListExchangesLocaleEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExchanges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExchanges(assetClass, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listExchanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
         * @summary Stock Financials vX
         * @param {string} [ticker] Query by company ticker.
         * @param {string} [cik] Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number
         * @param {string} [companyName] Query by company name.
         * @param {string} [sic] Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;)
         * @param {string} [filingDate] Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01
         * @param {string} [periodOfReportDate] The period of report for the filing with financials data in YYYY-MM-DD format.
         * @param {ListFinancialsTimeframeEnum} [timeframe] Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
         * @param {boolean} [includeSources] Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default.
         * @param {string} [companyNameSearch] Search by company_name.
         * @param {string} [filingDateGte] Search by filing_date.
         * @param {string} [filingDateGt] Search by filing_date.
         * @param {string} [filingDateLte] Search by filing_date.
         * @param {string} [filingDateLt] Search by filing_date.
         * @param {string} [periodOfReportDateGte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateGt] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLt] Search by period_of_report_date.
         * @param {ListFinancialsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 100.
         * @param {ListFinancialsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFinancials(ticker?: string, cik?: string, companyName?: string, sic?: string, filingDate?: string, periodOfReportDate?: string, timeframe?: ListFinancialsTimeframeEnum, includeSources?: boolean, companyNameSearch?: string, filingDateGte?: string, filingDateGt?: string, filingDateLte?: string, filingDateLt?: string, periodOfReportDateGte?: string, periodOfReportDateGt?: string, periodOfReportDateLte?: string, periodOfReportDateLt?: string, order?: ListFinancialsOrderEnum, limit?: number, sort?: ListFinancialsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFinancials200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFinancials(ticker, cik, companyName, sic, filingDate, periodOfReportDate, timeframe, includeSources, companyNameSearch, filingDateGte, filingDateGt, filingDateLte, filingDateLt, periodOfReportDateGte, periodOfReportDateGt, periodOfReportDateLte, periodOfReportDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listFinancials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
         * @summary IPOs
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [usCode] Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
         * @param {string} [isin] Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
         * @param {string} [listingDate] Specify a listing date. This is the first trading date for the newly listed entity.
         * @param {ListIPOsIpoStatusEnum} [ipoStatus] Specify an IPO status.
         * @param {string} [listingDateGte] Range by listing_date.
         * @param {string} [listingDateGt] Range by listing_date.
         * @param {string} [listingDateLte] Range by listing_date.
         * @param {string} [listingDateLt] Range by listing_date.
         * @param {ListIPOsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListIPOsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIPOs(ticker?: string, usCode?: string, isin?: string, listingDate?: string, ipoStatus?: ListIPOsIpoStatusEnum, listingDateGte?: string, listingDateGt?: string, listingDateLte?: string, listingDateLt?: string, order?: ListIPOsOrderEnum, limit?: number, sort?: ListIPOsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListIPOs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIPOs(ticker, usCode, isin, listingDate, ipoStatus, listingDateGte, listingDateGt, listingDateLte, listingDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listIPOs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
         * @summary Ticker News
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtc] Return results published on, before, or after this date.
         * @param {string} [tickerGte] Search by ticker.
         * @param {string} [tickerGt] Search by ticker.
         * @param {string} [tickerLte] Search by ticker.
         * @param {string} [tickerLt] Search by ticker.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGt] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLt] Search by published_utc.
         * @param {ListNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListNewsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNews(ticker?: string, publishedUtc?: ListNewsPublishedUtcParameter, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, publishedUtcGte?: ListNewsPublishedUtcParameter, publishedUtcGt?: ListNewsPublishedUtcParameter, publishedUtcLte?: ListNewsPublishedUtcParameter, publishedUtcLt?: ListNewsPublishedUtcParameter, order?: ListNewsOrderEnum, limit?: number, sort?: ListNewsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListNews200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNews(ticker, publishedUtc, tickerGte, tickerGt, tickerLte, tickerLt, publishedUtcGte, publishedUtcGt, publishedUtcLte, publishedUtcLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query for historical options contracts. This provides both active and expired options contracts.
         * @summary Options Contracts
         * @param {string} [ticker] This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://polygon.io/docs/options/get_v3_reference_options_contracts__options_ticker).
         * @param {string} [underlyingTicker] Query for contracts relating to an underlying stock ticker.
         * @param {ListOptionsContractsContractTypeEnum} [contractType] Query by the type of contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {string} [asOf] Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {boolean} [expired] Query for expired contracts. Default is false.
         * @param {string} [underlyingTickerGte] Range by underlying_ticker.
         * @param {string} [underlyingTickerGt] Range by underlying_ticker.
         * @param {string} [underlyingTickerLte] Range by underlying_ticker.
         * @param {string} [underlyingTickerLt] Range by underlying_ticker.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {ListOptionsContractsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListOptionsContractsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOptionsContracts(ticker?: string, underlyingTicker?: string, contractType?: ListOptionsContractsContractTypeEnum, expirationDate?: string, asOf?: string, strikePrice?: number, expired?: boolean, underlyingTickerGte?: string, underlyingTickerGt?: string, underlyingTickerLte?: string, underlyingTickerLt?: string, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, order?: ListOptionsContractsOrderEnum, limit?: number, sort?: ListOptionsContractsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOptionsContracts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOptionsContracts(ticker, underlyingTicker, contractType, expirationDate, asOf, strikePrice, expired, underlyingTickerGte, underlyingTickerGt, underlyingTickerLte, underlyingTickerLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listOptionsContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
         * @summary Stock Splits v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [executionDate] Query by execution date with the format YYYY-MM-DD.
         * @param {boolean | null} [reverseSplit] Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [executionDateGte] Range by execution_date.
         * @param {string} [executionDateGt] Range by execution_date.
         * @param {string} [executionDateLte] Range by execution_date.
         * @param {string} [executionDateLt] Range by execution_date.
         * @param {ListStockSplitsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListStockSplitsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStockSplits(ticker?: string, executionDate?: string, reverseSplit?: boolean | null, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, executionDateGte?: string, executionDateGt?: string, executionDateLte?: string, executionDateLt?: string, order?: ListStockSplitsOrderEnum, limit?: number, sort?: ListStockSplitsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListStockSplits200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStockSplits(ticker, executionDate, reverseSplit, tickerGte, tickerGt, tickerLte, tickerLt, executionDateGte, executionDateGt, executionDateLte, executionDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listStockSplits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all ticker types that Polygon.io has.
         * @summary Ticker Types
         * @param {ListTickerTypesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListTickerTypesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTickerTypes(assetClass?: ListTickerTypesAssetClassEnum, locale?: ListTickerTypesLocaleEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTickerTypes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTickerTypes(assetClass, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listTickerTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
         * @summary Tickers
         * @param {string} [ticker] Specify a ticker symbol. Defaults to empty string which queries all tickers.
         * @param {ListTickersTypeEnum} [type] Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types). Defaults to empty string which queries all types.
         * @param {ListTickersMarketEnum} [market] Filter by market type. By default all markets are included.
         * @param {string} [exchange] Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes [at the ISO org website](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges.
         * @param {string} [cusip] Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
         * @param {string} [cik] Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs.
         * @param {string} [date] Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.
         * @param {string} [search] Search for terms within the ticker and/or company name.
         * @param {boolean} [active] Specify if the tickers returned should be actively traded on the queried date. Default is true.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {ListTickersOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 1000.
         * @param {ListTickersSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTickers(ticker?: string, type?: ListTickersTypeEnum, market?: ListTickersMarketEnum, exchange?: string, cusip?: string, cik?: string, date?: string, search?: string, active?: boolean, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: ListTickersOrderEnum, limit?: number, sort?: ListTickersSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTickers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTickers(ticker, type, market, exchange, cusip, cik, date, search, active, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listTickers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {MACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {MACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {MACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mACD(stockTicker: string, timestamp?: string, timespan?: MACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: MACDSeriesTypeEnum, expandUnderlying?: boolean, order?: MACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mACD(stockTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.mACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the snapshot of an option contract for a stock equity.
         * @summary Option Contract
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {string} optionContract The option contract identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionContract(underlyingAsset: string, optionContract: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionContract(underlyingAsset, optionContract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.optionContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the snapshot of all options contracts for an underlying ticker.
         * @summary Options Chain
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {OptionsChainContractTypeEnum} [contractType] Query by the type of contract.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {OptionsChainOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {OptionsChainSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsChain(underlyingAsset: string, strikePrice?: number, expirationDate?: string, contractType?: OptionsChainContractTypeEnum, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, order?: OptionsChainOrderEnum, limit?: number, sort?: OptionsChainSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionsChain200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsChain(underlyingAsset, strikePrice, expirationDate, contractType, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.optionsChain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {OptionsEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsEMA(optionsTicker: string, timestamp?: string, timespan?: OptionsEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsEMASeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsEMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.optionsEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} optionsTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {OptionsMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsMACD(optionsTicker: string, timestamp?: string, timespan?: OptionsMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: OptionsMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsMACD(optionsTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.optionsMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {OptionsRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsRSI(optionsTicker: string, timestamp?: string, timespan?: OptionsRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsRSISeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsRSI(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.optionsRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {OptionsSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsSMA(optionsTicker: string, timestamp?: string, timespan?: OptionsSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsSMASeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optionsSMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.optionsSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get NBBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (NBBO)
         * @param {string} stockTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {QuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {QuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotes(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesOrderEnum, limit?: number, sort?: QuotesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotes(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.quotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get BBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (BBO)
         * @param {string} fxTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {QuotesFxOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {QuotesFxSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotesFx(fxTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesFxOrderEnum, limit?: number, sort?: QuotesFxSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuotesFx200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotesFx(fxTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.quotesFx']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get quotes for an options ticker symbol in a given time range.
         * @summary Quotes
         * @param {string} optionsTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {QuotesOptionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {QuotesOptionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotesOptions(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesOptionsOrderEnum, limit?: number, sort?: QuotesOptionsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuotesOptions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotesOptions(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.quotesOptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {RSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {RSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {RSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rSI(stockTicker: string, timestamp?: string, timespan?: RSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: RSISeriesTypeEnum, expandUnderlying?: boolean, order?: RSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rSI(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
         * @summary Real-time Currency Conversion
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {number} [amount] The amount to convert, with a decimal.
         * @param {RealTimeCurrencyConversionPrecisionEnum} [precision] The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async realTimeCurrencyConversion(from: string, to: string, amount?: number, precision?: RealTimeCurrencyConversionPrecisionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealTimeCurrencyConversion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.realTimeCurrencyConversion(from, to, amount, precision, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.realTimeCurrencyConversion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {SMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {SMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {SMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sMA(stockTicker: string, timestamp?: string, timespan?: SMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: SMASeriesTypeEnum, expandUnderlying?: boolean, order?: SMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
         * @summary Summaries
         * @param {string} [tickerAnyOf] Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://polygon.io/docs/stocks/get_v3_reference_tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshotSummary(tickerAnyOf?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnapshotSummary200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snapshotSummary(tickerAnyOf, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.snapshotSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get snapshots for assets of all types
         * @summary Universal Snapshot
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {SnapshotsTypeEnum} [type] Query by the type of asset.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. 
         * @param {SnapshotsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {SnapshotsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshots(ticker?: string, type?: SnapshotsTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, tickerAnyOf?: string, order?: SnapshotsOrderEnum, limit?: number, sort?: SnapshotsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Snapshots200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snapshots(ticker, type, tickerGte, tickerGt, tickerLte, tickerLt, tickerAnyOf, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.snapshots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve finra_short_interest_v1 data via API.
         * @summary finra_short_interest_v1 API
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [daysToCover] Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume.
         * @param {string} [settlementDate] The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
         * @param {string} [avgDailyVolume] The average daily trading volume for the stock over a specified period, typically used to contextualize short interest.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [daysToCoverGte] Range by days_to_cover.
         * @param {string} [daysToCoverGt] Range by days_to_cover.
         * @param {string} [daysToCoverLte] Range by days_to_cover.
         * @param {string} [daysToCoverLt] Range by days_to_cover.
         * @param {string} [settlementDateGte] Range by settlement_date.
         * @param {string} [settlementDateGt] Range by settlement_date.
         * @param {string} [settlementDateLte] Range by settlement_date.
         * @param {string} [settlementDateLt] Range by settlement_date.
         * @param {string} [avgDailyVolumeGte] Range by avg_daily_volume.
         * @param {string} [avgDailyVolumeGt] Range by avg_daily_volume.
         * @param {string} [avgDailyVolumeLte] Range by avg_daily_volume.
         * @param {string} [avgDailyVolumeLt] Range by avg_daily_volume.
         * @param {StocksShortInterestOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 50000.
         * @param {StocksShortInterestSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stocksShortInterest(ticker?: string, daysToCover?: string, settlementDate?: string, avgDailyVolume?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, daysToCoverGte?: string, daysToCoverGt?: string, daysToCoverLte?: string, daysToCoverLt?: string, settlementDateGte?: string, settlementDateGt?: string, settlementDateLte?: string, settlementDateLt?: string, avgDailyVolumeGte?: string, avgDailyVolumeGt?: string, avgDailyVolumeLte?: string, avgDailyVolumeLt?: string, order?: StocksShortInterestOrderEnum, limit?: number, sort?: StocksShortInterestSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StocksShortInterest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stocksShortInterest(ticker, daysToCover, settlementDate, avgDailyVolume, tickerGte, tickerGt, tickerLte, tickerLt, daysToCoverGte, daysToCoverGt, daysToCoverLte, daysToCoverLt, settlementDateGte, settlementDateGt, settlementDateLte, settlementDateLt, avgDailyVolumeGte, avgDailyVolumeGt, avgDailyVolumeLte, avgDailyVolumeLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.stocksShortInterest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve finra_short_volume_v1 data via API.
         * @summary finra_short_volume_v1 API
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [date] The date of trade activity reported in the format YYYY-MM-DD
         * @param {string} [shortVolumeRatio] The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100.
         * @param {string} [totalVolume] Total reported volume across all venues for the ticker on the given date.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [dateGte] Range by date.
         * @param {string} [dateGt] Range by date.
         * @param {string} [dateLte] Range by date.
         * @param {string} [dateLt] Range by date.
         * @param {string} [shortVolumeRatioGte] Range by short_volume_ratio.
         * @param {string} [shortVolumeRatioGt] Range by short_volume_ratio.
         * @param {string} [shortVolumeRatioLte] Range by short_volume_ratio.
         * @param {string} [shortVolumeRatioLt] Range by short_volume_ratio.
         * @param {string} [totalVolumeGte] Range by total_volume.
         * @param {string} [totalVolumeGt] Range by total_volume.
         * @param {string} [totalVolumeLte] Range by total_volume.
         * @param {string} [totalVolumeLt] Range by total_volume.
         * @param {StocksShortVolumeOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 50000.
         * @param {StocksShortVolumeSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stocksShortVolume(ticker?: string, date?: string, shortVolumeRatio?: string, totalVolume?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, shortVolumeRatioGte?: string, shortVolumeRatioGt?: string, shortVolumeRatioLte?: string, shortVolumeRatioLt?: string, totalVolumeGte?: string, totalVolumeGt?: string, totalVolumeLte?: string, totalVolumeLt?: string, order?: StocksShortVolumeOrderEnum, limit?: number, sort?: StocksShortVolumeSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StocksShortVolume200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stocksShortVolume(ticker, date, shortVolumeRatio, totalVolume, tickerGte, tickerGt, tickerLte, tickerLt, dateGte, dateGt, dateLte, dateLt, shortVolumeRatioGte, shortVolumeRatioGt, shortVolumeRatioLte, shortVolumeRatioLt, totalVolumeGte, totalVolumeGt, totalVolumeLte, totalVolumeLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.stocksShortVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a ticker symbol in a given time range.
         * @summary Trades
         * @param {string} stockTicker The ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {TradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {TradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trades(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesOrderEnum, limit?: number, sort?: TradesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trades(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.trades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a crypto ticker symbol in a given time range.
         * @summary Trades
         * @param {string} cryptoTicker The ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {TradesCryptoOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {TradesCryptoSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradesCrypto(cryptoTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesCryptoOrderEnum, limit?: number, sort?: TradesCryptoSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradesCrypto200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradesCrypto(cryptoTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.tradesCrypto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for an options ticker symbol in a given time range.
         * @summary Trades
         * @param {string} optionsTicker The options ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {TradesOptionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {TradesOptionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradesOptions(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesOptionsOrderEnum, limit?: number, sort?: TradesOptionsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradesOptions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradesOptions(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.tradesOptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get historic trade ticks for a cryptocurrency pair. 
         * @summary Historic Crypto Trades
         * @param {string} from The \&quot;from\&quot; symbol of the crypto pair.
         * @param {string} to The \&quot;to\&quot; symbol of the crypto pair.
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1HistoricCryptoFromToDateGet(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1HistoricCryptoFromToDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1HistoricCryptoFromToDateGet(from, to, date, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v1HistoricCryptoFromToDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get historic ticks for a forex currency pair. 
         * @summary Historic Forex Ticks
         * @param {string} from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
         * @param {string} to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1HistoricForexFromToDateGet(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1HistoricForexFromToDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1HistoricForexFromToDateGet(from, to, date, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v1HistoricForexFromToDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close prices of a cryptocurrency symbol on a certain day. 
         * @summary Daily Open/Close
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OpenCloseCryptoFromToDateGet(from: string, to: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OpenCloseCryptoFromToDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OpenCloseCryptoFromToDateGet(from, to, date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v1OpenCloseCryptoFromToDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close and afterhours values of a index symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OpenCloseIndicesTickerDateGet(indicesTicker: string, date: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OpenCloseIndicesTickerDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OpenCloseIndicesTickerDateGet(indicesTicker, date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v1OpenCloseIndicesTickerDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close and afterhours prices of an options contract on a certain date. 
         * @summary Daily Open/Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OpenCloseOptionsTickerDateGet(optionsTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OpenCloseOptionsTickerDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OpenCloseOptionsTickerDateGet(optionsTicker, date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v1OpenCloseOptionsTickerDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close and afterhours prices of a stock symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OpenCloseStocksTickerDateGet(stocksTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OpenCloseOptionsTickerDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OpenCloseStocksTickerDateGet(stocksTicker, date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v1OpenCloseStocksTickerDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsGroupedLocaleGlobalMarketCryptoDateGet(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsGroupedLocaleGlobalMarketCryptoDateGet(date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsGroupedLocaleGlobalMarketCryptoDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsGroupedLocaleGlobalMarketFxDateGet(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsGroupedLocaleGlobalMarketFxDateGet(date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsGroupedLocaleGlobalMarketFxDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsGroupedLocaleUsMarketStocksDateGet(date: string, adjusted?: boolean, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsGroupedLocaleUsMarketStocksDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsGroupedLocaleUsMarketStocksDateGet(date, adjusted, includeOtc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsGroupedLocaleUsMarketStocksDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
         * @summary Previous Close
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsTickerCryptoTickerPrevGet(cryptoTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsTickerCryptoTickerPrevGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsTickerCryptoTickerPrevGet(cryptoTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsTickerCryptoTickerPrevGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet(cryptoTicker: string, multiplier: number, timespan: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet(cryptoTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
         * @summary Previous Close
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsTickerForexTickerPrevGet(forexTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsTickerForexTickerPrevGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsTickerForexTickerPrevGet(forexTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsTickerForexTickerPrevGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet(forexTicker: string, multiplier: number, timespan: V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet(forexTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
         * @summary Previous Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsTickerIndicesTickerPrevGet(indicesTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsTickerIndicesTickerPrevGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsTickerIndicesTickerPrevGet(indicesTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsTickerIndicesTickerPrevGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet(indicesTicker: string, multiplier: number, timespan: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, sort?: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsTickerIndicesTickerPrevGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet(indicesTicker, multiplier, timespan, from, to, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
         * @summary Previous Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsTickerOptionsTickerPrevGet(optionsTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsTickerOptionsTickerPrevGet(optionsTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsTickerOptionsTickerPrevGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet(optionsTicker: string, multiplier: number, timespan: V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet(optionsTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
         * @summary Previous Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsTickerStocksTickerPrevGet(stocksTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsTickerStocksTickerPrevGet(stocksTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsTickerStocksTickerPrevGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet(stocksTicker: string, multiplier: number, timespan: V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet(stocksTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {V2SnapshotLocaleGlobalMarketsCryptoDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SnapshotLocaleGlobalMarketsCryptoDirectionGet(direction: V2SnapshotLocaleGlobalMarketsCryptoDirectionGetDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2SnapshotLocaleGlobalMarketsCryptoDirectionGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SnapshotLocaleGlobalMarketsCryptoDirectionGet(direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2SnapshotLocaleGlobalMarketsCryptoDirectionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SnapshotLocaleGlobalMarketsCryptoTickersGet(tickers?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2SnapshotLocaleGlobalMarketsCryptoTickersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SnapshotLocaleGlobalMarketsCryptoTickersGet(tickers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2SnapshotLocaleGlobalMarketsCryptoTickersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker Full Book (L2)
         * @param {string} ticker The cryptocurrency ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker Ticker of the snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {V2SnapshotLocaleGlobalMarketsForexDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SnapshotLocaleGlobalMarketsForexDirectionGet(direction: V2SnapshotLocaleGlobalMarketsForexDirectionGetDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2SnapshotLocaleGlobalMarketsForexTickersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SnapshotLocaleGlobalMarketsForexDirectionGet(direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2SnapshotLocaleGlobalMarketsForexDirectionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SnapshotLocaleGlobalMarketsForexTickersGet(tickers?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2SnapshotLocaleGlobalMarketsForexTickersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SnapshotLocaleGlobalMarketsForexTickersGet(tickers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2SnapshotLocaleGlobalMarketsForexTickersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker The forex ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SnapshotLocaleGlobalMarketsForexTickersTickerGet(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SnapshotLocaleGlobalMarketsForexTickersTickerGet(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2SnapshotLocaleGlobalMarketsForexTickersTickerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {V2SnapshotLocaleUsMarketsStocksDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SnapshotLocaleUsMarketsStocksDirectionGet(direction: V2SnapshotLocaleUsMarketsStocksDirectionGetDirectionEnum, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2SnapshotLocaleUsMarketsStocksDirectionGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SnapshotLocaleUsMarketsStocksDirectionGet(direction, includeOtc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2SnapshotLocaleUsMarketsStocksDirectionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SnapshotLocaleUsMarketsStocksTickersGet(tickers?: Array<string>, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2SnapshotLocaleUsMarketsStocksTickersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SnapshotLocaleUsMarketsStocksTickersGet(tickers, includeOtc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2SnapshotLocaleUsMarketsStocksTickersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary Ticker
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet(stocksTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get NBBO quotes for a given ticker symbol on a specified date. 
         * @summary Quotes (NBBO)
         * @param {string} ticker The ticker symbol we want quotes for.
         * @param {string} date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TicksStocksNbboTickerDateGet(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2TicksStocksNbboTickerDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TicksStocksNbboTickerDateGet(ticker, date, timestamp, timestampLimit, reverse, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2TicksStocksNbboTickerDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a given ticker symbol on a specified date. 
         * @summary Trades
         * @param {string} ticker The ticker symbol we want trades for.
         * @param {string} date The date/day of the trades to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2TicksStocksTradesTickerDateGet(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2TicksStocksTradesTickerDateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2TicksStocksTradesTickerDateGet(ticker, date, timestamp, timestampLimit, reverse, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v2TicksStocksTradesTickerDateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Retrieve earnings_v1 data via API.
         * @summary earnings_v1 API
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
         * @param {string} [ticker] The stock symbol of the company reporting earnings.
         * @param {string} [dateGte] Range by date.
         * @param {string} [dateGt] Range by date.
         * @param {string} [dateLte] Range by date.
         * @param {string} [dateLt] Range by date.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {BenzingaEarningsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
         * @param {BenzingaEarningsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        benzingaEarnings(date?: string, ticker?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: BenzingaEarningsOrderEnum, limit?: number, sort?: BenzingaEarningsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<BenzingaEarnings200Response> {
            return localVarFp.benzingaEarnings(date, ticker, dateGte, dateGt, dateLte, dateLt, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve news_v1 data via API.
         * @summary news_v1 API
         * @param {string} [created] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
         * @param {string} [tickers] A list of stock or crypto tickers mentioned in the article.
         * @param {string} [createdGte] Range by created.
         * @param {string} [createdGt] Range by created.
         * @param {string} [createdLte] Range by created.
         * @param {string} [createdLt] Range by created.
         * @param {string} [tickersGte] Range by tickers.
         * @param {string} [tickersGt] Range by tickers.
         * @param {string} [tickersLte] Range by tickers.
         * @param {string} [tickersLt] Range by tickers.
         * @param {BenzingaNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
         * @param {BenzingaNewsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        benzingaNews(created?: string, tickers?: string, createdGte?: string, createdGt?: string, createdLte?: string, createdLt?: string, tickersGte?: string, tickersGt?: string, tickersLte?: string, tickersLt?: string, order?: BenzingaNewsOrderEnum, limit?: number, sort?: BenzingaNewsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<BenzingaNews200Response> {
            return localVarFp.benzingaNews(created, tickers, createdGte, createdGt, createdLte, createdLt, tickersGte, tickersGt, tickersLte, tickersLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve ratings_v1 data via API.
         * @summary ratings_v1 API
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrade, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
         * @param {string} [priceTargetAction] The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
         * @param {string} [rating] The current rating set by the analyst.
         * @param {string} [firm] The name of the research firm or investment bank issuing the rating.
         * @param {string} [dateGte] Range by date.
         * @param {string} [dateGt] Range by date.
         * @param {string} [dateLte] Range by date.
         * @param {string} [dateLt] Range by date.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [ratingActionGte] Range by rating_action.
         * @param {string} [ratingActionGt] Range by rating_action.
         * @param {string} [ratingActionLte] Range by rating_action.
         * @param {string} [ratingActionLt] Range by rating_action.
         * @param {string} [priceTargetActionGte] Range by price_target_action.
         * @param {string} [priceTargetActionGt] Range by price_target_action.
         * @param {string} [priceTargetActionLte] Range by price_target_action.
         * @param {string} [priceTargetActionLt] Range by price_target_action.
         * @param {string} [ratingGte] Range by rating.
         * @param {string} [ratingGt] Range by rating.
         * @param {string} [ratingLte] Range by rating.
         * @param {string} [ratingLt] Range by rating.
         * @param {string} [firmGte] Range by firm.
         * @param {string} [firmGt] Range by firm.
         * @param {string} [firmLte] Range by firm.
         * @param {string} [firmLt] Range by firm.
         * @param {BenzingaRatingsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
         * @param {BenzingaRatingsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        benzingaRatings(date?: string, ticker?: string, ratingAction?: string, priceTargetAction?: string, rating?: string, firm?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, ratingActionGte?: string, ratingActionGt?: string, ratingActionLte?: string, ratingActionLt?: string, priceTargetActionGte?: string, priceTargetActionGt?: string, priceTargetActionLte?: string, priceTargetActionLt?: string, ratingGte?: string, ratingGt?: string, ratingLte?: string, ratingLt?: string, firmGte?: string, firmGt?: string, firmLte?: string, firmLt?: string, order?: BenzingaRatingsOrderEnum, limit?: number, sort?: BenzingaRatingsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<BenzingaRatings200Response> {
            return localVarFp.benzingaRatings(date, ticker, ratingAction, priceTargetAction, rating, firm, dateGte, dateGt, dateLte, dateLt, tickerGte, tickerGt, tickerLte, tickerLt, ratingActionGte, ratingActionGt, ratingActionLte, ratingActionLt, priceTargetActionGte, priceTargetActionGt, priceTargetActionLte, priceTargetActionLt, ratingGte, ratingGt, ratingLte, ratingLt, firmGte, firmGt, firmLte, firmLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {CryptoEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cryptoEMA(cryptoTicker: string, timestamp?: string, timespan?: CryptoEMATimespanEnum, window?: number, seriesType?: CryptoEMASeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoEMA200Response> {
            return localVarFp.cryptoEMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} cryptoTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {CryptoMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate MACD data. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cryptoMACD(cryptoTicker: string, timestamp?: string, timespan?: CryptoMACDTimespanEnum, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: CryptoMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoMACD200Response> {
            return localVarFp.cryptoMACD(cryptoTicker, timestamp, timespan, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {CryptoRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cryptoRSI(cryptoTicker: string, timestamp?: string, timespan?: CryptoRSITimespanEnum, window?: number, seriesType?: CryptoRSISeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoRSI200Response> {
            return localVarFp.cryptoRSI(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {CryptoSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {CryptoSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {CryptoSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cryptoSMA(cryptoTicker: string, timestamp?: string, timespan?: CryptoSMATimespanEnum, window?: number, seriesType?: CryptoSMASeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoSMA200Response> {
            return localVarFp.cryptoSMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {EMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {EMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {EMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eMA(stockTicker: string, timestamp?: string, timespan?: EMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: EMASeriesTypeEnum, expandUnderlying?: boolean, order?: EMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoEMA200Response> {
            return localVarFp.eMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {ForexEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forexEMA(fxTicker: string, timestamp?: string, timespan?: ForexEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexEMASeriesTypeEnum, expandUnderlying?: boolean, order?: ForexEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoEMA200Response> {
            return localVarFp.forexEMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} fxTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {ForexMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forexMACD(fxTicker: string, timestamp?: string, timespan?: ForexMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: ForexMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: ForexMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoMACD200Response> {
            return localVarFp.forexMACD(fxTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} fxTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {ForexRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forexRSI(fxTicker: string, timestamp?: string, timespan?: ForexRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexRSISeriesTypeEnum, expandUnderlying?: boolean, order?: ForexRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoRSI200Response> {
            return localVarFp.forexRSI(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} fxTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {ForexSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {ForexSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {ForexSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forexSMA(fxTicker: string, timestamp?: string, timespan?: ForexSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexSMASeriesTypeEnum, expandUnderlying?: boolean, order?: ForexSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoSMA200Response> {
            return localVarFp.forexSMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
         * @summary Ticker Events
         * @param {string} id Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the  [Ticker Details Endpoint](https://polygon.io/docs/stocks/get_v3_reference_tickers__ticker)
         * @param {string} [types] A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(id: string, types?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetEvents200Response> {
            return localVarFp.getEvents(id, types, options).then((request) => request(axios, basePath));
        },
        /**
         * Get upcoming market holidays and their open/close times.
         * @summary Market Holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketHolidays(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarketHolidays200ResponseInner>> {
            return localVarFp.getMarketHolidays(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current trading status of the exchanges and overall financial markets.
         * @summary Market Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketStatus(options?: RawAxiosRequestConfig): AxiosPromise<GetMarketStatus200Response> {
            return localVarFp.getMarketStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an options contract
         * @summary Options Contract
         * @param {string} optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://polygon.io/blog/how-to-read-a-stock-options-ticker/).
         * @param {string} [asOf] Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsContract(optionsTicker: string, asOf?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetOptionsContract200Response> {
            return localVarFp.getOptionsContract(optionsTicker, asOf, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of tickers related to the queried ticker based on News and Returns data.
         * @summary Related Companies
         * @param {string} ticker The ticker symbol to search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedCompanies(ticker: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRelatedCompanies200Response> {
            return localVarFp.getRelatedCompanies(ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
         * @summary Ticker Details v3
         * @param {string} ticker The ticker symbol of the asset.
         * @param {string} [date] Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker(ticker: string, date?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetTicker200Response> {
            return localVarFp.getTicker(ticker, date, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {IndicesEMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indicesEMA(indicesTicker: string, timestamp?: string, timespan?: IndicesEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesEMASeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoEMA200Response> {
            return localVarFp.indicesEMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} indicesTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {IndicesMACDSeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close values to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indicesMACD(indicesTicker: string, timestamp?: string, timespan?: IndicesMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: IndicesMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoMACD200Response> {
            return localVarFp.indicesMACD(indicesTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {IndicesRSISeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close values to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indicesRSI(indicesTicker: string, timestamp?: string, timespan?: IndicesRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesRSISeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoRSI200Response> {
            return localVarFp.indicesRSI(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {IndicesSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {IndicesSMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {IndicesSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indicesSMA(indicesTicker: string, timestamp?: string, timespan?: IndicesSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesSMASeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoSMA200Response> {
            return localVarFp.indicesSMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Snapshot of indices data for said tickers
         * @summary Indices Snapshot
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {IndicesSnapshotOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {IndicesSnapshotSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indicesSnapshot(tickerAnyOf?: string, ticker?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: IndicesSnapshotOrderEnum, limit?: number, sort?: IndicesSnapshotSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<IndicesSnapshot200Response> {
            return localVarFp.indicesSnapshot(tickerAnyOf, ticker, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent NBBO (Quote) tick for a given stock.
         * @summary Last Quote
         * @param {string} stocksTicker The ticker symbol of the stock/equity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastQuote(stocksTicker: string, options?: RawAxiosRequestConfig): AxiosPromise<LastQuote200Response> {
            return localVarFp.lastQuote(stocksTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the last quote tick for a forex currency pair.
         * @summary Last Quote for a Currency Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastQuoteCurrencies(from: string, to: string, options?: RawAxiosRequestConfig): AxiosPromise<LastQuoteCurrencies200Response> {
            return localVarFp.lastQuoteCurrencies(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent trade for a given stock.
         * @summary Last Trade
         * @param {string} stocksTicker The ticker symbol of the stock/equity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastTrade(stocksTicker: string, options?: RawAxiosRequestConfig): AxiosPromise<LastTradeOptions200Response> {
            return localVarFp.lastTrade(stocksTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the last trade tick for a cryptocurrency pair.
         * @summary Last Trade for a Crypto Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastTradeCrypto(from: string, to: string, options?: RawAxiosRequestConfig): AxiosPromise<LastTradeCrypto200Response> {
            return localVarFp.lastTradeCrypto(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent trade for a given options contract.
         * @summary Last Trade
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastTradeOptions(optionsTicker: string, options?: RawAxiosRequestConfig): AxiosPromise<LastTradeOptions200Response> {
            return localVarFp.lastTradeOptions(optionsTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * List all conditions that Polygon.io uses.
         * @summary Conditions
         * @param {ListConditionsAssetClassEnum} [assetClass] Filter for conditions within a given asset class.
         * @param {ListConditionsDataTypeEnum} [dataType] Filter by data type.
         * @param {number} [id] Filter for conditions with a given ID.
         * @param {ListConditionsSipEnum} [sip] Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
         * @param {ListConditionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListConditionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConditions(assetClass?: ListConditionsAssetClassEnum, dataType?: ListConditionsDataTypeEnum, id?: number, sip?: ListConditionsSipEnum, order?: ListConditionsOrderEnum, limit?: number, sort?: ListConditionsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListConditions200Response> {
            return localVarFp.listConditions(assetClass, dataType, id, sip, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
         * @summary Dividends v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [exDividendDate] Query by ex-dividend date with the format YYYY-MM-DD.
         * @param {string} [recordDate] Query by record date with the format YYYY-MM-DD.
         * @param {string} [declarationDate] Query by declaration date with the format YYYY-MM-DD.
         * @param {string} [payDate] Query by pay date with the format YYYY-MM-DD.
         * @param {ListDividendsFrequencyEnum} [frequency] Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
         * @param {number} [cashAmount] Query by the cash amount of the dividend.
         * @param {ListDividendsDividendTypeEnum} [dividendType] Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [exDividendDateGte] Range by ex_dividend_date.
         * @param {string} [exDividendDateGt] Range by ex_dividend_date.
         * @param {string} [exDividendDateLte] Range by ex_dividend_date.
         * @param {string} [exDividendDateLt] Range by ex_dividend_date.
         * @param {string} [recordDateGte] Range by record_date.
         * @param {string} [recordDateGt] Range by record_date.
         * @param {string} [recordDateLte] Range by record_date.
         * @param {string} [recordDateLt] Range by record_date.
         * @param {string} [declarationDateGte] Range by declaration_date.
         * @param {string} [declarationDateGt] Range by declaration_date.
         * @param {string} [declarationDateLte] Range by declaration_date.
         * @param {string} [declarationDateLt] Range by declaration_date.
         * @param {string} [payDateGte] Range by pay_date.
         * @param {string} [payDateGt] Range by pay_date.
         * @param {string} [payDateLte] Range by pay_date.
         * @param {string} [payDateLt] Range by pay_date.
         * @param {number} [cashAmountGte] Range by cash_amount.
         * @param {number} [cashAmountGt] Range by cash_amount.
         * @param {number} [cashAmountLte] Range by cash_amount.
         * @param {number} [cashAmountLt] Range by cash_amount.
         * @param {ListDividendsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListDividendsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDividends(ticker?: string, exDividendDate?: string, recordDate?: string, declarationDate?: string, payDate?: string, frequency?: ListDividendsFrequencyEnum, cashAmount?: number, dividendType?: ListDividendsDividendTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, exDividendDateGte?: string, exDividendDateGt?: string, exDividendDateLte?: string, exDividendDateLt?: string, recordDateGte?: string, recordDateGt?: string, recordDateLte?: string, recordDateLt?: string, declarationDateGte?: string, declarationDateGt?: string, declarationDateLte?: string, declarationDateLt?: string, payDateGte?: string, payDateGt?: string, payDateLte?: string, payDateLt?: string, cashAmountGte?: number, cashAmountGt?: number, cashAmountLte?: number, cashAmountLt?: number, order?: ListDividendsOrderEnum, limit?: number, sort?: ListDividendsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListDividends200Response> {
            return localVarFp.listDividends(ticker, exDividendDate, recordDate, declarationDate, payDate, frequency, cashAmount, dividendType, tickerGte, tickerGt, tickerLte, tickerLt, exDividendDateGte, exDividendDateGt, exDividendDateLte, exDividendDateLt, recordDateGte, recordDateGt, recordDateLte, recordDateLt, declarationDateGte, declarationDateGt, declarationDateLte, declarationDateLt, payDateGte, payDateGt, payDateLte, payDateLt, cashAmountGte, cashAmountGt, cashAmountLte, cashAmountLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * List all exchanges that Polygon.io knows about.
         * @summary Exchanges
         * @param {ListExchangesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListExchangesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExchanges(assetClass?: ListExchangesAssetClassEnum, locale?: ListExchangesLocaleEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListExchanges200Response> {
            return localVarFp.listExchanges(assetClass, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
         * @summary Stock Financials vX
         * @param {string} [ticker] Query by company ticker.
         * @param {string} [cik] Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number
         * @param {string} [companyName] Query by company name.
         * @param {string} [sic] Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;)
         * @param {string} [filingDate] Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01
         * @param {string} [periodOfReportDate] The period of report for the filing with financials data in YYYY-MM-DD format.
         * @param {ListFinancialsTimeframeEnum} [timeframe] Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
         * @param {boolean} [includeSources] Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default.
         * @param {string} [companyNameSearch] Search by company_name.
         * @param {string} [filingDateGte] Search by filing_date.
         * @param {string} [filingDateGt] Search by filing_date.
         * @param {string} [filingDateLte] Search by filing_date.
         * @param {string} [filingDateLt] Search by filing_date.
         * @param {string} [periodOfReportDateGte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateGt] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLt] Search by period_of_report_date.
         * @param {ListFinancialsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 100.
         * @param {ListFinancialsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFinancials(ticker?: string, cik?: string, companyName?: string, sic?: string, filingDate?: string, periodOfReportDate?: string, timeframe?: ListFinancialsTimeframeEnum, includeSources?: boolean, companyNameSearch?: string, filingDateGte?: string, filingDateGt?: string, filingDateLte?: string, filingDateLt?: string, periodOfReportDateGte?: string, periodOfReportDateGt?: string, periodOfReportDateLte?: string, periodOfReportDateLt?: string, order?: ListFinancialsOrderEnum, limit?: number, sort?: ListFinancialsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListFinancials200Response> {
            return localVarFp.listFinancials(ticker, cik, companyName, sic, filingDate, periodOfReportDate, timeframe, includeSources, companyNameSearch, filingDateGte, filingDateGt, filingDateLte, filingDateLt, periodOfReportDateGte, periodOfReportDateGt, periodOfReportDateLte, periodOfReportDateLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
         * @summary IPOs
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [usCode] Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
         * @param {string} [isin] Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
         * @param {string} [listingDate] Specify a listing date. This is the first trading date for the newly listed entity.
         * @param {ListIPOsIpoStatusEnum} [ipoStatus] Specify an IPO status.
         * @param {string} [listingDateGte] Range by listing_date.
         * @param {string} [listingDateGt] Range by listing_date.
         * @param {string} [listingDateLte] Range by listing_date.
         * @param {string} [listingDateLt] Range by listing_date.
         * @param {ListIPOsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListIPOsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIPOs(ticker?: string, usCode?: string, isin?: string, listingDate?: string, ipoStatus?: ListIPOsIpoStatusEnum, listingDateGte?: string, listingDateGt?: string, listingDateLte?: string, listingDateLt?: string, order?: ListIPOsOrderEnum, limit?: number, sort?: ListIPOsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListIPOs200Response> {
            return localVarFp.listIPOs(ticker, usCode, isin, listingDate, ipoStatus, listingDateGte, listingDateGt, listingDateLte, listingDateLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
         * @summary Ticker News
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtc] Return results published on, before, or after this date.
         * @param {string} [tickerGte] Search by ticker.
         * @param {string} [tickerGt] Search by ticker.
         * @param {string} [tickerLte] Search by ticker.
         * @param {string} [tickerLt] Search by ticker.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGt] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLt] Search by published_utc.
         * @param {ListNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListNewsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNews(ticker?: string, publishedUtc?: ListNewsPublishedUtcParameter, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, publishedUtcGte?: ListNewsPublishedUtcParameter, publishedUtcGt?: ListNewsPublishedUtcParameter, publishedUtcLte?: ListNewsPublishedUtcParameter, publishedUtcLt?: ListNewsPublishedUtcParameter, order?: ListNewsOrderEnum, limit?: number, sort?: ListNewsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListNews200Response> {
            return localVarFp.listNews(ticker, publishedUtc, tickerGte, tickerGt, tickerLte, tickerLt, publishedUtcGte, publishedUtcGt, publishedUtcLte, publishedUtcLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Query for historical options contracts. This provides both active and expired options contracts.
         * @summary Options Contracts
         * @param {string} [ticker] This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://polygon.io/docs/options/get_v3_reference_options_contracts__options_ticker).
         * @param {string} [underlyingTicker] Query for contracts relating to an underlying stock ticker.
         * @param {ListOptionsContractsContractTypeEnum} [contractType] Query by the type of contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {string} [asOf] Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {boolean} [expired] Query for expired contracts. Default is false.
         * @param {string} [underlyingTickerGte] Range by underlying_ticker.
         * @param {string} [underlyingTickerGt] Range by underlying_ticker.
         * @param {string} [underlyingTickerLte] Range by underlying_ticker.
         * @param {string} [underlyingTickerLt] Range by underlying_ticker.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {ListOptionsContractsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListOptionsContractsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOptionsContracts(ticker?: string, underlyingTicker?: string, contractType?: ListOptionsContractsContractTypeEnum, expirationDate?: string, asOf?: string, strikePrice?: number, expired?: boolean, underlyingTickerGte?: string, underlyingTickerGt?: string, underlyingTickerLte?: string, underlyingTickerLt?: string, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, order?: ListOptionsContractsOrderEnum, limit?: number, sort?: ListOptionsContractsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListOptionsContracts200Response> {
            return localVarFp.listOptionsContracts(ticker, underlyingTicker, contractType, expirationDate, asOf, strikePrice, expired, underlyingTickerGte, underlyingTickerGt, underlyingTickerLte, underlyingTickerLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
         * @summary Stock Splits v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [executionDate] Query by execution date with the format YYYY-MM-DD.
         * @param {boolean | null} [reverseSplit] Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [executionDateGte] Range by execution_date.
         * @param {string} [executionDateGt] Range by execution_date.
         * @param {string} [executionDateLte] Range by execution_date.
         * @param {string} [executionDateLt] Range by execution_date.
         * @param {ListStockSplitsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListStockSplitsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStockSplits(ticker?: string, executionDate?: string, reverseSplit?: boolean | null, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, executionDateGte?: string, executionDateGt?: string, executionDateLte?: string, executionDateLt?: string, order?: ListStockSplitsOrderEnum, limit?: number, sort?: ListStockSplitsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListStockSplits200Response> {
            return localVarFp.listStockSplits(ticker, executionDate, reverseSplit, tickerGte, tickerGt, tickerLte, tickerLt, executionDateGte, executionDateGt, executionDateLte, executionDateLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * List all ticker types that Polygon.io has.
         * @summary Ticker Types
         * @param {ListTickerTypesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListTickerTypesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickerTypes(assetClass?: ListTickerTypesAssetClassEnum, locale?: ListTickerTypesLocaleEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListTickerTypes200Response> {
            return localVarFp.listTickerTypes(assetClass, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
         * @summary Tickers
         * @param {string} [ticker] Specify a ticker symbol. Defaults to empty string which queries all tickers.
         * @param {ListTickersTypeEnum} [type] Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types). Defaults to empty string which queries all types.
         * @param {ListTickersMarketEnum} [market] Filter by market type. By default all markets are included.
         * @param {string} [exchange] Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes [at the ISO org website](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges.
         * @param {string} [cusip] Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
         * @param {string} [cik] Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs.
         * @param {string} [date] Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.
         * @param {string} [search] Search for terms within the ticker and/or company name.
         * @param {boolean} [active] Specify if the tickers returned should be actively traded on the queried date. Default is true.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {ListTickersOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 1000.
         * @param {ListTickersSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickers(ticker?: string, type?: ListTickersTypeEnum, market?: ListTickersMarketEnum, exchange?: string, cusip?: string, cik?: string, date?: string, search?: string, active?: boolean, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: ListTickersOrderEnum, limit?: number, sort?: ListTickersSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListTickers200Response> {
            return localVarFp.listTickers(ticker, type, market, exchange, cusip, cik, date, search, active, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {MACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {MACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {MACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mACD(stockTicker: string, timestamp?: string, timespan?: MACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: MACDSeriesTypeEnum, expandUnderlying?: boolean, order?: MACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoMACD200Response> {
            return localVarFp.mACD(stockTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the snapshot of an option contract for a stock equity.
         * @summary Option Contract
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {string} optionContract The option contract identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionContract(underlyingAsset: string, optionContract: string, options?: RawAxiosRequestConfig): AxiosPromise<OptionContract200Response> {
            return localVarFp.optionContract(underlyingAsset, optionContract, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the snapshot of all options contracts for an underlying ticker.
         * @summary Options Chain
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {OptionsChainContractTypeEnum} [contractType] Query by the type of contract.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {OptionsChainOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {OptionsChainSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsChain(underlyingAsset: string, strikePrice?: number, expirationDate?: string, contractType?: OptionsChainContractTypeEnum, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, order?: OptionsChainOrderEnum, limit?: number, sort?: OptionsChainSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<OptionsChain200Response> {
            return localVarFp.optionsChain(underlyingAsset, strikePrice, expirationDate, contractType, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {OptionsEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsEMA(optionsTicker: string, timestamp?: string, timespan?: OptionsEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsEMASeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoEMA200Response> {
            return localVarFp.optionsEMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} optionsTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {OptionsMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsMACD(optionsTicker: string, timestamp?: string, timespan?: OptionsMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: OptionsMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoMACD200Response> {
            return localVarFp.optionsMACD(optionsTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {OptionsRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsRSI(optionsTicker: string, timestamp?: string, timespan?: OptionsRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsRSISeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoRSI200Response> {
            return localVarFp.optionsRSI(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {OptionsSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {OptionsSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {OptionsSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsSMA(optionsTicker: string, timestamp?: string, timespan?: OptionsSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsSMASeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoSMA200Response> {
            return localVarFp.optionsSMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get NBBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (NBBO)
         * @param {string} stockTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {QuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {QuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotes(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesOrderEnum, limit?: number, sort?: QuotesSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<Quotes200Response> {
            return localVarFp.quotes(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get BBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (BBO)
         * @param {string} fxTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {QuotesFxOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {QuotesFxSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesFx(fxTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesFxOrderEnum, limit?: number, sort?: QuotesFxSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<QuotesFx200Response> {
            return localVarFp.quotesFx(fxTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get quotes for an options ticker symbol in a given time range.
         * @summary Quotes
         * @param {string} optionsTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {QuotesOptionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {QuotesOptionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesOptions(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesOptionsOrderEnum, limit?: number, sort?: QuotesOptionsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<QuotesOptions200Response> {
            return localVarFp.quotesOptions(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {RSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {RSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {RSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rSI(stockTicker: string, timestamp?: string, timespan?: RSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: RSISeriesTypeEnum, expandUnderlying?: boolean, order?: RSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoRSI200Response> {
            return localVarFp.rSI(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
         * @summary Real-time Currency Conversion
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {number} [amount] The amount to convert, with a decimal.
         * @param {RealTimeCurrencyConversionPrecisionEnum} [precision] The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        realTimeCurrencyConversion(from: string, to: string, amount?: number, precision?: RealTimeCurrencyConversionPrecisionEnum, options?: RawAxiosRequestConfig): AxiosPromise<RealTimeCurrencyConversion200Response> {
            return localVarFp.realTimeCurrencyConversion(from, to, amount, precision, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {SMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {SMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {SMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sMA(stockTicker: string, timestamp?: string, timespan?: SMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: SMASeriesTypeEnum, expandUnderlying?: boolean, order?: SMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): AxiosPromise<CryptoSMA200Response> {
            return localVarFp.sMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
         * @summary Summaries
         * @param {string} [tickerAnyOf] Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://polygon.io/docs/stocks/get_v3_reference_tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotSummary(tickerAnyOf?: string, options?: RawAxiosRequestConfig): AxiosPromise<SnapshotSummary200Response> {
            return localVarFp.snapshotSummary(tickerAnyOf, options).then((request) => request(axios, basePath));
        },
        /**
         * Get snapshots for assets of all types
         * @summary Universal Snapshot
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {SnapshotsTypeEnum} [type] Query by the type of asset.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. 
         * @param {SnapshotsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {SnapshotsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshots(ticker?: string, type?: SnapshotsTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, tickerAnyOf?: string, order?: SnapshotsOrderEnum, limit?: number, sort?: SnapshotsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<Snapshots200Response> {
            return localVarFp.snapshots(ticker, type, tickerGte, tickerGt, tickerLte, tickerLt, tickerAnyOf, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve finra_short_interest_v1 data via API.
         * @summary finra_short_interest_v1 API
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [daysToCover] Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume.
         * @param {string} [settlementDate] The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
         * @param {string} [avgDailyVolume] The average daily trading volume for the stock over a specified period, typically used to contextualize short interest.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [daysToCoverGte] Range by days_to_cover.
         * @param {string} [daysToCoverGt] Range by days_to_cover.
         * @param {string} [daysToCoverLte] Range by days_to_cover.
         * @param {string} [daysToCoverLt] Range by days_to_cover.
         * @param {string} [settlementDateGte] Range by settlement_date.
         * @param {string} [settlementDateGt] Range by settlement_date.
         * @param {string} [settlementDateLte] Range by settlement_date.
         * @param {string} [settlementDateLt] Range by settlement_date.
         * @param {string} [avgDailyVolumeGte] Range by avg_daily_volume.
         * @param {string} [avgDailyVolumeGt] Range by avg_daily_volume.
         * @param {string} [avgDailyVolumeLte] Range by avg_daily_volume.
         * @param {string} [avgDailyVolumeLt] Range by avg_daily_volume.
         * @param {StocksShortInterestOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 50000.
         * @param {StocksShortInterestSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stocksShortInterest(ticker?: string, daysToCover?: string, settlementDate?: string, avgDailyVolume?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, daysToCoverGte?: string, daysToCoverGt?: string, daysToCoverLte?: string, daysToCoverLt?: string, settlementDateGte?: string, settlementDateGt?: string, settlementDateLte?: string, settlementDateLt?: string, avgDailyVolumeGte?: string, avgDailyVolumeGt?: string, avgDailyVolumeLte?: string, avgDailyVolumeLt?: string, order?: StocksShortInterestOrderEnum, limit?: number, sort?: StocksShortInterestSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<StocksShortInterest200Response> {
            return localVarFp.stocksShortInterest(ticker, daysToCover, settlementDate, avgDailyVolume, tickerGte, tickerGt, tickerLte, tickerLt, daysToCoverGte, daysToCoverGt, daysToCoverLte, daysToCoverLt, settlementDateGte, settlementDateGt, settlementDateLte, settlementDateLt, avgDailyVolumeGte, avgDailyVolumeGt, avgDailyVolumeLte, avgDailyVolumeLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve finra_short_volume_v1 data via API.
         * @summary finra_short_volume_v1 API
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [date] The date of trade activity reported in the format YYYY-MM-DD
         * @param {string} [shortVolumeRatio] The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100.
         * @param {string} [totalVolume] Total reported volume across all venues for the ticker on the given date.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [dateGte] Range by date.
         * @param {string} [dateGt] Range by date.
         * @param {string} [dateLte] Range by date.
         * @param {string} [dateLt] Range by date.
         * @param {string} [shortVolumeRatioGte] Range by short_volume_ratio.
         * @param {string} [shortVolumeRatioGt] Range by short_volume_ratio.
         * @param {string} [shortVolumeRatioLte] Range by short_volume_ratio.
         * @param {string} [shortVolumeRatioLt] Range by short_volume_ratio.
         * @param {string} [totalVolumeGte] Range by total_volume.
         * @param {string} [totalVolumeGt] Range by total_volume.
         * @param {string} [totalVolumeLte] Range by total_volume.
         * @param {string} [totalVolumeLt] Range by total_volume.
         * @param {StocksShortVolumeOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 50000.
         * @param {StocksShortVolumeSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stocksShortVolume(ticker?: string, date?: string, shortVolumeRatio?: string, totalVolume?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, shortVolumeRatioGte?: string, shortVolumeRatioGt?: string, shortVolumeRatioLte?: string, shortVolumeRatioLt?: string, totalVolumeGte?: string, totalVolumeGt?: string, totalVolumeLte?: string, totalVolumeLt?: string, order?: StocksShortVolumeOrderEnum, limit?: number, sort?: StocksShortVolumeSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<StocksShortVolume200Response> {
            return localVarFp.stocksShortVolume(ticker, date, shortVolumeRatio, totalVolume, tickerGte, tickerGt, tickerLte, tickerLt, dateGte, dateGt, dateLte, dateLt, shortVolumeRatioGte, shortVolumeRatioGt, shortVolumeRatioLte, shortVolumeRatioLt, totalVolumeGte, totalVolumeGt, totalVolumeLte, totalVolumeLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a ticker symbol in a given time range.
         * @summary Trades
         * @param {string} stockTicker The ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {TradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {TradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trades(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesOrderEnum, limit?: number, sort?: TradesSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<Trades200Response> {
            return localVarFp.trades(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a crypto ticker symbol in a given time range.
         * @summary Trades
         * @param {string} cryptoTicker The ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {TradesCryptoOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {TradesCryptoSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradesCrypto(cryptoTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesCryptoOrderEnum, limit?: number, sort?: TradesCryptoSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<TradesCrypto200Response> {
            return localVarFp.tradesCrypto(cryptoTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for an options ticker symbol in a given time range.
         * @summary Trades
         * @param {string} optionsTicker The options ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {TradesOptionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {TradesOptionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradesOptions(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesOptionsOrderEnum, limit?: number, sort?: TradesOptionsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<TradesOptions200Response> {
            return localVarFp.tradesOptions(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get historic trade ticks for a cryptocurrency pair. 
         * @summary Historic Crypto Trades
         * @param {string} from The \&quot;from\&quot; symbol of the crypto pair.
         * @param {string} to The \&quot;to\&quot; symbol of the crypto pair.
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1HistoricCryptoFromToDateGet(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<V1HistoricCryptoFromToDateGet200Response> {
            return localVarFp.v1HistoricCryptoFromToDateGet(from, to, date, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get historic ticks for a forex currency pair. 
         * @summary Historic Forex Ticks
         * @param {string} from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
         * @param {string} to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1HistoricForexFromToDateGet(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<V1HistoricForexFromToDateGet200Response> {
            return localVarFp.v1HistoricForexFromToDateGet(from, to, date, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close prices of a cryptocurrency symbol on a certain day. 
         * @summary Daily Open/Close
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OpenCloseCryptoFromToDateGet(from: string, to: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V1OpenCloseCryptoFromToDateGet200Response> {
            return localVarFp.v1OpenCloseCryptoFromToDateGet(from, to, date, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close and afterhours values of a index symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OpenCloseIndicesTickerDateGet(indicesTicker: string, date: string, options?: RawAxiosRequestConfig): AxiosPromise<V1OpenCloseIndicesTickerDateGet200Response> {
            return localVarFp.v1OpenCloseIndicesTickerDateGet(indicesTicker, date, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close and afterhours prices of an options contract on a certain date. 
         * @summary Daily Open/Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OpenCloseOptionsTickerDateGet(optionsTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V1OpenCloseOptionsTickerDateGet200Response> {
            return localVarFp.v1OpenCloseOptionsTickerDateGet(optionsTicker, date, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close and afterhours prices of a stock symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OpenCloseStocksTickerDateGet(stocksTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V1OpenCloseOptionsTickerDateGet200Response> {
            return localVarFp.v1OpenCloseStocksTickerDateGet(stocksTicker, date, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsGroupedLocaleGlobalMarketCryptoDateGet(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response> {
            return localVarFp.v2AggsGroupedLocaleGlobalMarketCryptoDateGet(date, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsGroupedLocaleGlobalMarketFxDateGet(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response> {
            return localVarFp.v2AggsGroupedLocaleGlobalMarketFxDateGet(date, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsGroupedLocaleUsMarketStocksDateGet(date: string, adjusted?: boolean, includeOtc?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsGroupedLocaleUsMarketStocksDateGet200Response> {
            return localVarFp.v2AggsGroupedLocaleUsMarketStocksDateGet(date, adjusted, includeOtc, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
         * @summary Previous Close
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerCryptoTickerPrevGet(cryptoTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsTickerCryptoTickerPrevGet200Response> {
            return localVarFp.v2AggsTickerCryptoTickerPrevGet(cryptoTicker, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet(cryptoTicker: string, multiplier: number, timespan: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response> {
            return localVarFp.v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet(cryptoTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
         * @summary Previous Close
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerForexTickerPrevGet(forexTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsTickerForexTickerPrevGet200Response> {
            return localVarFp.v2AggsTickerForexTickerPrevGet(forexTicker, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet(forexTicker: string, multiplier: number, timespan: V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response> {
            return localVarFp.v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet(forexTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
         * @summary Previous Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerIndicesTickerPrevGet(indicesTicker: string, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsTickerIndicesTickerPrevGet200Response> {
            return localVarFp.v2AggsTickerIndicesTickerPrevGet(indicesTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet(indicesTicker: string, multiplier: number, timespan: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, sort?: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsTickerIndicesTickerPrevGet200Response> {
            return localVarFp.v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet(indicesTicker, multiplier, timespan, from, to, sort, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
         * @summary Previous Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerOptionsTickerPrevGet(optionsTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response> {
            return localVarFp.v2AggsTickerOptionsTickerPrevGet(optionsTicker, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet(optionsTicker: string, multiplier: number, timespan: V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response> {
            return localVarFp.v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet(optionsTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
         * @summary Previous Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerStocksTickerPrevGet(stocksTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response> {
            return localVarFp.v2AggsTickerStocksTickerPrevGet(stocksTicker, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet(stocksTicker: string, multiplier: number, timespan: V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet200Response> {
            return localVarFp.v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet(stocksTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {V2SnapshotLocaleGlobalMarketsCryptoDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsCryptoDirectionGet(direction: V2SnapshotLocaleGlobalMarketsCryptoDirectionGetDirectionEnum, options?: RawAxiosRequestConfig): AxiosPromise<V2SnapshotLocaleGlobalMarketsCryptoDirectionGet200Response> {
            return localVarFp.v2SnapshotLocaleGlobalMarketsCryptoDirectionGet(direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsCryptoTickersGet(tickers?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<V2SnapshotLocaleGlobalMarketsCryptoTickersGet200Response> {
            return localVarFp.v2SnapshotLocaleGlobalMarketsCryptoTickersGet(tickers, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker Full Book (L2)
         * @param {string} ticker The cryptocurrency ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet(ticker: string, options?: RawAxiosRequestConfig): AxiosPromise<V2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet200Response> {
            return localVarFp.v2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet(ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker Ticker of the snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet(ticker: string, options?: RawAxiosRequestConfig): AxiosPromise<V2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet200Response> {
            return localVarFp.v2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet(ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {V2SnapshotLocaleGlobalMarketsForexDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsForexDirectionGet(direction: V2SnapshotLocaleGlobalMarketsForexDirectionGetDirectionEnum, options?: RawAxiosRequestConfig): AxiosPromise<V2SnapshotLocaleGlobalMarketsForexTickersGet200Response> {
            return localVarFp.v2SnapshotLocaleGlobalMarketsForexDirectionGet(direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsForexTickersGet(tickers?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<V2SnapshotLocaleGlobalMarketsForexTickersGet200Response> {
            return localVarFp.v2SnapshotLocaleGlobalMarketsForexTickersGet(tickers, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker The forex ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleGlobalMarketsForexTickersTickerGet(ticker: string, options?: RawAxiosRequestConfig): AxiosPromise<V2SnapshotLocaleGlobalMarketsForexTickersTickerGet200Response> {
            return localVarFp.v2SnapshotLocaleGlobalMarketsForexTickersTickerGet(ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {V2SnapshotLocaleUsMarketsStocksDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleUsMarketsStocksDirectionGet(direction: V2SnapshotLocaleUsMarketsStocksDirectionGetDirectionEnum, includeOtc?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V2SnapshotLocaleUsMarketsStocksDirectionGet200Response> {
            return localVarFp.v2SnapshotLocaleUsMarketsStocksDirectionGet(direction, includeOtc, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleUsMarketsStocksTickersGet(tickers?: Array<string>, includeOtc?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V2SnapshotLocaleUsMarketsStocksTickersGet200Response> {
            return localVarFp.v2SnapshotLocaleUsMarketsStocksTickersGet(tickers, includeOtc, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary Ticker
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet(stocksTicker: string, options?: RawAxiosRequestConfig): AxiosPromise<V2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet200Response> {
            return localVarFp.v2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet(stocksTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get NBBO quotes for a given ticker symbol on a specified date. 
         * @summary Quotes (NBBO)
         * @param {string} ticker The ticker symbol we want quotes for.
         * @param {string} date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TicksStocksNbboTickerDateGet(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<V2TicksStocksNbboTickerDateGet200Response> {
            return localVarFp.v2TicksStocksNbboTickerDateGet(ticker, date, timestamp, timestampLimit, reverse, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a given ticker symbol on a specified date. 
         * @summary Trades
         * @param {string} ticker The ticker symbol we want trades for.
         * @param {string} date The date/day of the trades to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TicksStocksTradesTickerDateGet(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<V2TicksStocksTradesTickerDateGet200Response> {
            return localVarFp.v2TicksStocksTradesTickerDateGet(ticker, date, timestamp, timestampLimit, reverse, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Retrieve earnings_v1 data via API.
     * @summary earnings_v1 API
     * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
     * @param {string} [ticker] The stock symbol of the company reporting earnings.
     * @param {string} [dateGte] Range by date.
     * @param {string} [dateGt] Range by date.
     * @param {string} [dateLte] Range by date.
     * @param {string} [dateLt] Range by date.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {BenzingaEarningsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
     * @param {BenzingaEarningsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public benzingaEarnings(date?: string, ticker?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: BenzingaEarningsOrderEnum, limit?: number, sort?: BenzingaEarningsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).benzingaEarnings(date, ticker, dateGte, dateGt, dateLte, dateLt, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve news_v1 data via API.
     * @summary news_v1 API
     * @param {string} [created] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
     * @param {string} [tickers] A list of stock or crypto tickers mentioned in the article.
     * @param {string} [createdGte] Range by created.
     * @param {string} [createdGt] Range by created.
     * @param {string} [createdLte] Range by created.
     * @param {string} [createdLt] Range by created.
     * @param {string} [tickersGte] Range by tickers.
     * @param {string} [tickersGt] Range by tickers.
     * @param {string} [tickersLte] Range by tickers.
     * @param {string} [tickersLt] Range by tickers.
     * @param {BenzingaNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
     * @param {BenzingaNewsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public benzingaNews(created?: string, tickers?: string, createdGte?: string, createdGt?: string, createdLte?: string, createdLt?: string, tickersGte?: string, tickersGt?: string, tickersLte?: string, tickersLt?: string, order?: BenzingaNewsOrderEnum, limit?: number, sort?: BenzingaNewsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).benzingaNews(created, tickers, createdGte, createdGt, createdLte, createdLt, tickersGte, tickersGt, tickersLte, tickersLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve ratings_v1 data via API.
     * @summary ratings_v1 API
     * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
     * @param {string} [ticker] The stock symbol of the company being rated.
     * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrade, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
     * @param {string} [priceTargetAction] The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
     * @param {string} [rating] The current rating set by the analyst.
     * @param {string} [firm] The name of the research firm or investment bank issuing the rating.
     * @param {string} [dateGte] Range by date.
     * @param {string} [dateGt] Range by date.
     * @param {string} [dateLte] Range by date.
     * @param {string} [dateLt] Range by date.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {string} [ratingActionGte] Range by rating_action.
     * @param {string} [ratingActionGt] Range by rating_action.
     * @param {string} [ratingActionLte] Range by rating_action.
     * @param {string} [ratingActionLt] Range by rating_action.
     * @param {string} [priceTargetActionGte] Range by price_target_action.
     * @param {string} [priceTargetActionGt] Range by price_target_action.
     * @param {string} [priceTargetActionLte] Range by price_target_action.
     * @param {string} [priceTargetActionLt] Range by price_target_action.
     * @param {string} [ratingGte] Range by rating.
     * @param {string} [ratingGt] Range by rating.
     * @param {string} [ratingLte] Range by rating.
     * @param {string} [ratingLt] Range by rating.
     * @param {string} [firmGte] Range by firm.
     * @param {string} [firmGt] Range by firm.
     * @param {string} [firmLte] Range by firm.
     * @param {string} [firmLt] Range by firm.
     * @param {BenzingaRatingsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 100 and max is 50000.
     * @param {BenzingaRatingsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public benzingaRatings(date?: string, ticker?: string, ratingAction?: string, priceTargetAction?: string, rating?: string, firm?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, ratingActionGte?: string, ratingActionGt?: string, ratingActionLte?: string, ratingActionLt?: string, priceTargetActionGte?: string, priceTargetActionGt?: string, priceTargetActionLte?: string, priceTargetActionLt?: string, ratingGte?: string, ratingGt?: string, ratingLte?: string, ratingLt?: string, firmGte?: string, firmGt?: string, firmLte?: string, firmLt?: string, order?: BenzingaRatingsOrderEnum, limit?: number, sort?: BenzingaRatingsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).benzingaRatings(date, ticker, ratingAction, priceTargetAction, rating, firm, dateGte, dateGt, dateLte, dateLt, tickerGte, tickerGt, tickerLte, tickerLt, ratingActionGte, ratingActionGt, ratingActionLte, ratingActionLt, priceTargetActionGte, priceTargetActionGt, priceTargetActionLte, priceTargetActionLt, ratingGte, ratingGt, ratingLte, ratingLt, firmGte, firmGt, firmLte, firmLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {string} cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {CryptoEMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {CryptoEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {CryptoEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cryptoEMA(cryptoTicker: string, timestamp?: string, timespan?: CryptoEMATimespanEnum, window?: number, seriesType?: CryptoEMASeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cryptoEMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {string} cryptoTicker The ticker symbol for which to get MACD data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {CryptoMACDTimespanEnum} [timespan] The size of the aggregate time window.
     * @param {number} [shortWindow] The short window size used to calculate MACD data.
     * @param {number} [longWindow] The long window size used to calculate MACD data.
     * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
     * @param {CryptoMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate MACD data. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {CryptoMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cryptoMACD(cryptoTicker: string, timestamp?: string, timespan?: CryptoMACDTimespanEnum, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: CryptoMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cryptoMACD(cryptoTicker, timestamp, timespan, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {string} cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {CryptoRSITimespanEnum} [timespan] The size of the aggregate time window.
     * @param {number} [window] The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {CryptoRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {CryptoRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cryptoRSI(cryptoTicker: string, timestamp?: string, timespan?: CryptoRSITimespanEnum, window?: number, seriesType?: CryptoRSISeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cryptoRSI(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {string} cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {CryptoSMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {CryptoSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {CryptoSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cryptoSMA(cryptoTicker: string, timestamp?: string, timespan?: CryptoSMATimespanEnum, window?: number, seriesType?: CryptoSMASeriesTypeEnum, expandUnderlying?: boolean, order?: CryptoSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cryptoSMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {EMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {EMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {EMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public eMA(stockTicker: string, timestamp?: string, timespan?: EMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: EMASeriesTypeEnum, expandUnderlying?: boolean, order?: EMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).eMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {string} fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {ForexEMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {ForexEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {ForexEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public forexEMA(fxTicker: string, timestamp?: string, timespan?: ForexEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexEMASeriesTypeEnum, expandUnderlying?: boolean, order?: ForexEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forexEMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {string} fxTicker The ticker symbol for which to get MACD data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {ForexMACDTimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [shortWindow] The short window size used to calculate MACD data.
     * @param {number} [longWindow] The long window size used to calculate MACD data.
     * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
     * @param {ForexMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {ForexMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public forexMACD(fxTicker: string, timestamp?: string, timespan?: ForexMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: ForexMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: ForexMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forexMACD(fxTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {string} fxTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {ForexRSITimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the relative strength index (RSI).
     * @param {ForexRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {ForexRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public forexRSI(fxTicker: string, timestamp?: string, timespan?: ForexRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexRSISeriesTypeEnum, expandUnderlying?: boolean, order?: ForexRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forexRSI(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {string} fxTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {ForexSMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {ForexSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {ForexSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public forexSMA(fxTicker: string, timestamp?: string, timespan?: ForexSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: ForexSMASeriesTypeEnum, expandUnderlying?: boolean, order?: ForexSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forexSMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
     * @summary Ticker Events
     * @param {string} id Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the  [Ticker Details Endpoint](https://polygon.io/docs/stocks/get_v3_reference_tickers__ticker)
     * @param {string} [types] A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEvents(id: string, types?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEvents(id, types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get upcoming market holidays and their open/close times.
     * @summary Market Holidays
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarketHolidays(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMarketHolidays(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current trading status of the exchanges and overall financial markets.
     * @summary Market Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarketStatus(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMarketStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an options contract
     * @summary Options Contract
     * @param {string} optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://polygon.io/blog/how-to-read-a-stock-options-ticker/).
     * @param {string} [asOf] Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsContract(optionsTicker: string, asOf?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsContract(optionsTicker, asOf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of tickers related to the queried ticker based on News and Returns data.
     * @summary Related Companies
     * @param {string} ticker The ticker symbol to search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRelatedCompanies(ticker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRelatedCompanies(ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
     * @summary Ticker Details v3
     * @param {string} ticker The ticker symbol of the asset.
     * @param {string} [date] Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTicker(ticker: string, date?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTicker(ticker, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {string} indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {IndicesEMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {IndicesEMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the exponential moving average (EMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {IndicesEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public indicesEMA(indicesTicker: string, timestamp?: string, timespan?: IndicesEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesEMASeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).indicesEMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {string} indicesTicker The ticker symbol for which to get MACD data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {IndicesMACDTimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [shortWindow] The short window size used to calculate MACD data.
     * @param {number} [longWindow] The long window size used to calculate MACD data.
     * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
     * @param {IndicesMACDSeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close values to  calculate the MACD.
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {IndicesMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public indicesMACD(indicesTicker: string, timestamp?: string, timespan?: IndicesMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: IndicesMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).indicesMACD(indicesTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {string} indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {IndicesRSITimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the relative strength index (RSI).
     * @param {IndicesRSISeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close values to  calculate the relative strength index (RSI).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {IndicesRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public indicesRSI(indicesTicker: string, timestamp?: string, timespan?: IndicesRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesRSISeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).indicesRSI(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {string} indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {IndicesSMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {IndicesSMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the simple moving average (SMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {IndicesSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public indicesSMA(indicesTicker: string, timestamp?: string, timespan?: IndicesSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: IndicesSMASeriesTypeEnum, expandUnderlying?: boolean, order?: IndicesSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).indicesSMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Snapshot of indices data for said tickers
     * @summary Indices Snapshot
     * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
     * @param {string} [ticker] Search a range of tickers lexicographically.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {IndicesSnapshotOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
     * @param {IndicesSnapshotSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public indicesSnapshot(tickerAnyOf?: string, ticker?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: IndicesSnapshotOrderEnum, limit?: number, sort?: IndicesSnapshotSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).indicesSnapshot(tickerAnyOf, ticker, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent NBBO (Quote) tick for a given stock.
     * @summary Last Quote
     * @param {string} stocksTicker The ticker symbol of the stock/equity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lastQuote(stocksTicker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lastQuote(stocksTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the last quote tick for a forex currency pair.
     * @summary Last Quote for a Currency Pair
     * @param {string} from The \&quot;from\&quot; symbol of the pair.
     * @param {string} to The \&quot;to\&quot; symbol of the pair.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lastQuoteCurrencies(from: string, to: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lastQuoteCurrencies(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent trade for a given stock.
     * @summary Last Trade
     * @param {string} stocksTicker The ticker symbol of the stock/equity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lastTrade(stocksTicker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lastTrade(stocksTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the last trade tick for a cryptocurrency pair.
     * @summary Last Trade for a Crypto Pair
     * @param {string} from The \&quot;from\&quot; symbol of the pair.
     * @param {string} to The \&quot;to\&quot; symbol of the pair.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lastTradeCrypto(from: string, to: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lastTradeCrypto(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent trade for a given options contract.
     * @summary Last Trade
     * @param {string} optionsTicker The ticker symbol of the options contract.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lastTradeOptions(optionsTicker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lastTradeOptions(optionsTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all conditions that Polygon.io uses.
     * @summary Conditions
     * @param {ListConditionsAssetClassEnum} [assetClass] Filter for conditions within a given asset class.
     * @param {ListConditionsDataTypeEnum} [dataType] Filter by data type.
     * @param {number} [id] Filter for conditions with a given ID.
     * @param {ListConditionsSipEnum} [sip] Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
     * @param {ListConditionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListConditionsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listConditions(assetClass?: ListConditionsAssetClassEnum, dataType?: ListConditionsDataTypeEnum, id?: number, sip?: ListConditionsSipEnum, order?: ListConditionsOrderEnum, limit?: number, sort?: ListConditionsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listConditions(assetClass, dataType, id, sip, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
     * @summary Dividends v3
     * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {string} [exDividendDate] Query by ex-dividend date with the format YYYY-MM-DD.
     * @param {string} [recordDate] Query by record date with the format YYYY-MM-DD.
     * @param {string} [declarationDate] Query by declaration date with the format YYYY-MM-DD.
     * @param {string} [payDate] Query by pay date with the format YYYY-MM-DD.
     * @param {ListDividendsFrequencyEnum} [frequency] Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
     * @param {number} [cashAmount] Query by the cash amount of the dividend.
     * @param {ListDividendsDividendTypeEnum} [dividendType] Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {string} [exDividendDateGte] Range by ex_dividend_date.
     * @param {string} [exDividendDateGt] Range by ex_dividend_date.
     * @param {string} [exDividendDateLte] Range by ex_dividend_date.
     * @param {string} [exDividendDateLt] Range by ex_dividend_date.
     * @param {string} [recordDateGte] Range by record_date.
     * @param {string} [recordDateGt] Range by record_date.
     * @param {string} [recordDateLte] Range by record_date.
     * @param {string} [recordDateLt] Range by record_date.
     * @param {string} [declarationDateGte] Range by declaration_date.
     * @param {string} [declarationDateGt] Range by declaration_date.
     * @param {string} [declarationDateLte] Range by declaration_date.
     * @param {string} [declarationDateLt] Range by declaration_date.
     * @param {string} [payDateGte] Range by pay_date.
     * @param {string} [payDateGt] Range by pay_date.
     * @param {string} [payDateLte] Range by pay_date.
     * @param {string} [payDateLt] Range by pay_date.
     * @param {number} [cashAmountGte] Range by cash_amount.
     * @param {number} [cashAmountGt] Range by cash_amount.
     * @param {number} [cashAmountLte] Range by cash_amount.
     * @param {number} [cashAmountLt] Range by cash_amount.
     * @param {ListDividendsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListDividendsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listDividends(ticker?: string, exDividendDate?: string, recordDate?: string, declarationDate?: string, payDate?: string, frequency?: ListDividendsFrequencyEnum, cashAmount?: number, dividendType?: ListDividendsDividendTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, exDividendDateGte?: string, exDividendDateGt?: string, exDividendDateLte?: string, exDividendDateLt?: string, recordDateGte?: string, recordDateGt?: string, recordDateLte?: string, recordDateLt?: string, declarationDateGte?: string, declarationDateGt?: string, declarationDateLte?: string, declarationDateLt?: string, payDateGte?: string, payDateGt?: string, payDateLte?: string, payDateLt?: string, cashAmountGte?: number, cashAmountGt?: number, cashAmountLte?: number, cashAmountLt?: number, order?: ListDividendsOrderEnum, limit?: number, sort?: ListDividendsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listDividends(ticker, exDividendDate, recordDate, declarationDate, payDate, frequency, cashAmount, dividendType, tickerGte, tickerGt, tickerLte, tickerLt, exDividendDateGte, exDividendDateGt, exDividendDateLte, exDividendDateLt, recordDateGte, recordDateGt, recordDateLte, recordDateLt, declarationDateGte, declarationDateGt, declarationDateLte, declarationDateLt, payDateGte, payDateGt, payDateLte, payDateLt, cashAmountGte, cashAmountGt, cashAmountLte, cashAmountLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all exchanges that Polygon.io knows about.
     * @summary Exchanges
     * @param {ListExchangesAssetClassEnum} [assetClass] Filter by asset class.
     * @param {ListExchangesLocaleEnum} [locale] Filter by locale.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listExchanges(assetClass?: ListExchangesAssetClassEnum, locale?: ListExchangesLocaleEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listExchanges(assetClass, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
     * @summary Stock Financials vX
     * @param {string} [ticker] Query by company ticker.
     * @param {string} [cik] Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number
     * @param {string} [companyName] Query by company name.
     * @param {string} [sic] Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;)
     * @param {string} [filingDate] Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01
     * @param {string} [periodOfReportDate] The period of report for the filing with financials data in YYYY-MM-DD format.
     * @param {ListFinancialsTimeframeEnum} [timeframe] Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
     * @param {boolean} [includeSources] Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default.
     * @param {string} [companyNameSearch] Search by company_name.
     * @param {string} [filingDateGte] Search by filing_date.
     * @param {string} [filingDateGt] Search by filing_date.
     * @param {string} [filingDateLte] Search by filing_date.
     * @param {string} [filingDateLt] Search by filing_date.
     * @param {string} [periodOfReportDateGte] Search by period_of_report_date.
     * @param {string} [periodOfReportDateGt] Search by period_of_report_date.
     * @param {string} [periodOfReportDateLte] Search by period_of_report_date.
     * @param {string} [periodOfReportDateLt] Search by period_of_report_date.
     * @param {ListFinancialsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 100.
     * @param {ListFinancialsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listFinancials(ticker?: string, cik?: string, companyName?: string, sic?: string, filingDate?: string, periodOfReportDate?: string, timeframe?: ListFinancialsTimeframeEnum, includeSources?: boolean, companyNameSearch?: string, filingDateGte?: string, filingDateGt?: string, filingDateLte?: string, filingDateLt?: string, periodOfReportDateGte?: string, periodOfReportDateGt?: string, periodOfReportDateLte?: string, periodOfReportDateLt?: string, order?: ListFinancialsOrderEnum, limit?: number, sort?: ListFinancialsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFinancials(ticker, cik, companyName, sic, filingDate, periodOfReportDate, timeframe, includeSources, companyNameSearch, filingDateGte, filingDateGt, filingDateLte, filingDateLt, periodOfReportDateGte, periodOfReportDateGt, periodOfReportDateLte, periodOfReportDateLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
     * @summary IPOs
     * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {string} [usCode] Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
     * @param {string} [isin] Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
     * @param {string} [listingDate] Specify a listing date. This is the first trading date for the newly listed entity.
     * @param {ListIPOsIpoStatusEnum} [ipoStatus] Specify an IPO status.
     * @param {string} [listingDateGte] Range by listing_date.
     * @param {string} [listingDateGt] Range by listing_date.
     * @param {string} [listingDateLte] Range by listing_date.
     * @param {string} [listingDateLt] Range by listing_date.
     * @param {ListIPOsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListIPOsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listIPOs(ticker?: string, usCode?: string, isin?: string, listingDate?: string, ipoStatus?: ListIPOsIpoStatusEnum, listingDateGte?: string, listingDateGt?: string, listingDateLte?: string, listingDateLt?: string, order?: ListIPOsOrderEnum, limit?: number, sort?: ListIPOsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listIPOs(ticker, usCode, isin, listingDate, ipoStatus, listingDateGte, listingDateGt, listingDateLte, listingDateLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
     * @summary Ticker News
     * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {ListNewsPublishedUtcParameter} [publishedUtc] Return results published on, before, or after this date.
     * @param {string} [tickerGte] Search by ticker.
     * @param {string} [tickerGt] Search by ticker.
     * @param {string} [tickerLte] Search by ticker.
     * @param {string} [tickerLt] Search by ticker.
     * @param {ListNewsPublishedUtcParameter} [publishedUtcGte] Search by published_utc.
     * @param {ListNewsPublishedUtcParameter} [publishedUtcGt] Search by published_utc.
     * @param {ListNewsPublishedUtcParameter} [publishedUtcLte] Search by published_utc.
     * @param {ListNewsPublishedUtcParameter} [publishedUtcLt] Search by published_utc.
     * @param {ListNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListNewsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNews(ticker?: string, publishedUtc?: ListNewsPublishedUtcParameter, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, publishedUtcGte?: ListNewsPublishedUtcParameter, publishedUtcGt?: ListNewsPublishedUtcParameter, publishedUtcLte?: ListNewsPublishedUtcParameter, publishedUtcLt?: ListNewsPublishedUtcParameter, order?: ListNewsOrderEnum, limit?: number, sort?: ListNewsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listNews(ticker, publishedUtc, tickerGte, tickerGt, tickerLte, tickerLt, publishedUtcGte, publishedUtcGt, publishedUtcLte, publishedUtcLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query for historical options contracts. This provides both active and expired options contracts.
     * @summary Options Contracts
     * @param {string} [ticker] This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://polygon.io/docs/options/get_v3_reference_options_contracts__options_ticker).
     * @param {string} [underlyingTicker] Query for contracts relating to an underlying stock ticker.
     * @param {ListOptionsContractsContractTypeEnum} [contractType] Query by the type of contract.
     * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
     * @param {string} [asOf] Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
     * @param {number} [strikePrice] Query by strike price of a contract.
     * @param {boolean} [expired] Query for expired contracts. Default is false.
     * @param {string} [underlyingTickerGte] Range by underlying_ticker.
     * @param {string} [underlyingTickerGt] Range by underlying_ticker.
     * @param {string} [underlyingTickerLte] Range by underlying_ticker.
     * @param {string} [underlyingTickerLt] Range by underlying_ticker.
     * @param {string} [expirationDateGte] Range by expiration_date.
     * @param {string} [expirationDateGt] Range by expiration_date.
     * @param {string} [expirationDateLte] Range by expiration_date.
     * @param {string} [expirationDateLt] Range by expiration_date.
     * @param {number} [strikePriceGte] Range by strike_price.
     * @param {number} [strikePriceGt] Range by strike_price.
     * @param {number} [strikePriceLte] Range by strike_price.
     * @param {number} [strikePriceLt] Range by strike_price.
     * @param {ListOptionsContractsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListOptionsContractsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOptionsContracts(ticker?: string, underlyingTicker?: string, contractType?: ListOptionsContractsContractTypeEnum, expirationDate?: string, asOf?: string, strikePrice?: number, expired?: boolean, underlyingTickerGte?: string, underlyingTickerGt?: string, underlyingTickerLte?: string, underlyingTickerLt?: string, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, order?: ListOptionsContractsOrderEnum, limit?: number, sort?: ListOptionsContractsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listOptionsContracts(ticker, underlyingTicker, contractType, expirationDate, asOf, strikePrice, expired, underlyingTickerGte, underlyingTickerGt, underlyingTickerLte, underlyingTickerLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
     * @summary Stock Splits v3
     * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {string} [executionDate] Query by execution date with the format YYYY-MM-DD.
     * @param {boolean | null} [reverseSplit] Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {string} [executionDateGte] Range by execution_date.
     * @param {string} [executionDateGt] Range by execution_date.
     * @param {string} [executionDateLte] Range by execution_date.
     * @param {string} [executionDateLt] Range by execution_date.
     * @param {ListStockSplitsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListStockSplitsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listStockSplits(ticker?: string, executionDate?: string, reverseSplit?: boolean | null, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, executionDateGte?: string, executionDateGt?: string, executionDateLte?: string, executionDateLt?: string, order?: ListStockSplitsOrderEnum, limit?: number, sort?: ListStockSplitsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listStockSplits(ticker, executionDate, reverseSplit, tickerGte, tickerGt, tickerLte, tickerLt, executionDateGte, executionDateGt, executionDateLte, executionDateLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all ticker types that Polygon.io has.
     * @summary Ticker Types
     * @param {ListTickerTypesAssetClassEnum} [assetClass] Filter by asset class.
     * @param {ListTickerTypesLocaleEnum} [locale] Filter by locale.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTickerTypes(assetClass?: ListTickerTypesAssetClassEnum, locale?: ListTickerTypesLocaleEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listTickerTypes(assetClass, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
     * @summary Tickers
     * @param {string} [ticker] Specify a ticker symbol. Defaults to empty string which queries all tickers.
     * @param {ListTickersTypeEnum} [type] Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types). Defaults to empty string which queries all types.
     * @param {ListTickersMarketEnum} [market] Filter by market type. By default all markets are included.
     * @param {string} [exchange] Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes [at the ISO org website](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges.
     * @param {string} [cusip] Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
     * @param {string} [cik] Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs.
     * @param {string} [date] Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.
     * @param {string} [search] Search for terms within the ticker and/or company name.
     * @param {boolean} [active] Specify if the tickers returned should be actively traded on the queried date. Default is true.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {ListTickersOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 100 and max is 1000.
     * @param {ListTickersSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTickers(ticker?: string, type?: ListTickersTypeEnum, market?: ListTickersMarketEnum, exchange?: string, cusip?: string, cik?: string, date?: string, search?: string, active?: boolean, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: ListTickersOrderEnum, limit?: number, sort?: ListTickersSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listTickers(ticker, type, market, exchange, cusip, cik, date, search, active, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {MACDTimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [shortWindow] The short window size used to calculate MACD data.
     * @param {number} [longWindow] The long window size used to calculate MACD data.
     * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
     * @param {MACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {MACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mACD(stockTicker: string, timestamp?: string, timespan?: MACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: MACDSeriesTypeEnum, expandUnderlying?: boolean, order?: MACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mACD(stockTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the snapshot of an option contract for a stock equity.
     * @summary Option Contract
     * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
     * @param {string} optionContract The option contract identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public optionContract(underlyingAsset: string, optionContract: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).optionContract(underlyingAsset, optionContract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the snapshot of all options contracts for an underlying ticker.
     * @summary Options Chain
     * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
     * @param {number} [strikePrice] Query by strike price of a contract.
     * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
     * @param {OptionsChainContractTypeEnum} [contractType] Query by the type of contract.
     * @param {number} [strikePriceGte] Range by strike_price.
     * @param {number} [strikePriceGt] Range by strike_price.
     * @param {number} [strikePriceLte] Range by strike_price.
     * @param {number} [strikePriceLt] Range by strike_price.
     * @param {string} [expirationDateGte] Range by expiration_date.
     * @param {string} [expirationDateGt] Range by expiration_date.
     * @param {string} [expirationDateLte] Range by expiration_date.
     * @param {string} [expirationDateLt] Range by expiration_date.
     * @param {OptionsChainOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
     * @param {OptionsChainSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public optionsChain(underlyingAsset: string, strikePrice?: number, expirationDate?: string, contractType?: OptionsChainContractTypeEnum, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, order?: OptionsChainOrderEnum, limit?: number, sort?: OptionsChainSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).optionsChain(underlyingAsset, strikePrice, expirationDate, contractType, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {string} optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {OptionsEMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {OptionsEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {OptionsEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public optionsEMA(optionsTicker: string, timestamp?: string, timespan?: OptionsEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsEMASeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).optionsEMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {string} optionsTicker The ticker symbol for which to get MACD data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {OptionsMACDTimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [shortWindow] The short window size used to calculate MACD data.
     * @param {number} [longWindow] The long window size used to calculate MACD data.
     * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
     * @param {OptionsMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {OptionsMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public optionsMACD(optionsTicker: string, timestamp?: string, timespan?: OptionsMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: OptionsMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).optionsMACD(optionsTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {string} optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {OptionsRSITimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the relative strength index (RSI).
     * @param {OptionsRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {OptionsRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public optionsRSI(optionsTicker: string, timestamp?: string, timespan?: OptionsRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsRSISeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).optionsRSI(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {string} optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {OptionsSMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {OptionsSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {OptionsSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public optionsSMA(optionsTicker: string, timestamp?: string, timespan?: OptionsSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: OptionsSMASeriesTypeEnum, expandUnderlying?: boolean, order?: OptionsSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).optionsSMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get NBBO quotes for a ticker symbol in a given time range.
     * @summary Quotes (NBBO)
     * @param {string} stockTicker The ticker symbol to get quotes for.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {QuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {QuotesSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quotes(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesOrderEnum, limit?: number, sort?: QuotesSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).quotes(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get BBO quotes for a ticker symbol in a given time range.
     * @summary Quotes (BBO)
     * @param {string} fxTicker The ticker symbol to get quotes for.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {QuotesFxOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {QuotesFxSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quotesFx(fxTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesFxOrderEnum, limit?: number, sort?: QuotesFxSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).quotesFx(fxTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get quotes for an options ticker symbol in a given time range.
     * @summary Quotes
     * @param {string} optionsTicker The ticker symbol to get quotes for.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {QuotesOptionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {QuotesOptionsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quotesOptions(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: QuotesOptionsOrderEnum, limit?: number, sort?: QuotesOptionsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).quotesOptions(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {RSITimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the relative strength index (RSI).
     * @param {RSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {RSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rSI(stockTicker: string, timestamp?: string, timespan?: RSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: RSISeriesTypeEnum, expandUnderlying?: boolean, order?: RSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rSI(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
     * @summary Real-time Currency Conversion
     * @param {string} from The \&quot;from\&quot; symbol of the pair.
     * @param {string} to The \&quot;to\&quot; symbol of the pair.
     * @param {number} [amount] The amount to convert, with a decimal.
     * @param {RealTimeCurrencyConversionPrecisionEnum} [precision] The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public realTimeCurrencyConversion(from: string, to: string, amount?: number, precision?: RealTimeCurrencyConversionPrecisionEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).realTimeCurrencyConversion(from, to, amount, precision, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {SMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {SMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {SMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sMA(stockTicker: string, timestamp?: string, timespan?: SMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: SMASeriesTypeEnum, expandUnderlying?: boolean, order?: SMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
     * @summary Summaries
     * @param {string} [tickerAnyOf] Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://polygon.io/docs/stocks/get_v3_reference_tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public snapshotSummary(tickerAnyOf?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).snapshotSummary(tickerAnyOf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get snapshots for assets of all types
     * @summary Universal Snapshot
     * @param {string} [ticker] Search a range of tickers lexicographically.
     * @param {SnapshotsTypeEnum} [type] Query by the type of asset.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. 
     * @param {SnapshotsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
     * @param {SnapshotsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public snapshots(ticker?: string, type?: SnapshotsTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, tickerAnyOf?: string, order?: SnapshotsOrderEnum, limit?: number, sort?: SnapshotsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).snapshots(ticker, type, tickerGte, tickerGt, tickerLte, tickerLt, tickerAnyOf, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve finra_short_interest_v1 data via API.
     * @summary finra_short_interest_v1 API
     * @param {string} [ticker] The primary ticker symbol for the stock.
     * @param {string} [daysToCover] Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume.
     * @param {string} [settlementDate] The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
     * @param {string} [avgDailyVolume] The average daily trading volume for the stock over a specified period, typically used to contextualize short interest.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {string} [daysToCoverGte] Range by days_to_cover.
     * @param {string} [daysToCoverGt] Range by days_to_cover.
     * @param {string} [daysToCoverLte] Range by days_to_cover.
     * @param {string} [daysToCoverLt] Range by days_to_cover.
     * @param {string} [settlementDateGte] Range by settlement_date.
     * @param {string} [settlementDateGt] Range by settlement_date.
     * @param {string} [settlementDateLte] Range by settlement_date.
     * @param {string} [settlementDateLt] Range by settlement_date.
     * @param {string} [avgDailyVolumeGte] Range by avg_daily_volume.
     * @param {string} [avgDailyVolumeGt] Range by avg_daily_volume.
     * @param {string} [avgDailyVolumeLte] Range by avg_daily_volume.
     * @param {string} [avgDailyVolumeLt] Range by avg_daily_volume.
     * @param {StocksShortInterestOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 50000.
     * @param {StocksShortInterestSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stocksShortInterest(ticker?: string, daysToCover?: string, settlementDate?: string, avgDailyVolume?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, daysToCoverGte?: string, daysToCoverGt?: string, daysToCoverLte?: string, daysToCoverLt?: string, settlementDateGte?: string, settlementDateGt?: string, settlementDateLte?: string, settlementDateLt?: string, avgDailyVolumeGte?: string, avgDailyVolumeGt?: string, avgDailyVolumeLte?: string, avgDailyVolumeLt?: string, order?: StocksShortInterestOrderEnum, limit?: number, sort?: StocksShortInterestSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).stocksShortInterest(ticker, daysToCover, settlementDate, avgDailyVolume, tickerGte, tickerGt, tickerLte, tickerLt, daysToCoverGte, daysToCoverGt, daysToCoverLte, daysToCoverLt, settlementDateGte, settlementDateGt, settlementDateLte, settlementDateLt, avgDailyVolumeGte, avgDailyVolumeGt, avgDailyVolumeLte, avgDailyVolumeLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve finra_short_volume_v1 data via API.
     * @summary finra_short_volume_v1 API
     * @param {string} [ticker] The primary ticker symbol for the stock.
     * @param {string} [date] The date of trade activity reported in the format YYYY-MM-DD
     * @param {string} [shortVolumeRatio] The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100.
     * @param {string} [totalVolume] Total reported volume across all venues for the ticker on the given date.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {string} [dateGte] Range by date.
     * @param {string} [dateGt] Range by date.
     * @param {string} [dateLte] Range by date.
     * @param {string} [dateLt] Range by date.
     * @param {string} [shortVolumeRatioGte] Range by short_volume_ratio.
     * @param {string} [shortVolumeRatioGt] Range by short_volume_ratio.
     * @param {string} [shortVolumeRatioLte] Range by short_volume_ratio.
     * @param {string} [shortVolumeRatioLt] Range by short_volume_ratio.
     * @param {string} [totalVolumeGte] Range by total_volume.
     * @param {string} [totalVolumeGt] Range by total_volume.
     * @param {string} [totalVolumeLte] Range by total_volume.
     * @param {string} [totalVolumeLt] Range by total_volume.
     * @param {StocksShortVolumeOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 50000.
     * @param {StocksShortVolumeSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stocksShortVolume(ticker?: string, date?: string, shortVolumeRatio?: string, totalVolume?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, dateGte?: string, dateGt?: string, dateLte?: string, dateLt?: string, shortVolumeRatioGte?: string, shortVolumeRatioGt?: string, shortVolumeRatioLte?: string, shortVolumeRatioLt?: string, totalVolumeGte?: string, totalVolumeGt?: string, totalVolumeLte?: string, totalVolumeLt?: string, order?: StocksShortVolumeOrderEnum, limit?: number, sort?: StocksShortVolumeSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).stocksShortVolume(ticker, date, shortVolumeRatio, totalVolume, tickerGte, tickerGt, tickerLte, tickerLt, dateGte, dateGt, dateLte, dateLt, shortVolumeRatioGte, shortVolumeRatioGt, shortVolumeRatioLte, shortVolumeRatioLt, totalVolumeGte, totalVolumeGt, totalVolumeLte, totalVolumeLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a ticker symbol in a given time range.
     * @summary Trades
     * @param {string} stockTicker The ticker symbol to get trades for.
     * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {TradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {TradesSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public trades(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesOrderEnum, limit?: number, sort?: TradesSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).trades(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a crypto ticker symbol in a given time range.
     * @summary Trades
     * @param {string} cryptoTicker The ticker symbol to get trades for.
     * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {TradesCryptoOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {TradesCryptoSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tradesCrypto(cryptoTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesCryptoOrderEnum, limit?: number, sort?: TradesCryptoSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tradesCrypto(cryptoTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for an options ticker symbol in a given time range.
     * @summary Trades
     * @param {string} optionsTicker The options ticker symbol to get trades for.
     * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {TradesOptionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {TradesOptionsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tradesOptions(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: TradesOptionsOrderEnum, limit?: number, sort?: TradesOptionsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tradesOptions(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historic trade ticks for a cryptocurrency pair. 
     * @summary Historic Crypto Trades
     * @param {string} from The \&quot;from\&quot; symbol of the crypto pair.
     * @param {string} to The \&quot;to\&quot; symbol of the crypto pair.
     * @param {string} date The date/day of the historic ticks to retrieve.
     * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param {number} [limit] Limit the size of the response, max 10000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v1HistoricCryptoFromToDateGet(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v1HistoricCryptoFromToDateGet(from, to, date, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historic ticks for a forex currency pair. 
     * @summary Historic Forex Ticks
     * @param {string} from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
     * @param {string} to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
     * @param {string} date The date/day of the historic ticks to retrieve.
     * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param {number} [limit] Limit the size of the response, max 10000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v1HistoricForexFromToDateGet(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v1HistoricForexFromToDateGet(from, to, date, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close prices of a cryptocurrency symbol on a certain day. 
     * @summary Daily Open/Close
     * @param {string} from The \&quot;from\&quot; symbol of the pair.
     * @param {string} to The \&quot;to\&quot; symbol of the pair.
     * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v1OpenCloseCryptoFromToDateGet(from: string, to: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v1OpenCloseCryptoFromToDateGet(from, to, date, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close and afterhours values of a index symbol on a certain date. 
     * @summary Daily Open/Close
     * @param {string} indicesTicker The ticker symbol of Index.
     * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v1OpenCloseIndicesTickerDateGet(indicesTicker: string, date: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v1OpenCloseIndicesTickerDateGet(indicesTicker, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close and afterhours prices of an options contract on a certain date. 
     * @summary Daily Open/Close
     * @param {string} optionsTicker The ticker symbol of the options contract.
     * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v1OpenCloseOptionsTickerDateGet(optionsTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v1OpenCloseOptionsTickerDateGet(optionsTicker, date, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close and afterhours prices of a stock symbol on a certain date. 
     * @summary Daily Open/Close
     * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v1OpenCloseStocksTickerDateGet(stocksTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v1OpenCloseStocksTickerDateGet(stocksTicker, date, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
     * @summary Grouped Daily (Bars)
     * @param {string} date The beginning date for the aggregate window.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsGroupedLocaleGlobalMarketCryptoDateGet(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsGroupedLocaleGlobalMarketCryptoDateGet(date, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
     * @summary Grouped Daily (Bars)
     * @param {string} date The beginning date for the aggregate window.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsGroupedLocaleGlobalMarketFxDateGet(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsGroupedLocaleGlobalMarketFxDateGet(date, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
     * @summary Grouped Daily (Bars)
     * @param {string} date The beginning date for the aggregate window.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsGroupedLocaleUsMarketStocksDateGet(date: string, adjusted?: boolean, includeOtc?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsGroupedLocaleUsMarketStocksDateGet(date, adjusted, includeOtc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
     * @summary Previous Close
     * @param {string} cryptoTicker The ticker symbol of the currency pair.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsTickerCryptoTickerPrevGet(cryptoTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsTickerCryptoTickerPrevGet(cryptoTicker, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {string} cryptoTicker The ticker symbol of the currency pair.
     * @param {number} multiplier The size of the timespan multiplier.
     * @param {V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
     * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet(cryptoTicker: string, multiplier: number, timespan: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet(cryptoTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
     * @summary Previous Close
     * @param {string} forexTicker The ticker symbol of the currency pair.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsTickerForexTickerPrevGet(forexTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsTickerForexTickerPrevGet(forexTicker, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {string} forexTicker The ticker symbol of the currency pair.
     * @param {number} multiplier The size of the timespan multiplier.
     * @param {V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
     * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet(forexTicker: string, multiplier: number, timespan: V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsTickerForexTickerRangeMultiplierTimespanFromToGet(forexTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
     * @summary Previous Close
     * @param {string} indicesTicker The ticker symbol of Index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsTickerIndicesTickerPrevGet(indicesTicker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsTickerIndicesTickerPrevGet(indicesTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {string} indicesTicker The ticker symbol of Index.
     * @param {number} multiplier The size of the timespan multiplier.
     * @param {V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
     * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet(indicesTicker: string, multiplier: number, timespan: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, sort?: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet(indicesTicker, multiplier, timespan, from, to, sort, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
     * @summary Previous Close
     * @param {string} optionsTicker The ticker symbol of the options contract.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsTickerOptionsTickerPrevGet(optionsTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsTickerOptionsTickerPrevGet(optionsTicker, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {string} optionsTicker The ticker symbol of the options contract.
     * @param {number} multiplier The size of the timespan multiplier.
     * @param {V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
     * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet(optionsTicker: string, multiplier: number, timespan: V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGet(optionsTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
     * @summary Previous Close
     * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsTickerStocksTickerPrevGet(stocksTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsTickerStocksTickerPrevGet(stocksTicker, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {number} multiplier The size of the timespan multiplier.
     * @param {V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetTimespanEnum} timespan The size of the time window.
     * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet(stocksTicker: string, multiplier: number, timespan: V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetSortEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2AggsTickerStocksTickerRangeMultiplierTimespanFromToGet(stocksTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Gainers/Losers
     * @param {V2SnapshotLocaleGlobalMarketsCryptoDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2SnapshotLocaleGlobalMarketsCryptoDirectionGet(direction: V2SnapshotLocaleGlobalMarketsCryptoDirectionGetDirectionEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2SnapshotLocaleGlobalMarketsCryptoDirectionGet(direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary All Tickers
     * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2SnapshotLocaleGlobalMarketsCryptoTickersGet(tickers?: Array<string>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2SnapshotLocaleGlobalMarketsCryptoTickersGet(tickers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Ticker Full Book (L2)
     * @param {string} ticker The cryptocurrency ticker.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet(ticker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet(ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Ticker
     * @param {string} ticker Ticker of the snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet(ticker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet(ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Gainers/Losers
     * @param {V2SnapshotLocaleGlobalMarketsForexDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2SnapshotLocaleGlobalMarketsForexDirectionGet(direction: V2SnapshotLocaleGlobalMarketsForexDirectionGetDirectionEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2SnapshotLocaleGlobalMarketsForexDirectionGet(direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary All Tickers
     * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2SnapshotLocaleGlobalMarketsForexTickersGet(tickers?: Array<string>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2SnapshotLocaleGlobalMarketsForexTickersGet(tickers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Ticker
     * @param {string} ticker The forex ticker.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2SnapshotLocaleGlobalMarketsForexTickersTickerGet(ticker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2SnapshotLocaleGlobalMarketsForexTickersTickerGet(ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
     * @summary Gainers/Losers
     * @param {V2SnapshotLocaleUsMarketsStocksDirectionGetDirectionEnum} direction The direction of the snapshot results to return. 
     * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2SnapshotLocaleUsMarketsStocksDirectionGet(direction: V2SnapshotLocaleUsMarketsStocksDirectionGetDirectionEnum, includeOtc?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2SnapshotLocaleUsMarketsStocksDirectionGet(direction, includeOtc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary All Tickers
     * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
     * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2SnapshotLocaleUsMarketsStocksTickersGet(tickers?: Array<string>, includeOtc?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2SnapshotLocaleUsMarketsStocksTickersGet(tickers, includeOtc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary Ticker
     * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet(stocksTicker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2SnapshotLocaleUsMarketsStocksTickersStocksTickerGet(stocksTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get NBBO quotes for a given ticker symbol on a specified date. 
     * @summary Quotes (NBBO)
     * @param {string} ticker The ticker symbol we want quotes for.
     * @param {string} date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
     * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
     * @param {boolean} [reverse] Reverse the order of the results. 
     * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TicksStocksNbboTickerDateGet(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TicksStocksNbboTickerDateGet(ticker, date, timestamp, timestampLimit, reverse, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a given ticker symbol on a specified date. 
     * @summary Trades
     * @param {string} ticker The ticker symbol we want trades for.
     * @param {string} date The date/day of the trades to retrieve in the format YYYY-MM-DD.
     * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
     * @param {boolean} [reverse] Reverse the order of the results. 
     * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v2TicksStocksTradesTickerDateGet(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v2TicksStocksTradesTickerDateGet(ticker, date, timestamp, timestampLimit, reverse, limit, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum BenzingaEarningsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum BenzingaEarningsSortEnum {
    Date = 'date',
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum BenzingaNewsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum BenzingaNewsSortEnum {
    Created = 'created'
}
/**
  * @export
  * @enum {string}
  */
export enum BenzingaRatingsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum BenzingaRatingsSortEnum {
    Date = 'date',
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum CryptoSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum EMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum EMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum EMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum ForexSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesSnapshotOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum IndicesSnapshotSortEnum {
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsDataTypeEnum {
    Trade = 'trade',
    Bbo = 'bbo',
    Nbbo = 'nbbo'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsSipEnum {
    Cta = 'CTA',
    Utp = 'UTP',
    Opra = 'OPRA'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsSortEnum {
    AssetClass = 'asset_class',
    Id = 'id',
    Type = 'type',
    Name = 'name',
    DataTypes = 'data_types',
    Legacy = 'legacy'
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsFrequencyEnum {
    NUMBER_0 = 0,
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_4 = 4,
    NUMBER_12 = 12,
    NUMBER_24 = 24,
    NUMBER_52 = 52
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsDividendTypeEnum {
    Cd = 'CD',
    Sc = 'SC',
    Lt = 'LT',
    St = 'ST'
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsSortEnum {
    ExDividendDate = 'ex_dividend_date',
    PayDate = 'pay_date',
    DeclarationDate = 'declaration_date',
    RecordDate = 'record_date',
    CashAmount = 'cash_amount',
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum ListExchangesAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx'
}
/**
  * @export
  * @enum {string}
  */
export enum ListExchangesLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
  * @export
  * @enum {string}
  */
export enum ListFinancialsTimeframeEnum {
    Annual = 'annual',
    Quarterly = 'quarterly',
    Ttm = 'ttm'
}
/**
  * @export
  * @enum {string}
  */
export enum ListFinancialsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListFinancialsSortEnum {
    FilingDate = 'filing_date',
    PeriodOfReportDate = 'period_of_report_date'
}
/**
  * @export
  * @enum {string}
  */
export enum ListIPOsIpoStatusEnum {
    DirectListingProcess = 'direct_listing_process',
    History = 'history',
    New = 'new',
    Pending = 'pending',
    Postponed = 'postponed',
    Rumor = 'rumor',
    Withdrawn = 'withdrawn'
}
/**
  * @export
  * @enum {string}
  */
export enum ListIPOsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListIPOsSortEnum {
    ListingDate = 'listing_date',
    Ticker = 'ticker',
    LastUpdated = 'last_updated',
    SecurityType = 'security_type',
    IssuerName = 'issuer_name',
    CurrencyCode = 'currency_code',
    Isin = 'isin',
    UsCode = 'us_code',
    FinalIssuePrice = 'final_issue_price',
    MinSharesOffered = 'min_shares_offered',
    MaxSharesOffered = 'max_shares_offered',
    LowestOfferPrice = 'lowest_offer_price',
    HighestOfferPrice = 'highest_offer_price',
    TotalOfferSize = 'total_offer_size',
    SharesOutstanding = 'shares_outstanding',
    PrimaryExchange = 'primary_exchange',
    LotSize = 'lot_size',
    SecurityDescription = 'security_description',
    IpoStatus = 'ipo_status',
    AnnouncedDate = 'announced_date'
}
/**
  * @export
  * @enum {string}
  */
export enum ListNewsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListNewsSortEnum {
    PublishedUtc = 'published_utc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListOptionsContractsContractTypeEnum {
    Call = 'call',
    Put = 'put'
}
/**
  * @export
  * @enum {string}
  */
export enum ListOptionsContractsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListOptionsContractsSortEnum {
    Ticker = 'ticker',
    UnderlyingTicker = 'underlying_ticker',
    ExpirationDate = 'expiration_date',
    StrikePrice = 'strike_price'
}
/**
  * @export
  * @enum {string}
  */
export enum ListStockSplitsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListStockSplitsSortEnum {
    ExecutionDate = 'execution_date',
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickerTypesAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx',
    Indices = 'indices'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickerTypesLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersTypeEnum {
    Cs = 'CS',
    Adrc = 'ADRC',
    Adrp = 'ADRP',
    Adrr = 'ADRR',
    Unit = 'UNIT',
    Right = 'RIGHT',
    Pfd = 'PFD',
    Fund = 'FUND',
    Sp = 'SP',
    Warrant = 'WARRANT',
    Index = 'INDEX',
    Etf = 'ETF',
    Etn = 'ETN',
    Os = 'OS',
    Gdr = 'GDR',
    Other = 'OTHER',
    Nyrs = 'NYRS',
    Agen = 'AGEN',
    Eqlk = 'EQLK',
    Bond = 'BOND',
    Adrw = 'ADRW',
    Basket = 'BASKET',
    Lt = 'LT'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersMarketEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Fx = 'fx',
    Otc = 'otc',
    Indices = 'indices'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersSortEnum {
    Ticker = 'ticker',
    Name = 'name',
    Market = 'market',
    Locale = 'locale',
    PrimaryExchange = 'primary_exchange',
    Type = 'type',
    CurrencySymbol = 'currency_symbol',
    CurrencyName = 'currency_name',
    BaseCurrencySymbol = 'base_currency_symbol',
    BaseCurrencyName = 'base_currency_name',
    Cik = 'cik',
    CompositeFigi = 'composite_figi',
    ShareClassFigi = 'share_class_figi',
    LastUpdatedUtc = 'last_updated_utc',
    DelistedUtc = 'delisted_utc'
}
/**
  * @export
  * @enum {string}
  */
export enum MACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum MACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum MACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsChainContractTypeEnum {
    Call = 'call',
    Put = 'put'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsChainOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsChainSortEnum {
    Ticker = 'ticker',
    ExpirationDate = 'expiration_date',
    StrikePrice = 'strike_price'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum OptionsSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum QuotesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum QuotesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum QuotesFxOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum QuotesFxSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum QuotesOptionsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum QuotesOptionsSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum RSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum RSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum RSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum RealTimeCurrencyConversionPrecisionEnum {
    NUMBER_0 = 0,
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3,
    NUMBER_4 = 4
}
/**
  * @export
  * @enum {string}
  */
export enum SMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum SMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum SMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum SnapshotsTypeEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx',
    Indices = 'indices'
}
/**
  * @export
  * @enum {string}
  */
export enum SnapshotsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum SnapshotsSortEnum {
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum StocksShortInterestOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum StocksShortInterestSortEnum {
    Ticker = 'ticker',
    SettlementDate = 'settlement_date',
    DaysToCover = 'days_to_cover',
    AvgDailyVolume = 'avg_daily_volume'
}
/**
  * @export
  * @enum {string}
  */
export enum StocksShortVolumeOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum StocksShortVolumeSortEnum {
    Ticker = 'ticker',
    Date = 'date',
    ShortVolumeRatio = 'short_volume_ratio',
    TotalVolume = 'total_volume'
}
/**
  * @export
  * @enum {string}
  */
export enum TradesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum TradesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum TradesCryptoOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum TradesCryptoSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum TradesOptionsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum TradesOptionsSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum V2AggsTickerForexTickerRangeMultiplierTimespanFromToGetSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum V2AggsTickerOptionsTickerRangeMultiplierTimespanFromToGetSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum V2AggsTickerStocksTickerRangeMultiplierTimespanFromToGetSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum V2SnapshotLocaleGlobalMarketsCryptoDirectionGetDirectionEnum {
    Gainers = 'gainers',
    Losers = 'losers'
}
/**
  * @export
  * @enum {string}
  */
export enum V2SnapshotLocaleGlobalMarketsForexDirectionGetDirectionEnum {
    Gainers = 'gainers',
    Losers = 'losers'
}
/**
  * @export
  * @enum {string}
  */
export enum V2SnapshotLocaleUsMarketsStocksDirectionGetDirectionEnum {
    Gainers = 'gainers',
    Losers = 'losers'
}


