/* tslint:disable */
/* eslint-disable */
/**
 * Polygon API
 * The future of fintech.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Company
 */
export interface Company {
    /**
     * Indicates if the security is actively listed.  If false, this means the company is no longer listed and cannot be traded.
     * @type {boolean}
     * @memberof Company
     */
    'active'?: boolean;
    /**
     * The Bloomberg guid for the symbol.
     * @type {string}
     * @memberof Company
     */
    'bloomberg'?: string;
    /**
     * The name of the company\'s current CEO.
     * @type {string}
     * @memberof Company
     */
    'ceo'?: string;
    /**
     * The official CIK guid used for SEC database/filings.
     * @type {string}
     * @memberof Company
     */
    'cik'?: string;
    /**
     * The country in which the company is registered.
     * @type {string}
     * @memberof Company
     */
    'country'?: string;
    /**
     * A description of the company and what they do/offer.
     * @type {string}
     * @memberof Company
     */
    'description'?: string;
    /**
     * The approximate number of employees for the company.
     * @type {number}
     * @memberof Company
     */
    'employees'?: number;
    /**
     * The symbol\'s primary exchange.
     * @type {string}
     * @memberof Company
     */
    'exchange'?: string;
    /**
     * The exchange code (id) of the symbol\'s primary exchange.
     * @type {string}
     * @memberof Company
     */
    'exchangeSymbol'?: string;
    /**
     * The OpenFigi project guid for the symbol. (<a rel=\"nofollow\" target=\"_blank\" href=\"https://openfigi.com/\">https://openfigi.com/</a>)
     * @type {string}
     * @memberof Company
     */
    'figi'?: string;
    /**
     * The street address for the company\'s headquarters.
     * @type {string}
     * @memberof Company
     */
    'hq_address'?: string;
    /**
     * The country in which the company\'s headquarters is located.
     * @type {string}
     * @memberof Company
     */
    'hq_country'?: string;
    /**
     * The state in which the company\'s headquarters is located.
     * @type {string}
     * @memberof Company
     */
    'hq_state'?: string;
    /**
     * The industry in which the company operates.
     * @type {string}
     * @memberof Company
     */
    'industry'?: string;
    /**
     * The Legal Entity Identifier (LEI) guid for the symbol. (<a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Legal_Entity_Identifier\">https://en.wikipedia.org/wiki/Legal_Entity_Identifier</a>)
     * @type {string}
     * @memberof Company
     */
    'lei'?: string;
    /**
     * The date that the symbol was listed on the exchange.
     * @type {string}
     * @memberof Company
     */
    'listdate'?: string;
    /**
     * The URL of the entity\'s logo.
     * @type {string}
     * @memberof Company
     */
    'logo'?: string;
    /**
     * The current market cap for the company.
     * @type {number}
     * @memberof Company
     */
    'marketcap'?: number;
    /**
     * The name of the company/entity.
     * @type {string}
     * @memberof Company
     */
    'name'?: string;
    /**
     * The phone number for the company. This is usually a corporate contact number.
     * @type {string}
     * @memberof Company
     */
    'phone'?: string;
    /**
     * The sector of the indsutry in which the symbol operates.
     * @type {string}
     * @memberof Company
     */
    'sector'?: string;
    /**
     * Standard Industrial Classification (SIC) id for the symbol. (<a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Standard_Industrial_Classification\">https://en.wikipedia.org/wiki/Legal_Entity_Identifier</a>)
     * @type {number}
     * @memberof Company
     */
    'sic'?: number;
    /**
     * A list of ticker symbols for similar companies.
     * @type {Array<string>}
     * @memberof Company
     */
    'similar'?: Array<string>;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof Company
     */
    'symbol'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Company
     */
    'tags'?: Array<string>;
    /**
     * The type or class of the security.  (<a alt=\"Full List of Ticker Types\" href=\"https://polygon.io/docs/stocks/get_v3_reference_tickers_types\">Full List of Ticker Types</a>)
     * @type {string}
     * @memberof Company
     */
    'type'?: string;
    /**
     * The last time this company record was updated.
     * @type {string}
     * @memberof Company
     */
    'updated'?: string;
    /**
     * The URL of the company\'s website
     * @type {string}
     * @memberof Company
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ConditionTypeMap
 */
export interface ConditionTypeMap {
    /**
     * Polygon.io\'s mapping for condition codes.  For more information, see our <a href=\"https://polygon.io/glossary/us/stocks/trade-conditions\" alt=\"Trade Conditions Glossary\" target=\"_blank\">Trade Conditions Glossary</a>. 
     * @type {string}
     * @memberof ConditionTypeMap
     */
    'condition'?: string;
}
/**
 * 
 * @export
 * @interface CryptoExchangeInner
 */
export interface CryptoExchangeInner {
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof CryptoExchangeInner
     */
    'id': number;
    /**
     * Market data type this exchange contains ( crypto only currently )
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'market': string;
    /**
     * Name of the exchange
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'name': string;
    /**
     * Type of exchange feed
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'type': string;
    /**
     * URL of this exchange
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CryptoGroupedResults
 */
export interface CryptoGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof CryptoGroupedResults
     */
    'results'?: Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface CryptoHistoricTrades
 */
export interface CryptoHistoricTrades {
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof CryptoHistoricTrades
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof CryptoHistoricTrades
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof CryptoHistoricTrades
     */
    'msLatency': number;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof CryptoHistoricTrades
     */
    'symbol': string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof CryptoHistoricTrades
     */
    'ticks': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface CryptoLastTrade
 */
export interface CryptoLastTrade {
    /**
     * 
     * @type {CryptoLastTradeLast}
     * @memberof CryptoLastTrade
     */
    'last'?: CryptoLastTradeLast;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof CryptoLastTrade
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface CryptoLastTradeLast
 */
export interface CryptoLastTradeLast {
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof CryptoLastTradeLast
     */
    'conditions': Array<number>;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'exchange': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'price': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'size': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface CryptoOpenClose
 */
export interface CryptoOpenClose {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoOpenClose
     */
    'close': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof CryptoOpenClose
     */
    'closingTrades': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
    /**
     * The date requested.
     * @type {string}
     * @memberof CryptoOpenClose
     */
    'day': string;
    /**
     * Whether or not the timestamps are in UTC timezone.
     * @type {boolean}
     * @memberof CryptoOpenClose
     */
    'isUTC': boolean;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoOpenClose
     */
    'open': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof CryptoOpenClose
     */
    'openTrades': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof CryptoOpenClose
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotMinute
 */
export interface CryptoSnapshotMinute {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotTicker
 */
export interface CryptoSnapshotTicker {
    /**
     * 
     * @type {GetCryptoSnapshotTicker200ResponseAllOfTicker}
     * @memberof CryptoSnapshotTicker
     */
    'ticker'?: GetCryptoSnapshotTicker200ResponseAllOfTicker;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotTickerFullBook
 */
export interface CryptoSnapshotTickerFullBook {
    /**
     * 
     * @type {DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData}
     * @memberof CryptoSnapshotTickerFullBook
     */
    'data'?: DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotTickers
 */
export interface CryptoSnapshotTickers {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof CryptoSnapshotTickers
     */
    'tickers'?: Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface CryptoTick
 */
export interface CryptoTick {
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof CryptoTick
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof CryptoTick
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof CryptoTick
     */
    'p': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof CryptoTick
     */
    's': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof CryptoTick
     */
    't': number;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof CryptoTick
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface DeprecatedGetCryptoSnapshotTickerBook200Response
 */
export interface DeprecatedGetCryptoSnapshotTickerBook200Response {
    /**
     * 
     * @type {DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200Response
     */
    'data'?: DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData;
}
/**
 * 
 * @export
 * @interface DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
 */
export interface DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData {
    /**
     * The combined total number of asks in the book.
     * @type {number}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'askCount': number;
    /**
     * 
     * @type {Array<DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner>}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'asks': Array<DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner>;
    /**
     * The combined total number of bids in the book.
     * @type {number}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'bidCount': number;
    /**
     * 
     * @type {Array<DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner>}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'bids': Array<DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner>;
    /**
     * The difference between the best bid and the best ask price across exchanges.
     * @type {number}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'spread': number;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'ticker': string;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner
 */
export interface DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner {
    /**
     * The price of this book level.
     * @type {number}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner
     */
    'p': number;
    /**
     * A map of the exchange ID to number of shares at this price level. <br /> <br /> **Example:** <br /> `{   \"p\": 16302.94,   \"x\": {     \"1\": 0.02859424,     \"6\": 0.023455   } }` <br /> <br /> In this example, exchange ID 1 has 0.02859424 shares available at $16,302.94, and exchange ID 6 has 0.023455 shares at the same price level. 
     * @type {object}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner
     */
    'x': object;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricCryptoTrades200Response
 */
export interface DeprecatedGetHistoricCryptoTrades200Response {
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof DeprecatedGetHistoricCryptoTrades200Response
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof DeprecatedGetHistoricCryptoTrades200Response
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof DeprecatedGetHistoricCryptoTrades200Response
     */
    'msLatency': number;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof DeprecatedGetHistoricCryptoTrades200Response
     */
    'symbol': string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof DeprecatedGetHistoricCryptoTrades200Response
     */
    'ticks': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
 */
export interface DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner {
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    'p': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    's': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    't': number;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricForexQuotes200Response
 */
export interface DeprecatedGetHistoricForexQuotes200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'status': string;
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'msLatency': number;
    /**
     * The currency pair that was evaluated from the request.
     * @type {string}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'pair': string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner>}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'ticks': Array<DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner
 */
export interface DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner {
    /**
     * The ask price.
     * @type {number}
     * @memberof DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner
     */
    'a': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner
     */
    'b': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/forex/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricStocksQuotes200Response
 */
export interface DeprecatedGetHistoricStocksQuotes200Response {
    /**
     * Latency in milliseconds for the query results from the database.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200Response
     */
    'db_latency'?: number;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200Response
     */
    'results_count'?: number;
    /**
     * Whether or not this query was executed successfully.
     * @type {boolean}
     * @memberof DeprecatedGetHistoricStocksQuotes200Response
     */
    'success'?: boolean;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof DeprecatedGetHistoricStocksQuotes200Response
     */
    'ticker'?: string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner>}
     * @memberof DeprecatedGetHistoricStocksQuotes200Response
     */
    'results'?: Array<DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
 */
export interface DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'y': number;
    /**
     * The ask price.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'P': number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'S': number;
    /**
     * The ask exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'X': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'c': Array<number>;
    /**
     * The indicators. For more information, see our glossary of [Conditions and Indicators](https://polygon.io/glossary/us/stocks/conditions-indicators). 
     * @type {Array<number>}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'i': Array<number>;
    /**
     * The bid price.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'p': number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    's': number;
    /**
     * The bid exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricStocksTrades200Response
 */
export interface DeprecatedGetHistoricStocksTrades200Response {
    /**
     * Latency in milliseconds for the query results from the database.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200Response
     */
    'db_latency'?: number;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200Response
     */
    'results_count'?: number;
    /**
     * Whether or not this query was executed successfully.
     * @type {boolean}
     * @memberof DeprecatedGetHistoricStocksTrades200Response
     */
    'success'?: boolean;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof DeprecatedGetHistoricStocksTrades200Response
     */
    'ticker'?: string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner>}
     * @memberof DeprecatedGetHistoricStocksTrades200Response
     */
    'results'?: Array<DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
 */
export interface DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'y': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'c': Array<number>;
    /**
     * The trade correction indicator. 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'e': number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'p': number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place. 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'r': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    's': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface ExchangeInner
 */
export interface ExchangeInner {
    /**
     * A unique identifier for the exchange internal to Polygon.io.  This is not an industry code or ISO standard.
     * @type {string}
     * @memberof ExchangeInner
     */
    'code'?: string;
    /**
     * The ID of the exchange.
     * @type {number}
     * @memberof ExchangeInner
     */
    'id'?: number;
    /**
     * The market data type that this exchange contains.
     * @type {string}
     * @memberof ExchangeInner
     */
    'market'?: string;
    /**
     * The Market Identification Code or MIC as defined in ISO 10383 (<a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Market_Identifier_Code\">https://en.wikipedia.org/wiki/Market_Identifier_Code</a>).
     * @type {string}
     * @memberof ExchangeInner
     */
    'mic'?: string;
    /**
     * The name of the exchange.
     * @type {string}
     * @memberof ExchangeInner
     */
    'name'?: string;
    /**
     * The tape id of the exchange.
     * @type {string}
     * @memberof ExchangeInner
     */
    'tape'?: string;
    /**
     * The type of exchange. - TRF = Trade Reporting Facility - exchange = Reporting exchange on the tape 
     * @type {string}
     * @memberof ExchangeInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Financial
 */
export interface Financial {
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'cashChange'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'cashFlow'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'costOfRevenue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'currentAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'currentCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'currentDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'grossProfit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'netIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingGainsLosses'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingRevenue'?: number;
    /**
     * Report Date
     * @type {string}
     * @memberof Financial
     */
    'reportDate': string;
    /**
     * Report date as non date format
     * @type {string}
     * @memberof Financial
     */
    'reportDateStr': string;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'researchAndDevelopment'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'shareholderEquity'?: number;
    /**
     * Stock Symbol
     * @type {string}
     * @memberof Financial
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalLiabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalRevenue'?: number;
}
/**
 * Financials
 * @export
 * @interface Financials
 */
export interface Financials {
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'EBITDAMargin'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'accumulatedOtherComprehensiveIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'accumulatedRetainedEarningsDeficit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetTurnover'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetsAverage'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetsCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetsNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'averageEquity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'bookValuePerShare'?: number;
    /**
     * 
     * @type {string}
     * @memberof Financials
     */
    'calendarDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'capitalExpenditure'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'cashAndEquivalents'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'cashAndEquivalentsUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'consolidatedIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'costOfRevenue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'currentLiabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'currentRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtToEquityRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'deferredRevenue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'deposits'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'depreciationAmortizationAndAccretion'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'dividendYield'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'dividendsPerBasicCommonShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningBeforeInterestTaxes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningBeforeInterestTaxesUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsBeforeInterestTaxesDepreciationAmortization'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsBeforeInterestTaxesDepreciationAmortizationUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsBeforeTax'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsPerBasicShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsPerBasicShareUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsPerDilutedShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'effectOfExchangeRateChangesOnCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'enterpriseValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'enterpriseValueOverEBIT'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'enterpriseValueOverEBITDA'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'foreignCurrencyUSDExchangeRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'freeCashFlow'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'freeCashFlowPerShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'goodwillAndIntangibleAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'grossMargin'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'grossProfit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'incomeTaxExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'interestExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'inventory'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investedCapital'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investedCapitalAverage'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investments'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investmentsCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investmentsNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'issuanceDebtSecurities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'issuanceEquityShares'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'liabilitiesNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'marketCapitalization'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlow'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowBusinessAcquisitionsDisposals'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowFromFinancing'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowFromInvesting'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowFromOperations'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowInvestmentAcquisitionsDisposals'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncomeCommonStock'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncomeCommonStockUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncomeToNonControllingInterests'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netLossIncomeFromDiscontinuedOperations'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'operatingExpenses'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'operatingIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'paymentDividendsOtherCashDistributions'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'payoutRatio'?: number;
    /**
     * Reporting period.
     * @type {string}
     * @memberof Financials
     */
    'period'?: FinancialsPeriodEnum;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'preferredDividendsIncomeStatementImpact'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceEarnings'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceSales'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceToBookValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceToEarningsRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceToSalesRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'profitMargin'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'propertyPlantEquipmentNet'?: number;
    /**
     * 
     * @type {string}
     * @memberof Financials
     */
    'reportPeriod'?: string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'researchAndDevelopmentExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnAverageAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnAverageEquity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnInvestedCapital'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnSales'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'revenues'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'revenuesUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'salesPerShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'sellingGeneralAndAdministrativeExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareBasedCompensation'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareFactor'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'sharePriceAdjustedClose'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareholdersEquity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareholdersEquityUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shares'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tangibleAssetValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tangibleAssetsBookValuePerShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'taxAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'taxLiabilities'?: number;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof Financials
     */
    'ticker': string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'totalLiabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tradeAndNonTradePayables'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tradeAndNonTradeReceivables'?: number;
    /**
     * 
     * @type {string}
     * @memberof Financials
     */
    'updated'?: string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'weightedAverageShares'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'weightedAverageSharesDiluted'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'workingCapital'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum FinancialsPeriodEnum {
    Q = 'Q',
    T = 'T',
    Qa = 'QA',
    Ta = 'TA',
    Y = 'Y',
    Ya = 'YA'
}

/**
 * 
 * @export
 * @interface ForexConversion
 */
export interface ForexConversion {
    /**
     * The result of the conversion.
     * @type {number}
     * @memberof ForexConversion
     */
    'converted': number;
    /**
     * The \"from\" currency symbol.
     * @type {string}
     * @memberof ForexConversion
     */
    'from': string;
    /**
     * The amount to convert.
     * @type {number}
     * @memberof ForexConversion
     */
    'initialAmount': number;
    /**
     * 
     * @type {ForexConversionLast}
     * @memberof ForexConversion
     */
    'last'?: ForexConversionLast;
    /**
     * The \"to\" currency symbol.
     * @type {string}
     * @memberof ForexConversion
     */
    'to': string;
}
/**
 * 
 * @export
 * @interface ForexConversionLast
 */
export interface ForexConversionLast {
    /**
     * The ask price.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'ask': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'bid': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/forex/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'exchange': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface ForexGroupedResults
 */
export interface ForexGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof ForexGroupedResults
     */
    'results'?: Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface ForexHistoricTrades
 */
export interface ForexHistoricTrades {
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof ForexHistoricTrades
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof ForexHistoricTrades
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof ForexHistoricTrades
     */
    'msLatency': number;
    /**
     * The currency pair that was evaluated from the request.
     * @type {string}
     * @memberof ForexHistoricTrades
     */
    'pair': string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner>}
     * @memberof ForexHistoricTrades
     */
    'ticks': Array<DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface ForexPairLastQuote
 */
export interface ForexPairLastQuote {
    /**
     * 
     * @type {ForexConversionLast}
     * @memberof ForexPairLastQuote
     */
    'last'?: ForexConversionLast;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof ForexPairLastQuote
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface ForexPreviousClose
 */
export interface ForexPreviousClose {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetPreviousForexAggregates200ResponseAllOfResultsInner>}
     * @memberof ForexPreviousClose
     */
    'results'?: Array<GetPreviousForexAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface ForexSnapshotLastQuote
 */
export interface ForexSnapshotLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    'a': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    'b': number;
    /**
     * The millisecond accuracy timestamp of the quote.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    't': number;
    /**
     * The exchange ID on which this quote happened.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface ForexSnapshotPrevDay
 */
export interface ForexSnapshotPrevDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface ForexSnapshotTicker
 */
export interface ForexSnapshotTicker {
    /**
     * 
     * @type {GetForexSnapshotTicker200ResponseAllOfTicker}
     * @memberof ForexSnapshotTicker
     */
    'ticker'?: GetForexSnapshotTicker200ResponseAllOfTicker;
}
/**
 * 
 * @export
 * @interface ForexSnapshotTickers
 */
export interface ForexSnapshotTickers {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetForexSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof ForexSnapshotTickers
     */
    'tickers'?: Array<GetForexSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface ForexTickerResults
 */
export interface ForexTickerResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof ForexTickerResults
     */
    'results'?: Array<GetCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1AnalystInsights200Response
 */
export interface GetBenzingaV1AnalystInsights200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1AnalystInsights200ResponseResultsInner>}
     * @memberof GetBenzingaV1AnalystInsights200Response
     */
    'results': Array<GetBenzingaV1AnalystInsights200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200Response
     */
    'status': GetBenzingaV1AnalystInsights200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1AnalystInsights200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1AnalystInsights200ResponseResultsInner
 */
export interface GetBenzingaV1AnalystInsights200ResponseResultsInner {
    /**
     * The identifer used by Benzinga for the firm record.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'benzinga_firm_id'?: string;
    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * The identifier used by Benzinga for the rating record.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'benzinga_rating_id'?: string;
    /**
     * The name of the company being rated.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'company_name'?: string;
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'date'?: string;
    /**
     * The name of the research firm or investment bank issuing the rating.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'firm'?: string;
    /**
     * Narrative commentary or reasoning provided by the analyst or firm to explain the rating or price target.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'insight'?: string;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The current price target set by the analyst.
     * @type {number}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'price_target'?: number;
    /**
     * The current rating set by the analyst.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'rating'?: string;
    /**
     * The description of the change in rating from the firm\'s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'rating_action'?: string;
    /**
     * The stock symbol of the company being rated.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1AnalystInsights400Response
 */
export interface GetBenzingaV1AnalystInsights400Response {
    /**
     * A message describing the source of the error.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights400Response
     */
    'error': string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights400Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights400Response
     */
    'status': GetBenzingaV1AnalystInsights400ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1AnalystInsights400ResponseStatusEnum {
    Error = 'ERROR'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Analysts200Response
 */
export interface GetBenzingaV1Analysts200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1Analysts200ResponseResultsInner>}
     * @memberof GetBenzingaV1Analysts200Response
     */
    'results': Array<GetBenzingaV1Analysts200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200Response
     */
    'status': GetBenzingaV1Analysts200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1Analysts200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Analysts200ResponseResultsInner
 */
export interface GetBenzingaV1Analysts200ResponseResultsInner {
    /**
     * The unique identifier assigned by Benzinga to the research firm or investment bank.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'benzinga_firm_id'?: string;
    /**
     * The identifier used by Benzinga for this record.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * The name of the research firm or investment bank issuing the ratings.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'firm_name'?: string;
    /**
     * The full name of the analyst associated with the ratings.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'full_name'?: string;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the analyst record was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The average percent price difference per rating since the date of recommendation.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'overall_avg_return'?: number;
    /**
     * The analyst\'s percentile rank based on average return, relative to other analysts.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'overall_avg_return_percentile'?: number;
    /**
     * The percentage of gain/loss ratings that resulted in a gain overall.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'overall_success_rate'?: number;
    /**
     * A weighted average of the total_ratings_percentile, overall_avg_return_percentile, and overall_success_rate.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'smart_score'?: number;
    /**
     * The total number of ratings issued by the analyst included in the performance calculation.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'total_ratings'?: number;
    /**
     * The analyst\'s percentile rank based on the total number of ratings issued, relative to other analysts.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'total_ratings_percentile'?: number;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1ConsensusRatings200Response
 */
export interface GetBenzingaV1ConsensusRatings200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1ConsensusRatings200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1ConsensusRatings200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1ConsensusRatings200ResponseResultsInner>}
     * @memberof GetBenzingaV1ConsensusRatings200Response
     */
    'results': Array<GetBenzingaV1ConsensusRatings200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1ConsensusRatings200Response
     */
    'status': GetBenzingaV1ConsensusRatings200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1ConsensusRatings200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1ConsensusRatings200ResponseResultsInner
 */
export interface GetBenzingaV1ConsensusRatings200ResponseResultsInner {
    /**
     * The count of \'Buy\' ratings from contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'buy_ratings': number;
    /**
     * The average price target across all analysts, rounded to 2 decimal places.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'consensus_price_target'?: number;
    /**
     * The overall rating category determined by the average consensus weight. Possible values: \'strong_buy\', \'buy\', \'hold\', \'sell\', \'strong_sell\'.
     * @type {string}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'consensus_rating'?: string;
    /**
     * The numerical average of all consensus weights, rounded to 2 decimal places. Scale ranges from 1 (Strong Sell) to 5 (Strong Buy).
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'consensus_rating_value'?: number;
    /**
     * The highest price target among all contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'high_price_target'?: number;
    /**
     * The count of \'Hold\' ratings from contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'hold_ratings': number;
    /**
     * The lowest price target among all contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'low_price_target'?: number;
    /**
     * The number of unique analysts contributing price targets.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'price_target_contributors': number;
    /**
     * The number of unique analysts contributing to the overall ratings consensus.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'ratings_contributors': number;
    /**
     * The count of \'Sell\' ratings from contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'sell_ratings': number;
    /**
     * The count of \'Strong Buy\' ratings from contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'strong_buy_ratings': number;
    /**
     * The count of \'Strong Sell\' ratings from contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'strong_sell_ratings': number;
    /**
     * The requested ticker.
     * @type {string}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1Earnings200Response
 */
export interface GetBenzingaV1Earnings200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1Earnings200ResponseResultsInner>}
     * @memberof GetBenzingaV1Earnings200Response
     */
    'results': Array<GetBenzingaV1Earnings200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200Response
     */
    'status': GetBenzingaV1Earnings200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1Earnings200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Earnings200ResponseResultsInner
 */
export interface GetBenzingaV1Earnings200ResponseResultsInner {
    /**
     * The actual earnings per share (EPS) reported by the company for the given period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'actual_eps'?: number;
    /**
     * The actual revenue reported by the company for the given fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'actual_revenue'?: number;
    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * The name of the company releasing earnings.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'company_name'?: string;
    /**
     * The ISO 4217 currency code indicating the denomination in which the figures are reported.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'date'?: string;
    /**
     * Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'date_status'?: string;
    /**
     * The methodology of the EPS figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), ffo (Funds From Operations, a non-GAAP metric commonly used to assess the operating performance of REITs), and adj (adjusted, non-GAAP).
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'eps_method'?: string;
    /**
     * The difference between the actual and estimated EPS.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'eps_surprise'?: number;
    /**
     * The percentage difference between the actual and estimated EPS.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'eps_surprise_percent'?: number;
    /**
     * The analyst consensus estimate for earnings per share (EPS) for the given period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'estimated_eps'?: number;
    /**
     * The analyst consensus estimate for the company\'s revenue in the given period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'estimated_revenue'?: number;
    /**
     * The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'fiscal_period'?: string;
    /**
     * The fiscal year in which the earnings period falls.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'fiscal_year'?: number;
    /**
     * A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest).
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'importance'?: number;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * Additional context, commentary, or clarifying notes related to the earnings event.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'notes'?: string;
    /**
     * The company\'s reported earnings per share (EPS) for the previous comparable period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'previous_eps'?: number;
    /**
     * The company\'s revenue for the previous comparable fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'previous_revenue'?: number;
    /**
     * The methodology of the revenue figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), adj (adjusted, non-GAAP figures that exclude certain items like one-time charges or divestitures), and rental (revenue specifically derived from rental operations, typically used by REITs, leasing companies, or businesses with a rental-based model).
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'revenue_method'?: string;
    /**
     * The difference between the actual and estimated revenue.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'revenue_surprise'?: number;
    /**
     * The percentage difference between the actual and estimated revenue.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'revenue_surprise_percent'?: number;
    /**
     * The stock symbol of the company reporting earnings.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The time (formatted as 24-hour HH:MM:SS UTC) when the earnings are scheduled or were reported.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1Firms200Response
 */
export interface GetBenzingaV1Firms200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1Firms200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1Firms200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1Firms200ResponseResultsInner>}
     * @memberof GetBenzingaV1Firms200Response
     */
    'results': Array<GetBenzingaV1Firms200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1Firms200Response
     */
    'status': GetBenzingaV1Firms200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1Firms200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Firms200ResponseResultsInner
 */
export interface GetBenzingaV1Firms200ResponseResultsInner {
    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof GetBenzingaV1Firms200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBenzingaV1Firms200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBenzingaV1Firms200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The name of a research firm or investment bank which issues ratings.
     * @type {string}
     * @memberof GetBenzingaV1Firms200ResponseResultsInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1Guidance200Response
 */
export interface GetBenzingaV1Guidance200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1Guidance200ResponseResultsInner>}
     * @memberof GetBenzingaV1Guidance200Response
     */
    'results': Array<GetBenzingaV1Guidance200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200Response
     */
    'status': GetBenzingaV1Guidance200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1Guidance200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Guidance200ResponseResultsInner
 */
export interface GetBenzingaV1Guidance200ResponseResultsInner {
    /**
     * A unique identifier assigned by Benzinga to the guidance record.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * The name of the company issuing guidance.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'company_name'?: string;
    /**
     * The ISO 4217 code representing the currency in which the company issued its guidance figures.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'date'?: string;
    /**
     * The methodology of the EPS figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), ffo (Funds From Operations, a non-GAAP metric commonly used to assess the operating performance of REITs), and adj (adjusted, non-GAAP).
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'eps_method'?: string;
    /**
     * The midpoint or central earnings per share (EPS) value the company expects for the given fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'estimated_eps_guidance'?: number;
    /**
     * The midpoint or central revenue figure the company expects for the given fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'estimated_revenue_guidance'?: number;
    /**
     * The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'fiscal_period'?: string;
    /**
     * The fiscal year corresponding to the period for which the guidance is issued.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'fiscal_year'?: number;
    /**
     * A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest).
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'importance'?: number;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The highest EPS value the company expects for the fiscal period if a range was provided.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'max_eps_guidance'?: number;
    /**
     * The highest revenue figure the company expects for the fiscal period if a range was provided.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'max_revenue_guidance'?: number;
    /**
     * The lowest EPS value the company expects for the fiscal period if a range was provided.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'min_eps_guidance'?: number;
    /**
     * The lowest revenue figure the company expects for the fiscal period if a range was provided.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'min_revenue_guidance'?: number;
    /**
     * Additional descriptive text or commentary provided about the guidance record.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'notes'?: string;
    /**
     * Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are \'primary\' (the emphasized figure) and \'secondary\' (a supporting or alternate figure)
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'positioning'?: string;
    /**
     * The highest EPS value issued in a previous guidance record for the same fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'previous_max_eps_guidance'?: number;
    /**
     * The highest revenue value issued in a previous guidance record for the same fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'previous_max_revenue_guidance'?: number;
    /**
     * The lowest EPS value issued in a previous guidance record for the same fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'previous_min_eps_guidance'?: number;
    /**
     * The lowest revenue value issued in a previous guidance record for the same fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'previous_min_revenue_guidance'?: number;
    /**
     * Indicates whether the guidance was issued as part of a scheduled earnings release (\'official\') or as an unscheduled update (\'preliminary\').
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'release_type'?: string;
    /**
     * The methodology of the revenue figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles) and adj (adjusted, non-GAAP).
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'revenue_method'?: string;
    /**
     * The stock symbol of the company issuing guidance.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The time of day the guidance was announced, in HH:mm:ss format.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1News200Response
 */
export interface GetBenzingaV1News200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1News200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1News200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1News200ResponseResultsInner>}
     * @memberof GetBenzingaV1News200Response
     */
    'results': Array<GetBenzingaV1News200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1News200Response
     */
    'status': GetBenzingaV1News200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1News200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1News200ResponseResultsInner
 */
export interface GetBenzingaV1News200ResponseResultsInner {
    /**
     * The name of the journalist or entity that authored the news article.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'author'?: string;
    /**
     * The identifer used by Benzinga for this record.
     * @type {number}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'benzinga_id'?: number;
    /**
     * The full text content of the news article.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'body'?: string;
    /**
     * A list of categories or topics that the article belongs to (e.g., \'News\', \'Price Target\').
     * @type {Array<string>}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'channels'?: Array<string>;
    /**
     * A list of images associated with the article.
     * @type {Array<string>}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'images'?: Array<string>;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'published'?: string;
    /**
     * A list of tags that describe the themes or content of the article.
     * @type {Array<string>}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'tags'?: Array<string>;
    /**
     * A short summary or lead-in to the news article\'s content.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'teaser'?: string;
    /**
     * A list of stock or crypto tickers mentioned in the article.
     * @type {Array<string>}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'tickers'?: Array<string>;
    /**
     * The headline of the news article.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'title'?: string;
    /**
     * The direct link to the source of the news article.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1Ratings200Response
 */
export interface GetBenzingaV1Ratings200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1Ratings200ResponseResultsInner>}
     * @memberof GetBenzingaV1Ratings200Response
     */
    'results': Array<GetBenzingaV1Ratings200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200Response
     */
    'status': GetBenzingaV1Ratings200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1Ratings200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Ratings200ResponseResultsInner
 */
export interface GetBenzingaV1Ratings200ResponseResultsInner {
    /**
     * The current price target adjusted for stock splits and dividends.
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'adjusted_price_target'?: number;
    /**
     * The name of the individual analyst who issued the rating.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'analyst'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'benzinga_analyst_id'?: string;
    /**
     * A link to the Benzinga calendar page for this ticker
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'benzinga_calendar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'benzinga_firm_id'?: string;
    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * A link to the Benzinga articles page for this ticker
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'benzinga_news_url'?: string;
    /**
     * The name of the company being rated.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'company_name'?: string;
    /**
     * The ISO 4217 currency code in which the price target is denominated.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'date'?: string;
    /**
     * The name of the research firm or investment bank issuing the rating.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'firm'?: string;
    /**
     * A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest).
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'importance'?: number;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * Additional context or commentary.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'notes'?: string;
    /**
     * The previous price target adjusted for stock splits and dividends.
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'previous_adjusted_price_target'?: number;
    /**
     * The previous price target set by the analyst.
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'previous_price_target'?: number;
    /**
     * The previous rating set by the analyst.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'previous_rating'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'price_percent_change'?: number;
    /**
     * The current price target set by the analyst.
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'price_target'?: number;
    /**
     * The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'price_target_action'?: string;
    /**
     * The current rating set by the analyst.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'rating'?: string;
    /**
     * The description of the change in rating from the firm\'s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'rating_action'?: string;
    /**
     * The stock symbol of the company being rated.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The time (formatted as 24-hour HH:MM:SS UTC) when the rating was issued.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface GetCryptoAggregates200Response
 */
export interface GetCryptoAggregates200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetCryptoAggregates200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetCryptoAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetCryptoAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetCryptoAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof GetCryptoAggregates200Response
     */
    'results'?: Array<GetCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoAggregates200ResponseAllOfResultsInner
 */
export interface GetCryptoAggregates200ResponseAllOfResultsInner {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface GetCryptoEMA200Response
 */
export interface GetCryptoEMA200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetCryptoEMA200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoEMA200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {GetCryptoEMA200ResponseResults}
     * @memberof GetCryptoEMA200Response
     */
    'results'?: GetCryptoEMA200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoEMA200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetCryptoEMA200ResponseResults
 */
export interface GetCryptoEMA200ResponseResults {
    /**
     * 
     * @type {GetCryptoEMA200ResponseResultsUnderlying}
     * @memberof GetCryptoEMA200ResponseResults
     */
    'underlying'?: GetCryptoEMA200ResponseResultsUnderlying;
    /**
     * 
     * @type {Array<GetCryptoEMA200ResponseResultsValuesInner>}
     * @memberof GetCryptoEMA200ResponseResults
     */
    'values'?: Array<GetCryptoEMA200ResponseResultsValuesInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoEMA200ResponseResultsUnderlying
 */
export interface GetCryptoEMA200ResponseResultsUnderlying {
    /**
     * 
     * @type {Array<GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner>}
     * @memberof GetCryptoEMA200ResponseResultsUnderlying
     */
    'aggregates'?: Array<GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner>;
    /**
     * The URL which can be used to request the underlying aggregates used in this request.
     * @type {string}
     * @memberof GetCryptoEMA200ResponseResultsUnderlying
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
 */
export interface GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'otc'?: boolean;
    /**
     * The Unix Msec timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface GetCryptoEMA200ResponseResultsValuesInner
 */
export interface GetCryptoEMA200ResponseResultsValuesInner {
    /**
     * The Unix Msec timestamp from the last aggregate used in this calculation.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsValuesInner
     */
    'timestamp'?: number;
    /**
     * The indicator value for this period.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsValuesInner
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface GetCryptoMACD200Response
 */
export interface GetCryptoMACD200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetCryptoMACD200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoMACD200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {GetCryptoMACD200ResponseResults}
     * @memberof GetCryptoMACD200Response
     */
    'results'?: GetCryptoMACD200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoMACD200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetCryptoMACD200ResponseResults
 */
export interface GetCryptoMACD200ResponseResults {
    /**
     * 
     * @type {GetCryptoEMA200ResponseResultsUnderlying}
     * @memberof GetCryptoMACD200ResponseResults
     */
    'underlying'?: GetCryptoEMA200ResponseResultsUnderlying;
    /**
     * 
     * @type {Array<GetCryptoMACD200ResponseResultsValuesInner>}
     * @memberof GetCryptoMACD200ResponseResults
     */
    'values'?: Array<GetCryptoMACD200ResponseResultsValuesInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoMACD200ResponseResultsValuesInner
 */
export interface GetCryptoMACD200ResponseResultsValuesInner {
    /**
     * The indicator value for this period.
     * @type {number}
     * @memberof GetCryptoMACD200ResponseResultsValuesInner
     */
    'histogram'?: number;
    /**
     * The indicator value for this period.
     * @type {number}
     * @memberof GetCryptoMACD200ResponseResultsValuesInner
     */
    'signal'?: number;
    /**
     * The Unix Msec timestamp from the last aggregate used in this calculation.
     * @type {number}
     * @memberof GetCryptoMACD200ResponseResultsValuesInner
     */
    'timestamp'?: number;
    /**
     * The indicator value for this period.
     * @type {number}
     * @memberof GetCryptoMACD200ResponseResultsValuesInner
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface GetCryptoOpenClose200Response
 */
export interface GetCryptoOpenClose200Response {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoOpenClose200Response
     */
    'close': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof GetCryptoOpenClose200Response
     */
    'closingTrades': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
    /**
     * The date requested.
     * @type {string}
     * @memberof GetCryptoOpenClose200Response
     */
    'day': string;
    /**
     * Whether or not the timestamps are in UTC timezone.
     * @type {boolean}
     * @memberof GetCryptoOpenClose200Response
     */
    'isUTC': boolean;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoOpenClose200Response
     */
    'open': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof GetCryptoOpenClose200Response
     */
    'openTrades': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof GetCryptoOpenClose200Response
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface GetCryptoRSI200Response
 */
export interface GetCryptoRSI200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetCryptoRSI200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoRSI200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {GetCryptoRSI200ResponseResults}
     * @memberof GetCryptoRSI200Response
     */
    'results'?: GetCryptoRSI200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoRSI200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetCryptoRSI200ResponseResults
 */
export interface GetCryptoRSI200ResponseResults {
    /**
     * 
     * @type {GetCryptoEMA200ResponseResultsUnderlying}
     * @memberof GetCryptoRSI200ResponseResults
     */
    'underlying'?: GetCryptoEMA200ResponseResultsUnderlying;
    /**
     * 
     * @type {Array<GetCryptoEMA200ResponseResultsValuesInner>}
     * @memberof GetCryptoRSI200ResponseResults
     */
    'values'?: Array<GetCryptoEMA200ResponseResultsValuesInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoSMA200Response
 */
export interface GetCryptoSMA200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetCryptoSMA200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoSMA200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {GetCryptoSMA200ResponseResults}
     * @memberof GetCryptoSMA200Response
     */
    'results'?: GetCryptoSMA200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoSMA200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetCryptoSMA200ResponseResults
 */
export interface GetCryptoSMA200ResponseResults {
    /**
     * 
     * @type {GetCryptoEMA200ResponseResultsUnderlying}
     * @memberof GetCryptoSMA200ResponseResults
     */
    'underlying'?: GetCryptoEMA200ResponseResultsUnderlying;
    /**
     * 
     * @type {Array<GetCryptoEMA200ResponseResultsValuesInner>}
     * @memberof GetCryptoSMA200ResponseResults
     */
    'values'?: Array<GetCryptoEMA200ResponseResultsValuesInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoSnapshotDirection200Response
 */
export interface GetCryptoSnapshotDirection200Response {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof GetCryptoSnapshotDirection200Response
     */
    'tickers'?: Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoSnapshotTicker200Response
 */
export interface GetCryptoSnapshotTicker200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoSnapshotTicker200Response
     */
    'status': string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoSnapshotTicker200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetCryptoSnapshotTicker200ResponseAllOfTicker}
     * @memberof GetCryptoSnapshotTicker200Response
     */
    'ticker'?: GetCryptoSnapshotTicker200ResponseAllOfTicker;
}
/**
 * Contains the requested snapshot data for the specified ticker.
 * @export
 * @interface GetCryptoSnapshotTicker200ResponseAllOfTicker
 */
export interface GetCryptoSnapshotTicker200ResponseAllOfTicker {
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'day': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'lastTrade': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'min': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'prevDay': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface GetCryptoSnapshotTickers200Response
 */
export interface GetCryptoSnapshotTickers200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoSnapshotTickers200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof GetCryptoSnapshotTickers200Response
     */
    'tickers'?: Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoSnapshotTickers200ResponseAllOfTickersInner
 */
export interface GetCryptoSnapshotTickers200ResponseAllOfTickersInner {
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'day': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'lastTrade': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'min': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'prevDay': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'updated': number;
}
/**
 * The most recent daily bar for this ticker.
 * @export
 * @interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
 */
export interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'vw': number;
}
/**
 * The most recent trade for this ticker.
 * @export
 * @interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
 */
export interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade {
    /**
     * The trade conditions.
     * @type {Array<number>}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'p': number;
    /**
     * The size (volume) of the trade.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    's': number;
    /**
     * The millisecond accuracy timestamp. This is the timestamp of when the trade was generated at the exchange.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    't': number;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'x': number;
}
/**
 * The most recent minute bar for this ticker.
 * @export
 * @interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
 */
export interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'vw': number;
}
/**
 * The previous day\'s bar for this ticker.
 * @export
 * @interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
 */
export interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface GetCryptoTrades200Response
 */
export interface GetCryptoTrades200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetCryptoTrades200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoTrades200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetCryptoTrades200ResponseResultsInner>}
     * @memberof GetCryptoTrades200Response
     */
    'results'?: Array<GetCryptoTrades200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoTrades200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetCryptoTrades200ResponseResultsInner
 */
export interface GetCryptoTrades200ResponseResultsInner {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'exchange': number;
    /**
     * The Trade ID which uniquely identifies a trade on the exchange that the trade happened on.
     * @type {string}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'id'?: string;
    /**
     * The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
     * @type {number}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'participant_timestamp'?: number;
    /**
     * The price of the trade in the base currency of the crypto pair.
     * @type {number}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'price': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface GetCurrencyConversion200Response
 */
export interface GetCurrencyConversion200Response {
    /**
     * The result of the conversion.
     * @type {number}
     * @memberof GetCurrencyConversion200Response
     */
    'converted': number;
    /**
     * The \"from\" currency symbol.
     * @type {string}
     * @memberof GetCurrencyConversion200Response
     */
    'from': string;
    /**
     * The amount to convert.
     * @type {number}
     * @memberof GetCurrencyConversion200Response
     */
    'initialAmount': number;
    /**
     * 
     * @type {GetCurrencyConversion200ResponseLast}
     * @memberof GetCurrencyConversion200Response
     */
    'last'?: GetCurrencyConversion200ResponseLast;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCurrencyConversion200Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCurrencyConversion200Response
     */
    'status': string;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof GetCurrencyConversion200Response
     */
    'symbol': string;
    /**
     * The \"to\" currency symbol.
     * @type {string}
     * @memberof GetCurrencyConversion200Response
     */
    'to': string;
}
/**
 * Contains the requested quote data for the specified forex currency pair.
 * @export
 * @interface GetCurrencyConversion200ResponseLast
 */
export interface GetCurrencyConversion200ResponseLast {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetCurrencyConversion200ResponseLast
     */
    'ask': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetCurrencyConversion200ResponseLast
     */
    'bid': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/forex/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetCurrencyConversion200ResponseLast
     */
    'exchange': number;
    /**
     * The Unix millisecond timestamp.
     * @type {number}
     * @memberof GetCurrencyConversion200ResponseLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface GetEvents200Response
 */
export interface GetEvents200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetEvents200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {GetEvents200ResponseResults}
     * @memberof GetEvents200Response
     */
    'results'?: GetEvents200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetEvents200Response
     */
    'status'?: string;
}
/**
 * Contains the requested event data for the specified ticker.
 * @export
 * @interface GetEvents200ResponseResults
 */
export interface GetEvents200ResponseResults {
    /**
     * An array of event containing the requested data.
     * @type {Array<GetEvents200ResponseResultsEventsInner>}
     * @memberof GetEvents200ResponseResults
     */
    'events'?: Array<GetEvents200ResponseResultsEventsInner>;
    /**
     * The name of the asset.
     * @type {string}
     * @memberof GetEvents200ResponseResults
     */
    'name'?: string;
}
/**
 * @type GetEvents200ResponseResultsEventsInner
 * @export
 */
export type GetEvents200ResponseResultsEventsInner = GetEvents200ResponseResultsEventsInnerOneOf;

/**
 * 
 * @export
 * @interface GetEvents200ResponseResultsEventsInnerOneOf
 */
export interface GetEvents200ResponseResultsEventsInnerOneOf {
    /**
     * The date the event took place
     * @type {string}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOf
     */
    'date': string;
    /**
     * The type of historical event for the asset
     * @type {string}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOf
     */
    'event_type': string;
    /**
     * 
     * @type {GetEvents200ResponseResultsEventsInnerOneOfTickerChange}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOf
     */
    'ticker_change'?: GetEvents200ResponseResultsEventsInnerOneOfTickerChange;
}
/**
 * Details about a ticker change
 * @export
 * @interface GetEvents200ResponseResultsEventsInnerOneOfTickerChange
 */
export interface GetEvents200ResponseResultsEventsInnerOneOfTickerChange {
    /**
     * A ticker symbol
     * @type {string}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOfTickerChange
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetFedV1TreasuryYields200Response
 */
export interface GetFedV1TreasuryYields200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetFedV1TreasuryYields200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetFedV1TreasuryYields200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetFedV1TreasuryYields200ResponseResultsInner>}
     * @memberof GetFedV1TreasuryYields200Response
     */
    'results': Array<GetFedV1TreasuryYields200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFedV1TreasuryYields200Response
     */
    'status': GetFedV1TreasuryYields200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFedV1TreasuryYields200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetFedV1TreasuryYields200ResponseResultsInner
 */
export interface GetFedV1TreasuryYields200ResponseResultsInner {
    /**
     * Calendar date of the yield observation (YYYYMMDD).
     * @type {string}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'date'?: string;
    /**
     * Market Yield on U.S. Treasury Securities at 10Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_10_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 1Month Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_1_month'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 1Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_1_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 20Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_20_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 2Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_2_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 30Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_30_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 3Month Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_3_month'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 3Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_3_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 5Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_5_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 6Month Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_6_month'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 7Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_7_year'?: number;
}
/**
 * 
 * @export
 * @interface GetForexQuotes200Response
 */
export interface GetForexQuotes200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetForexQuotes200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetForexQuotes200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetForexQuotes200ResponseResultsInner>}
     * @memberof GetForexQuotes200Response
     */
    'results'?: Array<GetForexQuotes200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetForexQuotes200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetForexQuotes200ResponseResultsInner
 */
export interface GetForexQuotes200ResponseResultsInner {
    /**
     * The ask exchange ID
     * @type {number}
     * @memberof GetForexQuotes200ResponseResultsInner
     */
    'ask_exchange'?: number;
    /**
     * The ask price.
     * @type {number}
     * @memberof GetForexQuotes200ResponseResultsInner
     */
    'ask_price'?: number;
    /**
     * The bid exchange ID
     * @type {number}
     * @memberof GetForexQuotes200ResponseResultsInner
     */
    'bid_exchange'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetForexQuotes200ResponseResultsInner
     */
    'bid_price'?: number;
    /**
     * The nanosecond Exchange Unix Timestamp. This is the timestamp of when the quote was generated at the exchange.
     * @type {number}
     * @memberof GetForexQuotes200ResponseResultsInner
     */
    'participant_timestamp': number;
}
/**
 * 
 * @export
 * @interface GetForexSnapshotTicker200Response
 */
export interface GetForexSnapshotTicker200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetForexSnapshotTicker200Response
     */
    'status': string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetForexSnapshotTicker200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetForexSnapshotTicker200ResponseAllOfTicker}
     * @memberof GetForexSnapshotTicker200Response
     */
    'ticker'?: GetForexSnapshotTicker200ResponseAllOfTicker;
}
/**
 * Contains the requested snapshot data for the specified ticker.
 * @export
 * @interface GetForexSnapshotTicker200ResponseAllOfTicker
 */
export interface GetForexSnapshotTicker200ResponseAllOfTicker {
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'day': GetForexSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'lastQuote': GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'min': GetForexSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'prevDay': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface GetForexSnapshotTickers200Response
 */
export interface GetForexSnapshotTickers200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetForexSnapshotTickers200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetForexSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof GetForexSnapshotTickers200Response
     */
    'tickers'?: Array<GetForexSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface GetForexSnapshotTickers200ResponseAllOfTickersInner
 */
export interface GetForexSnapshotTickers200ResponseAllOfTickersInner {
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'day': GetForexSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'lastQuote': GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'min': GetForexSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'prevDay': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'updated': number;
}
/**
 * The most recent daily bar for this ticker.
 * @export
 * @interface GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
 */
export interface GetForexSnapshotTickers200ResponseAllOfTickersInnerDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'v': number;
}
/**
 * The most recent quote for this ticker.
 * @export
 * @interface GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote
 */
export interface GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'a': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'b': number;
    /**
     * The millisecond accuracy timestamp of the quote.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    't': number;
    /**
     * The exchange ID on which this quote happened.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'x': number;
}
/**
 * The most recent minute bar for this ticker.
 * @export
 * @interface GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
 */
export interface GetForexSnapshotTickers200ResponseAllOfTickersInnerMin {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'c'?: number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'h'?: number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'l'?: number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'o'?: number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    't'?: number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'v'?: number;
}
/**
 * 
 * @export
 * @interface GetGroupedCryptoAggregates200Response
 */
export interface GetGroupedCryptoAggregates200Response {
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'results'?: Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetGroupedCryptoAggregates200ResponseAllOfResultsInner
 */
export interface GetGroupedCryptoAggregates200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the end of the aggregate window.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface GetGroupedStocksAggregates200Response
 */
export interface GetGroupedStocksAggregates200Response {
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedStocksAggregates200ResponseAllOfResultsInner>}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'results'?: Array<GetGroupedStocksAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetGroupedStocksAggregates200ResponseAllOfResultsInner
 */
export interface GetGroupedStocksAggregates200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the end of the aggregate window.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface GetIndicesOpenClose200Response
 */
export interface GetIndicesOpenClose200Response {
    /**
     * The close value of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'afterHours'?: number;
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof GetIndicesOpenClose200Response
     */
    'from': string;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'high': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'low': number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'open': number;
    /**
     * The open value of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetIndicesOpenClose200Response
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetIndicesOpenClose200Response
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface GetIndicesSnapshot200Response
 */
export interface GetIndicesSnapshot200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetIndicesSnapshot200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetIndicesSnapshot200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetIndicesSnapshot200ResponseResultsInner>}
     * @memberof GetIndicesSnapshot200Response
     */
    'results'?: Array<GetIndicesSnapshot200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetIndicesSnapshot200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetIndicesSnapshot200ResponseResultsInner
 */
export interface GetIndicesSnapshot200ResponseResultsInner {
    /**
     * The error while looking for this ticker.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'error'?: string;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'last_updated'?: number;
    /**
     * The market status for the market that trades this ticker.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'market_status'?: string;
    /**
     * The error message while looking for this ticker.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'message'?: string;
    /**
     * Name of Index.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'name'?: string;
    /**
     * 
     * @type {GetIndicesSnapshot200ResponseResultsInnerSession}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'session'?: GetIndicesSnapshot200ResponseResultsInnerSession;
    /**
     * Ticker of asset queried.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'timeframe'?: GetIndicesSnapshot200ResponseResultsInnerTimeframeEnum;
    /**
     * The indices market.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'type'?: GetIndicesSnapshot200ResponseResultsInnerTypeEnum;
    /**
     * Value of Index.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'value'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetIndicesSnapshot200ResponseResultsInnerTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}
/**
    * @export
    * @enum {string}
    */
export enum GetIndicesSnapshot200ResponseResultsInnerTypeEnum {
    Indices = 'indices'
}

/**
 * Trading session metrics, detailing change percentages and key price points (open, close, high, low) for the asset within the current trading day.
 * @export
 * @interface GetIndicesSnapshot200ResponseResultsInnerSession
 */
export interface GetIndicesSnapshot200ResponseResultsInnerSession {
    /**
     * The value of the change for the index from the previous trading day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'change'?: number;
    /**
     * The percent of the change for the index from the previous trading day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'change_percent'?: number;
    /**
     * The closing value for the index of the day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'close'?: number;
    /**
     * The highest value for the index of the day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'high'?: number;
    /**
     * The lowest value for the index of the day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'low'?: number;
    /**
     * The open value for the index of the day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'open'?: number;
    /**
     * The closing value for the index of previous trading day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'previous_close'?: number;
}
/**
 * 
 * @export
 * @interface GetLastCryptoTrade200Response
 */
export interface GetLastCryptoTrade200Response {
    /**
     * 
     * @type {GetLastCryptoTrade200ResponseLast}
     * @memberof GetLastCryptoTrade200Response
     */
    'last'?: GetLastCryptoTrade200ResponseLast;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetLastCryptoTrade200Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetLastCryptoTrade200Response
     */
    'status': string;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof GetLastCryptoTrade200Response
     */
    'symbol': string;
}
/**
 * Contains the requested trade data for the specified cryptocurrency pair.
 * @export
 * @interface GetLastCryptoTrade200ResponseLast
 */
export interface GetLastCryptoTrade200ResponseLast {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetLastCryptoTrade200ResponseLast
     */
    'conditions'?: Array<number>;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://polygon.io/docs/crypto/get_v3_reference_exchanges\">Exchanges</a> for a mapping of exchanges to IDs.
     * @type {number}
     * @memberof GetLastCryptoTrade200ResponseLast
     */
    'exchange': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetLastCryptoTrade200ResponseLast
     */
    'price': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetLastCryptoTrade200ResponseLast
     */
    'size': number;
    /**
     * The Unix millisecond timestamp.
     * @type {number}
     * @memberof GetLastCryptoTrade200ResponseLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface GetLastCurrencyQuote200Response
 */
export interface GetLastCurrencyQuote200Response {
    /**
     * 
     * @type {GetCurrencyConversion200ResponseLast}
     * @memberof GetLastCurrencyQuote200Response
     */
    'last'?: GetCurrencyConversion200ResponseLast;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetLastCurrencyQuote200Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetLastCurrencyQuote200Response
     */
    'status': string;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof GetLastCurrencyQuote200Response
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface GetLastOptionsTrade200Response
 */
export interface GetLastOptionsTrade200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetLastOptionsTrade200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetLastOptionsTrade200ResponseResults}
     * @memberof GetLastOptionsTrade200Response
     */
    'results'?: GetLastOptionsTrade200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetLastOptionsTrade200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetLastOptionsTrade200ResponseResults
 */
export interface GetLastOptionsTrade200ResponseResults {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'T': string;
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'c'?: Array<number>;
    /**
     * The trade correction indicator.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'e'?: number;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'f'?: number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
     * @type {string}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'p': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'q': number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'r'?: number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    's'?: number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'x': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'y': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'z'?: number;
}
/**
 * 
 * @export
 * @interface GetLastStocksQuote200Response
 */
export interface GetLastStocksQuote200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetLastStocksQuote200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetLastStocksQuote200ResponseResults}
     * @memberof GetLastStocksQuote200Response
     */
    'results'?: GetLastStocksQuote200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetLastStocksQuote200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetLastStocksQuote200ResponseResults
 */
export interface GetLastStocksQuote200ResponseResults {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'P'?: number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'S'?: number;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'T': string;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'X'?: number;
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'c'?: Array<number>;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'f'?: number;
    /**
     * A list of indicator codes.
     * @type {Array<number>}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'i'?: Array<number>;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'p'?: number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'q': number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    's'?: number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'x'?: number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'y': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'z'?: number;
}
/**
 * 
 * @export
 * @interface GetMarketHolidays200ResponseInner
 */
export interface GetMarketHolidays200ResponseInner {
    /**
     * The market close time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'close'?: string;
    /**
     * The date of the holiday.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'date'?: string;
    /**
     * Which market the record is for.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'exchange'?: string;
    /**
     * The name of the holiday.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'name'?: string;
    /**
     * The market open time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'open'?: string;
    /**
     * The status of the market on the holiday.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetMarketStatus200Response
 */
export interface GetMarketStatus200Response {
    /**
     * Whether or not the market is in post-market hours.
     * @type {boolean}
     * @memberof GetMarketStatus200Response
     */
    'afterHours'?: boolean;
    /**
     * 
     * @type {GetMarketStatus200ResponseCurrencies}
     * @memberof GetMarketStatus200Response
     */
    'currencies'?: GetMarketStatus200ResponseCurrencies;
    /**
     * Whether or not the market is in pre-market hours.
     * @type {boolean}
     * @memberof GetMarketStatus200Response
     */
    'earlyHours'?: boolean;
    /**
     * 
     * @type {GetMarketStatus200ResponseExchanges}
     * @memberof GetMarketStatus200Response
     */
    'exchanges'?: GetMarketStatus200ResponseExchanges;
    /**
     * 
     * @type {GetMarketStatus200ResponseIndicesGroups}
     * @memberof GetMarketStatus200Response
     */
    'indicesGroups'?: GetMarketStatus200ResponseIndicesGroups;
    /**
     * The status of the market as a whole.
     * @type {string}
     * @memberof GetMarketStatus200Response
     */
    'market'?: string;
    /**
     * The current time of the server, returned as a date-time in RFC3339 format.
     * @type {string}
     * @memberof GetMarketStatus200Response
     */
    'serverTime'?: string;
}
/**
 * Contains the status of various currency markets.
 * @export
 * @interface GetMarketStatus200ResponseCurrencies
 */
export interface GetMarketStatus200ResponseCurrencies {
    /**
     * The status of the crypto market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseCurrencies
     */
    'crypto'?: string;
    /**
     * The status of the forex market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseCurrencies
     */
    'fx'?: string;
}
/**
 * Contains the status of different US stock exchanges (e.g., Nasdaq, NYSE).
 * @export
 * @interface GetMarketStatus200ResponseExchanges
 */
export interface GetMarketStatus200ResponseExchanges {
    /**
     * The status of the Nasdaq market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseExchanges
     */
    'nasdaq'?: string;
    /**
     * The status of the NYSE market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseExchanges
     */
    'nyse'?: string;
    /**
     * The status of the OTC market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseExchanges
     */
    'otc'?: string;
}
/**
 * Contains the status of various index groups (e.g., MSCI, FTSE Russell).
 * @export
 * @interface GetMarketStatus200ResponseIndicesGroups
 */
export interface GetMarketStatus200ResponseIndicesGroups {
    /**
     * The status of Cboe Streaming Market Indices Cryptocurrency (\"CCCY\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'cccy'?: string;
    /**
     * The status of Cboe Global Indices (\"CGI\") trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'cgi'?: string;
    /**
     * The status of Dow Jones indices trading hours
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'dow_jones'?: string;
    /**
     * The status of Financial Times Stock Exchange Group (\"FTSE\") Russell indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'ftse_russell'?: string;
    /**
     * The status of Morgan Stanley Capital International (\"MSCI\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'msci'?: string;
    /**
     * The status of Morningstar (\"MSTAR\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'mstar'?: string;
    /**
     * The status of Morningstar Customer (\"MSTARC\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'mstarc'?: string;
    /**
     * The status of National Association of Securities Dealers Automated Quotations (\"Nasdaq\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'nasdaq'?: string;
    /**
     * The status of Standard & Poors\'s (\"S&P\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    's_and_p'?: string;
    /**
     * The status of Societe Generale indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'societe_generale'?: string;
}
/**
 * 
 * @export
 * @interface GetOptionContract200Response
 */
export interface GetOptionContract200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetOptionContract200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetOptionContract200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetOptionsChain200ResponseResultsInner}
     * @memberof GetOptionContract200Response
     */
    'results'?: GetOptionsChain200ResponseResultsInner;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionContract200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetOptionsChain200Response
 */
export interface GetOptionsChain200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetOptionsChain200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetOptionsChain200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetOptionsChain200ResponseResultsInner>}
     * @memberof GetOptionsChain200Response
     */
    'results'?: Array<GetOptionsChain200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionsChain200Response
     */
    'status': string;
}
/**
 * Contains the requested snapshot data for the specified contract.
 * @export
 * @interface GetOptionsChain200ResponseResultsInner
 */
export interface GetOptionsChain200ResponseResultsInner {
    /**
     * The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'break_even_price': number;
    /**
     * 
     * @type {GetOptionsChain200ResponseResultsInnerDay}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'day': GetOptionsChain200ResponseResultsInnerDay;
    /**
     * 
     * @type {GetOptionsChain200ResponseResultsInnerDetails}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'details': GetOptionsChain200ResponseResultsInnerDetails;
    /**
     * Fair market value is only available on Business plans. It\'s it our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerGreeks}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'greeks'?: GetSnapshots200ResponseResultsInnerGreeks;
    /**
     * The market\'s forecast for the volatility of the underlying asset, based on this option\'s current price.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'implied_volatility'?: number;
    /**
     * 
     * @type {GetOptionsChain200ResponseResultsInnerLastQuote}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'last_quote': GetOptionsChain200ResponseResultsInnerLastQuote;
    /**
     * 
     * @type {GetOptionsChain200ResponseResultsInnerLastTrade}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'last_trade'?: GetOptionsChain200ResponseResultsInnerLastTrade;
    /**
     * The quantity of this contract held at the end of the last trading day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'open_interest': number;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerUnderlyingAsset}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'underlying_asset': GetSnapshots200ResponseResultsInnerUnderlyingAsset;
}
/**
 * The most recent daily bar for this contract.
 * @export
 * @interface GetOptionsChain200ResponseResultsInnerDay
 */
export interface GetOptionsChain200ResponseResultsInnerDay {
    /**
     * The value of the price change for the contract from the previous trading day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'change': number;
    /**
     * The percent of the price change for the contract from the previous trading day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'change_percent': number;
    /**
     * The closing price for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'close': number;
    /**
     * The highest price for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'high': number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'last_updated'?: number;
    /**
     * The lowest price for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'low': number;
    /**
     * The open price for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'open': number;
    /**
     * The closing price for the contract of previous trading day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'previous_close': number;
    /**
     * The trading volume for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'volume': number;
    /**
     * The trading volume weighted average price for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'vwap': number;
}
/**
 * The details for this contract.
 * @export
 * @interface GetOptionsChain200ResponseResultsInnerDetails
 */
export interface GetOptionsChain200ResponseResultsInnerDetails {
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'contract_type': GetOptionsChain200ResponseResultsInnerDetailsContractTypeEnum;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'exercise_style': GetOptionsChain200ResponseResultsInnerDetailsExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'expiration_date': string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'shares_per_contract': number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'strike_price': number;
    /**
     * The ticker symbol for the asset.
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum GetOptionsChain200ResponseResultsInnerDetailsContractTypeEnum {
    Put = 'put',
    Call = 'call',
    Other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum GetOptionsChain200ResponseResultsInnerDetailsExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * The most recent quote for this contract. This is only returned if your current plan includes quotes.
 * @export
 * @interface GetOptionsChain200ResponseResultsInnerLastQuote
 */
export interface GetOptionsChain200ResponseResultsInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'ask': number;
    /**
     * The ask side exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'ask_exchange'?: number;
    /**
     * The ask size.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'ask_size': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'bid': number;
    /**
     * The bid side exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'bid_exchange'?: number;
    /**
     * The bid size.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'bid_size': number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'last_updated'?: number;
    /**
     * The average of the bid and ask price.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'midpoint': number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'timeframe'?: GetOptionsChain200ResponseResultsInnerLastQuoteTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetOptionsChain200ResponseResultsInnerLastQuoteTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * The most recent trade for this contract. This is only returned if your current plan includes trades.
 * @export
 * @interface GetOptionsChain200ResponseResultsInnerLastTrade
 */
export interface GetOptionsChain200ResponseResultsInnerLastTrade {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'conditions'?: Array<number>;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/options/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'exchange': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'price': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'sip_timestamp': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'size': number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'timeframe'?: GetOptionsChain200ResponseResultsInnerLastTradeTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetOptionsChain200ResponseResultsInnerLastTradeTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * 
 * @export
 * @interface GetOptionsContract200Response
 */
export interface GetOptionsContract200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetOptionsContract200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {ListOptionsContracts200ResponseResultsInner}
     * @memberof GetOptionsContract200Response
     */
    'results'?: ListOptionsContracts200ResponseResultsInner;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionsContract200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetOptionsOpenClose200Response
 */
export interface GetOptionsOpenClose200Response {
    /**
     * The close price of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'afterHours'?: number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof GetOptionsOpenClose200Response
     */
    'from': string;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'high': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'low': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'open': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetOptionsOpenClose200Response
     */
    'otc'?: boolean;
    /**
     * The open price of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionsOpenClose200Response
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetOptionsOpenClose200Response
     */
    'symbol': string;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'volume': number;
}
/**
 * 
 * @export
 * @interface GetOptionsQuotes200Response
 */
export interface GetOptionsQuotes200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetOptionsQuotes200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetOptionsQuotes200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetOptionsQuotes200ResponseResultsInner>}
     * @memberof GetOptionsQuotes200Response
     */
    'results'?: Array<GetOptionsQuotes200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionsQuotes200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetOptionsQuotes200ResponseResultsInner
 */
export interface GetOptionsQuotes200ResponseResultsInner {
    /**
     * The ask exchange ID
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'ask_exchange'?: number;
    /**
     * The ask price.
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'ask_price'?: number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'ask_size'?: number;
    /**
     * The bid exchange ID
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'bid_exchange'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'bid_price'?: number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'bid_size'?: number;
    /**
     * The sequence number represents the sequence in which quote events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'sequence_number': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'sip_timestamp': number;
}
/**
 * 
 * @export
 * @interface GetOptionsTrades200Response
 */
export interface GetOptionsTrades200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetOptionsTrades200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetOptionsTrades200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetOptionsTrades200ResponseResultsInner>}
     * @memberof GetOptionsTrades200Response
     */
    'results'?: Array<GetOptionsTrades200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionsTrades200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetOptionsTrades200ResponseResultsInner
 */
export interface GetOptionsTrades200ResponseResultsInner {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * The trade correction indicator.
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'correction'?: number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/options/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'exchange': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'participant_timestamp'?: number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'price': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'sip_timestamp': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface GetPreviousCryptoAggregates200Response
 */
export interface GetPreviousCryptoAggregates200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'results'?: Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetPreviousForexAggregates200Response
 */
export interface GetPreviousForexAggregates200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetPreviousForexAggregates200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetPreviousForexAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetPreviousForexAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetPreviousForexAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetPreviousForexAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetPreviousForexAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetPreviousForexAggregates200ResponseAllOfResultsInner>}
     * @memberof GetPreviousForexAggregates200Response
     */
    'results'?: Array<GetPreviousForexAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetPreviousForexAggregates200ResponseAllOfResultsInner
 */
export interface GetPreviousForexAggregates200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface GetPreviousIndicesAggregates200Response
 */
export interface GetPreviousIndicesAggregates200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'ticker': string;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetPreviousIndicesAggregates200ResponseAllOfResultsInner>}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'results'?: Array<GetPreviousIndicesAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetPreviousIndicesAggregates200ResponseAllOfResultsInner
 */
export interface GetPreviousIndicesAggregates200ResponseAllOfResultsInner {
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200ResponseAllOfResultsInner
     */
    't': number;
}
/**
 * 
 * @export
 * @interface GetRelatedCompanies200Response
 */
export interface GetRelatedCompanies200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetRelatedCompanies200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetRelatedCompanies200ResponseResultsInner>}
     * @memberof GetRelatedCompanies200Response
     */
    'results'?: Array<GetRelatedCompanies200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetRelatedCompanies200Response
     */
    'status'?: string;
    /**
     * The ticker being queried.
     * @type {string}
     * @memberof GetRelatedCompanies200Response
     */
    'ticker'?: string;
}
/**
 * The tickers related to the requested ticker.
 * @export
 * @interface GetRelatedCompanies200ResponseResultsInner
 */
export interface GetRelatedCompanies200ResponseResultsInner {
    /**
     * A ticker related to the requested ticker.
     * @type {string}
     * @memberof GetRelatedCompanies200ResponseResultsInner
     */
    'ticker': string;
}
/**
 * 
 * @export
 * @interface GetSnapshotSummary200Response
 */
export interface GetSnapshotSummary200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetSnapshotSummary200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetSnapshotSummary200ResponseResultsInner>}
     * @memberof GetSnapshotSummary200Response
     */
    'results'?: Array<GetSnapshotSummary200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetSnapshotSummary200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetSnapshotSummary200ResponseResultsInner
 */
export interface GetSnapshotSummary200ResponseResultsInner {
    /**
     * 
     * @type {GetSnapshotSummary200ResponseResultsInnerBranding}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'branding'?: GetSnapshotSummary200ResponseResultsInnerBranding;
    /**
     * The error while looking for this ticker.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'error'?: string;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'last_updated'?: number;
    /**
     * The market status for the market that trades this ticker.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'market_status'?: string;
    /**
     * The error message while looking for this ticker.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'message'?: string;
    /**
     * Name of ticker, forex, or crypto asset.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'name'?: string;
    /**
     * 
     * @type {GetSnapshotSummary200ResponseResultsInnerOptions}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'options'?: GetSnapshotSummary200ResponseResultsInnerOptions;
    /**
     * The most up to date ticker price.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'price'?: number;
    /**
     * 
     * @type {GetSnapshotSummary200ResponseResultsInnerSession}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'session'?: GetSnapshotSummary200ResponseResultsInnerSession;
    /**
     * Ticker of asset queried.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The market for this ticker of stock, crypto, fx, option.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'type'?: GetSnapshotSummary200ResponseResultsInnerTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshotSummary200ResponseResultsInnerTypeEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Options = 'options',
    Fx = 'fx'
}

/**
 * 
 * @export
 * @interface GetSnapshotSummary200ResponseResultsInnerBranding
 */
export interface GetSnapshotSummary200ResponseResultsInnerBranding {
    /**
     * A link to this ticker\'s company\'s icon. Icon\'s are generally smaller, square images that represent the company at a glance. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerBranding
     */
    'icon_url'?: string;
    /**
     * A link to this ticker\'s company\'s logo. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerBranding
     */
    'logo_url'?: string;
}
/**
 * 
 * @export
 * @interface GetSnapshotSummary200ResponseResultsInnerOptions
 */
export interface GetSnapshotSummary200ResponseResultsInnerOptions {
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'contract_type': GetSnapshotSummary200ResponseResultsInnerOptionsContractTypeEnum;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'exercise_style': GetSnapshotSummary200ResponseResultsInnerOptionsExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'expiration_date': string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'shares_per_contract': number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'strike_price': number;
    /**
     * The ticker for the option contract.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'underlying_ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshotSummary200ResponseResultsInnerOptionsContractTypeEnum {
    Put = 'put',
    Call = 'call',
    Other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum GetSnapshotSummary200ResponseResultsInnerOptionsExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * Comprehensive trading session metrics, detailing price changes, trading volume, and key price points (open, close, high, low) for the asset within the current trading day. Includes specific changes during early, regular, and late trading periods to enable detailed performance analysis and trend tracking.
 * @export
 * @interface GetSnapshotSummary200ResponseResultsInnerSession
 */
export interface GetSnapshotSummary200ResponseResultsInnerSession {
    /**
     * The value of the price change for the asset from the previous trading day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'change': number;
    /**
     * The percent of the price change for the asset from the previous trading day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'change_percent': number;
    /**
     * The closing price of the asset for the day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'close': number;
    /**
     * Today\'s early trading change amount, difference between price and previous close if in early trading hours, otherwise difference between last price during early trading and previous close.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'early_trading_change'?: number;
    /**
     * Today\'s early trading change as a percentage.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'early_trading_change_percent'?: number;
    /**
     * The highest price of the asset for the day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'high': number;
    /**
     * Today\'s late trading change amount, difference between price and today\'s close if in late trading hours, otherwise difference between last price during late trading and today\'s close.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'late_trading_change'?: number;
    /**
     * Today\'s late trading change as a percentage.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'late_trading_change_percent'?: number;
    /**
     * The lowest price of the asset for the day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'low': number;
    /**
     * The open price of the asset for the day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'open': number;
    /**
     * The closing price of the asset for the previous trading day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'previous_close': number;
    /**
     * The price of the most recent trade or bid price for this asset.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'price'?: number;
    /**
     * Today\'s change in regular trading hours, difference between current price and previous trading day\'s close, otherwise difference between today\'s close and previous day\'s close.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'regular_trading_change'?: number;
    /**
     * Today\'s regular trading change as a percentage.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'regular_trading_change_percent'?: number;
    /**
     * The trading volume for the asset for the day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'volume'?: number;
}
/**
 * 
 * @export
 * @interface GetSnapshots200Response
 */
export interface GetSnapshots200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetSnapshots200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetSnapshots200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetSnapshots200ResponseResultsInner>}
     * @memberof GetSnapshots200Response
     */
    'results'?: Array<GetSnapshots200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetSnapshots200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetSnapshots200ResponseResultsInner
 */
export interface GetSnapshots200ResponseResultsInner {
    /**
     * The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'break_even_price'?: number;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerDetails}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'details'?: GetSnapshots200ResponseResultsInnerDetails;
    /**
     * The error while looking for this ticker.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'error'?: string;
    /**
     * Fair market value is only available on Business plans. It\'s it our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerGreeks}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'greeks'?: GetSnapshots200ResponseResultsInnerGreeks;
    /**
     * The market\'s forecast for the volatility of the underlying asset, based on this option\'s current price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'implied_volatility'?: number;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerLastQuote}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'last_quote'?: GetSnapshots200ResponseResultsInnerLastQuote;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerLastTrade}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'last_trade'?: GetSnapshots200ResponseResultsInnerLastTrade;
    /**
     * The market status for the market that trades this ticker. Possible values for stocks, options, crypto, and forex snapshots are open, closed, early_trading, or late_trading. Possible values for indices snapshots are regular_trading, closed, early_trading, and late_trading.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'market_status'?: string;
    /**
     * The error message while looking for this ticker.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'message'?: string;
    /**
     * The name of this contract.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'name'?: string;
    /**
     * The quantity of this contract held at the end of the last trading day.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'open_interest'?: number;
    /**
     * 
     * @type {GetSnapshotSummary200ResponseResultsInnerSession}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'session'?: GetSnapshotSummary200ResponseResultsInnerSession;
    /**
     * The ticker symbol for the asset.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The asset class for this ticker.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'type'?: GetSnapshots200ResponseResultsInnerTypeEnum;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerUnderlyingAsset}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'underlying_asset'?: GetSnapshots200ResponseResultsInnerUnderlyingAsset;
    /**
     * Value of Index.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'value'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerTypeEnum {
    Stocks = 'stocks',
    Options = 'options',
    Fx = 'fx',
    Crypto = 'crypto',
    Indices = 'indices'
}

/**
 * The details for this contract.
 * @export
 * @interface GetSnapshots200ResponseResultsInnerDetails
 */
export interface GetSnapshots200ResponseResultsInnerDetails {
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerDetails
     */
    'contract_type': GetSnapshots200ResponseResultsInnerDetailsContractTypeEnum;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerDetails
     */
    'exercise_style': GetSnapshots200ResponseResultsInnerDetailsExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerDetails
     */
    'expiration_date': string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerDetails
     */
    'shares_per_contract': number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerDetails
     */
    'strike_price': number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerDetailsContractTypeEnum {
    Put = 'put',
    Call = 'call',
    Other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerDetailsExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * The greeks for this contract. There are certain circumstances where greeks will not be returned, such as options contracts that are deep in the money. See this <a href=\"https://polygon.io/blog/greeks-and-implied-volatility/#testing\" alt=\"link\">article</a> for more information.
 * @export
 * @interface GetSnapshots200ResponseResultsInnerGreeks
 */
export interface GetSnapshots200ResponseResultsInnerGreeks {
    /**
     * The change in the option\'s price per $0.01 increment in the price of the underlying asset.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerGreeks
     */
    'delta': number;
    /**
     * The change in delta per $0.01 change in the price of the underlying asset.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerGreeks
     */
    'gamma': number;
    /**
     * The change in the option\'s price per day.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerGreeks
     */
    'theta': number;
    /**
     * The change in the option\'s price per 1% increment in volatility.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerGreeks
     */
    'vega': number;
}
/**
 * The most recent quote for this contract. This is only returned if your current plan includes quotes.
 * @export
 * @interface GetSnapshots200ResponseResultsInnerLastQuote
 */
export interface GetSnapshots200ResponseResultsInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'ask': number;
    /**
     * The ask side exchange ID. See <a href=\"https://polygon.io/docs/options/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'ask_exchange'?: number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'ask_size'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'bid': number;
    /**
     * The bid side exchange ID. See <a href=\"https://polygon.io/docs/options/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'bid_exchange'?: number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'bid_size'?: number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'last_updated': number;
    /**
     * The average of the bid and ask price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'midpoint'?: number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'timeframe': GetSnapshots200ResponseResultsInnerLastQuoteTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerLastQuoteTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * The most recent quote for this contract. This is only returned if your current plan includes trades.
 * @export
 * @interface GetSnapshots200ResponseResultsInnerLastTrade
 */
export interface GetSnapshots200ResponseResultsInnerLastTrade {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'conditions'?: Array<number>;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'exchange'?: number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'id'?: string;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'last_updated'?: number;
    /**
     * The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'participant_timestamp'?: number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'price': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'sip_timestamp'?: number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'size': number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'timeframe'?: GetSnapshots200ResponseResultsInnerLastTradeTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerLastTradeTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * Information on the underlying stock for this options contract.  The market data returned depends on your current stocks plan.
 * @export
 * @interface GetSnapshots200ResponseResultsInnerUnderlyingAsset
 */
export interface GetSnapshots200ResponseResultsInnerUnderlyingAsset {
    /**
     * The change in price for the contract to break even.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'change_to_break_even': number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'last_updated'?: number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'price'?: number;
    /**
     * The ticker symbol for the contract\'s underlying asset.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'ticker': string;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'timeframe'?: GetSnapshots200ResponseResultsInnerUnderlyingAssetTimeframeEnum;
    /**
     * The value of the underlying index.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'value'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerUnderlyingAssetTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * 
 * @export
 * @interface GetStocksAggregates200Response
 */
export interface GetStocksAggregates200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetStocksAggregates200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetStocksAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetStocksAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetStocksAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetStocksAggregates200ResponseAllOfResultsInner>}
     * @memberof GetStocksAggregates200Response
     */
    'results'?: Array<GetStocksAggregates200ResponseAllOfResultsInner>;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetStocksAggregates200Response
     */
    'next_url'?: string;
}
/**
 * 
 * @export
 * @interface GetStocksAggregates200ResponseAllOfResultsInner
 */
export interface GetStocksAggregates200ResponseAllOfResultsInner {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface GetStocksQuotes200Response
 */
export interface GetStocksQuotes200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetStocksQuotes200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksQuotes200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetStocksQuotes200ResponseResultsInner>}
     * @memberof GetStocksQuotes200Response
     */
    'results'?: Array<GetStocksQuotes200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksQuotes200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetStocksQuotes200ResponseResultsInner
 */
export interface GetStocksQuotes200ResponseResultsInner {
    /**
     * The ask exchange ID
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'ask_exchange'?: number;
    /**
     * The ask price.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'ask_price'?: number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'ask_size'?: number;
    /**
     * The bid exchange ID
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'bid_exchange'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'bid_price'?: number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'bid_size'?: number;
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * A list of indicator codes.
     * @type {Array<number>}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'indicators'?: Array<number>;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'participant_timestamp': number;
    /**
     * The sequence number represents the sequence in which quote events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'sequence_number': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'sip_timestamp': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'tape'?: number;
    /**
     * The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this quote.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'trf_timestamp'?: number;
}
/**
 * 
 * @export
 * @interface GetStocksSnapshotDirection200Response
 */
export interface GetStocksSnapshotDirection200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksSnapshotDirection200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof GetStocksSnapshotDirection200Response
     */
    'tickers'?: Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface GetStocksSnapshotTicker200Response
 */
export interface GetStocksSnapshotTicker200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksSnapshotTicker200Response
     */
    'status': string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksSnapshotTicker200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetStocksSnapshotTicker200ResponseAllOfTicker}
     * @memberof GetStocksSnapshotTicker200Response
     */
    'ticker'?: GetStocksSnapshotTicker200ResponseAllOfTicker;
}
/**
 * Contains the requested snapshot data for the specified ticker.
 * @export
 * @interface GetStocksSnapshotTicker200ResponseAllOfTicker
 */
export interface GetStocksSnapshotTicker200ResponseAllOfTicker {
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'day'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'lastQuote'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'lastTrade'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'min'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'prevDay'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'ticker'?: string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChange'?: number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChangePerc'?: number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'updated'?: number;
}
/**
 * 
 * @export
 * @interface GetStocksSnapshotTickers200Response
 */
export interface GetStocksSnapshotTickers200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200Response
     */
    'count'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksSnapshotTickers200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof GetStocksSnapshotTickers200Response
     */
    'tickers'?: Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInner
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInner {
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'day'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://polygon.io/contact\">contact us</a>.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'lastQuote'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'lastTrade'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'min'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'prevDay'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'ticker'?: string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChange'?: number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChangePerc'?: number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'updated'?: number;
}
/**
 * The most recent daily bar for this ticker.
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'otc'?: boolean;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'vw': number;
}
/**
 * The most recent quote for this ticker.  This is only returned if your current plan includes quotes.
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'P': number;
    /**
     * The ask size in lots.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'S': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'p': number;
    /**
     * The bid size in lots.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    's': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    't': number;
}
/**
 * The most recent trade for this ticker.  This is only returned if your current plan includes trades.
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade {
    /**
     * The trade conditions.
     * @type {Array<number>}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'p': number;
    /**
     * The size (volume) of the trade.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    's': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'x': number;
}
/**
 * The most recent minute bar for this ticker.
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin {
    /**
     * The accumulated volume.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'av': number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'vw': number;
}
/**
 * The previous day\'s bar for this ticker.
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'otc'?: boolean;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface GetStocksTrades200Response
 */
export interface GetStocksTrades200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetStocksTrades200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksTrades200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetStocksTrades200ResponseResultsInner>}
     * @memberof GetStocksTrades200Response
     */
    'results'?: Array<GetStocksTrades200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksTrades200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetStocksTrades200ResponseResultsInner
 */
export interface GetStocksTrades200ResponseResultsInner {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * The trade correction indicator.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'correction'?: number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'exchange': number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
     * @type {string}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'id': string;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'participant_timestamp': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'price': number;
    /**
     * The sequence number represents the sequence in which trade events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'sequence_number': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'sip_timestamp': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'size': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'tape'?: number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'trf_id'?: number;
    /**
     * The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this trade.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'trf_timestamp'?: number;
}
/**
 * 
 * @export
 * @interface GetStocksV1ShortInterest200Response
 */
export interface GetStocksV1ShortInterest200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetStocksV1ShortInterest200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksV1ShortInterest200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetStocksV1ShortInterest200ResponseResultsInner>}
     * @memberof GetStocksV1ShortInterest200Response
     */
    'results': Array<GetStocksV1ShortInterest200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksV1ShortInterest200Response
     */
    'status': GetStocksV1ShortInterest200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStocksV1ShortInterest200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetStocksV1ShortInterest200ResponseResultsInner
 */
export interface GetStocksV1ShortInterest200ResponseResultsInner {
    /**
     * The average daily trading volume for the stock over a specified period, typically used to contextualize short interest.
     * @type {number}
     * @memberof GetStocksV1ShortInterest200ResponseResultsInner
     */
    'avg_daily_volume': number;
    /**
     * Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume.
     * @type {number}
     * @memberof GetStocksV1ShortInterest200ResponseResultsInner
     */
    'days_to_cover': number;
    /**
     * The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
     * @type {string}
     * @memberof GetStocksV1ShortInterest200ResponseResultsInner
     */
    'settlement_date': string;
    /**
     * The total number of shares that have been sold short but have not yet been covered or closed out.
     * @type {number}
     * @memberof GetStocksV1ShortInterest200ResponseResultsInner
     */
    'short_interest'?: number;
    /**
     * The primary ticker symbol for the stock.
     * @type {string}
     * @memberof GetStocksV1ShortInterest200ResponseResultsInner
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetStocksV1ShortVolume200Response
 */
export interface GetStocksV1ShortVolume200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetStocksV1ShortVolume200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksV1ShortVolume200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetStocksV1ShortVolume200ResponseResultsInner>}
     * @memberof GetStocksV1ShortVolume200Response
     */
    'results': Array<GetStocksV1ShortVolume200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksV1ShortVolume200Response
     */
    'status': GetStocksV1ShortVolume200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStocksV1ShortVolume200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetStocksV1ShortVolume200ResponseResultsInner
 */
export interface GetStocksV1ShortVolume200ResponseResultsInner {
    /**
     * Short volume reported via the Alternative Display Facility (ADF), excluding exempt volume.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'adf_short_volume'?: number;
    /**
     * Short volume reported via ADF that was marked as exempt.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'adf_short_volume_exempt'?: number;
    /**
     * The date of trade activity reported in the format YYYY-MM-DD
     * @type {string}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'date': string;
    /**
     * Portion of short volume that was marked as exempt from regulation SHO.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'exempt_volume'?: number;
    /**
     * Short volume reported from Nasdaq\'s Carteret facility, excluding exempt volume.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nasdaq_carteret_short_volume'?: number;
    /**
     * Short volume from Nasdaq Carteret that was marked as exempt.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nasdaq_carteret_short_volume_exempt'?: number;
    /**
     * Short volume reported from Nasdaq\'s Chicago facility, excluding exempt volume.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nasdaq_chicago_short_volume'?: number;
    /**
     * Short volume from Nasdaq Chicago that was marked as exempt.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nasdaq_chicago_short_volume_exempt'?: number;
    /**
     * Portion of short volume that was not exempt from regulation SHO (i.e., short_volume - exempt_volume).
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'non_exempt_volume'?: number;
    /**
     * Short volume reported from NYSE facilities, excluding exempt volume.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nyse_short_volume'?: number;
    /**
     * Short volume from NYSE facilities that was marked as exempt.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nyse_short_volume_exempt'?: number;
    /**
     * Total number of shares sold short across all venues for the ticker on the given date.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'short_volume'?: number;
    /**
     * The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'short_volume_ratio'?: number;
    /**
     * The primary ticker symbol for the stock.
     * @type {string}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * Total reported volume across all venues for the ticker on the given date.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'total_volume'?: number;
}
/**
 * 
 * @export
 * @interface GetTicker200Response
 */
export interface GetTicker200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetTicker200Response
     */
    'count'?: number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetTicker200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {GetTicker200ResponseResults}
     * @memberof GetTicker200Response
     */
    'results'?: GetTicker200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetTicker200Response
     */
    'status'?: string;
}
/**
 * Ticker with details.
 * @export
 * @interface GetTicker200ResponseResults
 */
export interface GetTicker200ResponseResults {
    /**
     * Whether or not the asset is actively traded. False means the asset has been delisted.
     * @type {boolean}
     * @memberof GetTicker200ResponseResults
     */
    'active': boolean;
    /**
     * 
     * @type {GetTicker200ResponseResultsAddress}
     * @memberof GetTicker200ResponseResults
     */
    'address'?: GetTicker200ResponseResultsAddress;
    /**
     * 
     * @type {GetTicker200ResponseResultsBranding}
     * @memberof GetTicker200ResponseResults
     */
    'branding'?: GetTicker200ResponseResultsBranding;
    /**
     * The CIK number for this ticker. Find more information [here](https://en.wikipedia.org/wiki/Central_Index_Key).
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'cik'?: string;
    /**
     * The composite OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'composite_figi'?: string;
    /**
     * The name of the currency that this asset is traded with.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'currency_name': string;
    /**
     * The last date that the asset was traded.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'delisted_utc'?: string;
    /**
     * A description of the company and what they do/offer.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'description'?: string;
    /**
     * The URL of the company\'s website homepage.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'homepage_url'?: string;
    /**
     * The date that the symbol was first publicly listed in the format YYYY-MM-DD.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'list_date'?: string;
    /**
     * The locale of the asset.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'locale': GetTicker200ResponseResultsLocaleEnum;
    /**
     * The market type of the asset.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'market': GetTicker200ResponseResultsMarketEnum;
    /**
     * The most recent close price of the ticker multiplied by weighted outstanding shares.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'market_cap'?: number;
    /**
     * The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'name': string;
    /**
     * The phone number for the company behind this ticker.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'phone_number'?: string;
    /**
     * The ISO code of the primary listing exchange for this asset.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'primary_exchange'?: string;
    /**
     * Round lot size of this security.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'round_lot'?: number;
    /**
     * The share Class OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'share_class_figi'?: string;
    /**
     * The recorded number of outstanding shares for this particular share class.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'share_class_shares_outstanding'?: number;
    /**
     * The standard industrial classification code for this ticker.  For a list of SIC Codes, see the SEC\'s <a rel=\"nofollow\" target=\"_blank\" href=\"https://www.sec.gov/info/edgar/siccodes.htm\">SIC Code List</a>.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'sic_code'?: string;
    /**
     * A description of this ticker\'s SIC code.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'sic_description'?: string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'ticker': string;
    /**
     * The root of a specified ticker. For example, the root of BRK.A is BRK.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'ticker_root'?: string;
    /**
     * The suffix of a specified ticker. For example, the suffix of BRK.A is A.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'ticker_suffix'?: string;
    /**
     * The approximate number of employees for the company.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'total_employees'?: number;
    /**
     * The type of the asset. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types).
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'type'?: string;
    /**
     * The shares outstanding calculated assuming all shares of other share classes are converted to this share class.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'weighted_shares_outstanding'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetTicker200ResponseResultsLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTicker200ResponseResultsMarketEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Fx = 'fx',
    Otc = 'otc',
    Indices = 'indices'
}

/**
 * Company headquarters address details.
 * @export
 * @interface GetTicker200ResponseResultsAddress
 */
export interface GetTicker200ResponseResultsAddress {
    /**
     * The first line of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'address1'?: string;
    /**
     * The second line of the company\'s headquarters address, if applicable.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'address2'?: string;
    /**
     * The city of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'city'?: string;
    /**
     * The postal code of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'postal_code'?: string;
    /**
     * The state of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'state'?: string;
}
/**
 * Provides URLs aiding in visual identification.
 * @export
 * @interface GetTicker200ResponseResultsBranding
 */
export interface GetTicker200ResponseResultsBranding {
    /**
     * A link to this ticker\'s company\'s icon. Icon\'s are generally smaller, square images that represent the company at a glance. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof GetTicker200ResponseResultsBranding
     */
    'icon_url'?: string;
    /**
     * A link to this ticker\'s company\'s logo. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof GetTicker200ResponseResultsBranding
     */
    'logo_url'?: string;
}
/**
 * 
 * @export
 * @interface IndexAggsBase
 */
export interface IndexAggsBase {
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof IndexAggsBase
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof IndexAggsBase
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof IndexAggsBase
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof IndexAggsBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface IndicesGroupedResults
 */
export interface IndicesGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetPreviousIndicesAggregates200ResponseAllOfResultsInner>}
     * @memberof IndicesGroupedResults
     */
    'results'?: Array<GetPreviousIndicesAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface IndicesOpenClose
 */
export interface IndicesOpenClose {
    /**
     * The close value of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'afterHours'?: number;
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof IndicesOpenClose
     */
    'from': string;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'high': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'low': number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'open': number;
    /**
     * The open value of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof IndicesOpenClose
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof IndicesOpenClose
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface IndicesTickerResults
 */
export interface IndicesTickerResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<IndicesTickerResultsResultsInner>}
     * @memberof IndicesTickerResults
     */
    'results'?: Array<IndicesTickerResultsResultsInner>;
}
/**
 * 
 * @export
 * @interface IndicesTickerResultsResultsInner
 */
export interface IndicesTickerResultsResultsInner {
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'c': number;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'h': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'n'?: number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    't': number;
}
/**
 * 
 * @export
 * @interface ListConditions200Response
 */
export interface ListConditions200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListConditions200Response
     */
    'count': number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListConditions200Response
     */
    'next_url'?: string;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListConditions200Response
     */
    'request_id': string;
    /**
     * An array of conditions that match your query.
     * @type {Array<ListConditions200ResponseResultsInner>}
     * @memberof ListConditions200Response
     */
    'results': Array<ListConditions200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListConditions200Response
     */
    'status': string;
}
/**
 * A condition generally refers to any extra information passed in a trade or a quote. These conditions may or may not affect the behavior of aggregates.
 * @export
 * @interface ListConditions200ResponseResultsInner
 */
export interface ListConditions200ResponseResultsInner {
    /**
     * A commonly-used abbreviation for this condition.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'abbreviation'?: string;
    /**
     * An identifier for a group of similar financial instruments.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'asset_class': ListConditions200ResponseResultsInnerAssetClassEnum;
    /**
     * Data types that this condition applies to.
     * @type {Array<string>}
     * @memberof ListConditions200ResponseResultsInner
     */
    'data_types': Array<ListConditions200ResponseResultsInnerDataTypesEnum>;
    /**
     * A short description of the semantics of this condition.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'description'?: string;
    /**
     * If present, mapping this condition from a Polygon.io code to a SIP symbol depends on this attribute. In other words, data with this condition attached comes exclusively from the given exchange.
     * @type {number}
     * @memberof ListConditions200ResponseResultsInner
     */
    'exchange'?: number;
    /**
     * An identifier used by Polygon.io for this condition. Unique per data type.
     * @type {number}
     * @memberof ListConditions200ResponseResultsInner
     */
    'id': number;
    /**
     * If true, this condition is from an old version of the SIPs\' specs and no longer is used. Other conditions may or may not reuse the same symbol as this one.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInner
     */
    'legacy'?: boolean;
    /**
     * The name of this condition.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'name': string;
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerSipMapping}
     * @memberof ListConditions200ResponseResultsInner
     */
    'sip_mapping': ListConditions200ResponseResultsInnerSipMapping;
    /**
     * An identifier for a collection of related conditions.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'type': ListConditions200ResponseResultsInnerTypeEnum;
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerUpdateRules}
     * @memberof ListConditions200ResponseResultsInner
     */
    'update_rules'?: ListConditions200ResponseResultsInnerUpdateRules;
}

/**
    * @export
    * @enum {string}
    */
export enum ListConditions200ResponseResultsInnerAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx'
}
/**
    * @export
    * @enum {string}
    */
export enum ListConditions200ResponseResultsInnerDataTypesEnum {
    Trade = 'trade',
    Bbo = 'bbo',
    Nbbo = 'nbbo'
}
/**
    * @export
    * @enum {string}
    */
export enum ListConditions200ResponseResultsInnerTypeEnum {
    SaleCondition = 'sale_condition',
    QuoteCondition = 'quote_condition',
    SipGeneratedFlag = 'sip_generated_flag',
    FinancialStatusIndicator = 'financial_status_indicator',
    ShortSaleRestrictionIndicator = 'short_sale_restriction_indicator',
    SettlementCondition = 'settlement_condition',
    MarketCondition = 'market_condition',
    TradeThruExempt = 'trade_thru_exempt'
}

/**
 * A comprehensive mapping that translates condition codes from individual SIPs (CTA, OPRA, UTP) to a unified code used by Polygon.io. This facilitates consistent interpretation and application of market data conditions across different data streams, ensuring that users can accurately apply these conditions to their data analysis and reporting.
 * @export
 * @interface ListConditions200ResponseResultsInnerSipMapping
 */
export interface ListConditions200ResponseResultsInnerSipMapping {
    /**
     * Condition code from the Consolidated Tape Association (CTA).
     * @type {string}
     * @memberof ListConditions200ResponseResultsInnerSipMapping
     */
    'CTA'?: string;
    /**
     * Condition code from the Options Price Reporting Authority (OPRA).
     * @type {string}
     * @memberof ListConditions200ResponseResultsInnerSipMapping
     */
    'OPRA'?: string;
    /**
     * Condition code from UTP Plan (UTP).
     * @type {string}
     * @memberof ListConditions200ResponseResultsInnerSipMapping
     */
    'UTP'?: string;
}
/**
 * A list of aggregation rules.
 * @export
 * @interface ListConditions200ResponseResultsInnerUpdateRules
 */
export interface ListConditions200ResponseResultsInnerUpdateRules {
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerUpdateRulesConsolidated}
     * @memberof ListConditions200ResponseResultsInnerUpdateRules
     */
    'consolidated': ListConditions200ResponseResultsInnerUpdateRulesConsolidated;
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerUpdateRulesMarketCenter}
     * @memberof ListConditions200ResponseResultsInnerUpdateRules
     */
    'market_center': ListConditions200ResponseResultsInnerUpdateRulesMarketCenter;
}
/**
 * Describes aggregation rules on a consolidated (all exchanges) basis.
 * @export
 * @interface ListConditions200ResponseResultsInnerUpdateRulesConsolidated
 */
export interface ListConditions200ResponseResultsInnerUpdateRulesConsolidated {
    /**
     * Whether or not trades with this condition update the high/low.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesConsolidated
     */
    'updates_high_low': boolean;
    /**
     * Whether or not trades with this condition update the open/close.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesConsolidated
     */
    'updates_open_close': boolean;
    /**
     * Whether or not trades with this condition update the volume.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesConsolidated
     */
    'updates_volume': boolean;
}
/**
 * Describes aggregation rules on a per-market-center basis.
 * @export
 * @interface ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
 */
export interface ListConditions200ResponseResultsInnerUpdateRulesMarketCenter {
    /**
     * Whether or not trades with this condition update the high/low.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
     */
    'updates_high_low': boolean;
    /**
     * Whether or not trades with this condition update the open/close.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
     */
    'updates_open_close': boolean;
    /**
     * Whether or not trades with this condition update the volume.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
     */
    'updates_volume': boolean;
}
/**
 * 
 * @export
 * @interface ListConditions400Response
 */
export interface ListConditions400Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListConditions400Response
     */
    'count': number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListConditions400Response
     */
    'next_url'?: string;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListConditions400Response
     */
    'request_id': string;
    /**
     * An array of conditions that match your query.
     * @type {Array<ListConditions200ResponseResultsInner>}
     * @memberof ListConditions400Response
     */
    'results': Array<ListConditions200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListConditions400Response
     */
    'status': string;
}
/**
 * A list of dividends.
 * @export
 * @interface ListDividends200Response
 */
export interface ListDividends200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListDividends200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListDividends200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListDividends200ResponseResultsInner>}
     * @memberof ListDividends200Response
     */
    'results'?: Array<ListDividends200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListDividends200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListDividends200ResponseResultsInner
 */
export interface ListDividends200ResponseResultsInner {
    /**
     * The cash amount of the dividend per share owned.
     * @type {number}
     * @memberof ListDividends200ResponseResultsInner
     */
    'cash_amount': number;
    /**
     * The currency in which the dividend is paid.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * The date that the dividend was announced.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'declaration_date'?: string;
    /**
     * The type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC. Long-Term and Short-Term capital gain distributions are denoted as LT and ST, respectively.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'dividend_type': ListDividends200ResponseResultsInnerDividendTypeEnum;
    /**
     * The date that the stock first trades without the dividend, determined by the exchange.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'ex_dividend_date': string;
    /**
     * The number of times per year the dividend is paid out. Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
     * @type {number}
     * @memberof ListDividends200ResponseResultsInner
     */
    'frequency': number;
    /**
     * The unique identifier of the dividend.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'id': string;
    /**
     * The date that the dividend is paid out.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'pay_date'?: string;
    /**
     * The date that the stock must be held to receive the dividend, set by the company.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'record_date'?: string;
    /**
     * The ticker symbol of the dividend.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListDividends200ResponseResultsInnerDividendTypeEnum {
    Cd = 'CD',
    Sc = 'SC',
    Lt = 'LT',
    St = 'ST'
}

/**
 * 
 * @export
 * @interface ListExchanges200Response
 */
export interface ListExchanges200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListExchanges200Response
     */
    'count'?: number;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListExchanges200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListExchanges200ResponseResultsInner>}
     * @memberof ListExchanges200Response
     */
    'results'?: Array<ListExchanges200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListExchanges200Response
     */
    'status': string;
}
/**
 * An entity that reports trades.
 * @export
 * @interface ListExchanges200ResponseResultsInner
 */
export interface ListExchanges200ResponseResultsInner {
    /**
     * A commonly used abbreviation for this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'acronym'?: string;
    /**
     * An identifier for a group of similar financial instruments.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'asset_class': ListExchanges200ResponseResultsInnerAssetClassEnum;
    /**
     * A unique identifier used by Polygon.io for this exchange.
     * @type {number}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'id': number;
    /**
     * An identifier for a geographical location.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'locale': ListExchanges200ResponseResultsInnerLocaleEnum;
    /**
     * The Market Identifier Code of this exchange (see ISO 10383).
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'mic'?: string;
    /**
     * Name of this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'name': string;
    /**
     * The MIC of the entity that operates this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'operating_mic'?: string;
    /**
     * The ID used by SIP\'s to represent this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'participant_id'?: string;
    /**
     * Represents the type of exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'type': ListExchanges200ResponseResultsInnerTypeEnum;
    /**
     * A link to this exchange\'s website, if one exists.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'url'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListExchanges200ResponseResultsInnerAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx'
}
/**
    * @export
    * @enum {string}
    */
export enum ListExchanges200ResponseResultsInnerLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
    * @export
    * @enum {string}
    */
export enum ListExchanges200ResponseResultsInnerTypeEnum {
    Exchange = 'exchange',
    Trf = 'TRF',
    Sip = 'SIP'
}

/**
 * 
 * @export
 * @interface ListExchanges400Response
 */
export interface ListExchanges400Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListExchanges400Response
     */
    'count'?: number;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListExchanges400Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListExchanges400Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ListFinancials200Response
 */
export interface ListFinancials200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListFinancials200Response
     */
    'count': number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListFinancials200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListFinancials200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListFinancials200ResponseResultsInner>}
     * @memberof ListFinancials200Response
     */
    'results': Array<ListFinancials200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListFinancials200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ListFinancials200ResponseResultsInner
 */
export interface ListFinancials200ResponseResultsInner {
    /**
     * The datetime (EST timezone) the filing was accepted by EDGAR in YYYYMMDDHHMMSS format.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'acceptance_datetime'?: string;
    /**
     * The CIK number for the company.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'cik': string;
    /**
     * The company name.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'company_name': string;
    /**
     * The end date of the period that these financials cover in YYYYMMDD format.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'end_date'?: string;
    /**
     * The date that the SEC filing which these financials were derived from was made available. Note that this is not necessarily the date when this information became public, as some companies may publish a press release before filing with the SEC.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'filing_date'?: string;
    /**
     * 
     * @type {ListFinancials200ResponseResultsInnerFinancials}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'financials': ListFinancials200ResponseResultsInnerFinancials;
    /**
     * Fiscal period of the report according to the company (Q1, Q2, Q3, Q4, or FY).
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'fiscal_period': string;
    /**
     * Fiscal year of the report according to the company.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'fiscal_year'?: string;
    /**
     * The Standard Industrial Classification (SIC) code for the company.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'sic'?: string;
    /**
     * The URL of the specific XBRL instance document within the SEC filing that these financials were derived from.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'source_filing_file_url'?: string;
    /**
     * The URL of the SEC filing that these financials were derived from.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'source_filing_url'?: string;
    /**
     * The start date of the period that these financials cover in YYYYMMDD format.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'start_date'?: string;
    /**
     * The list of ticker symbols for the company.
     * @type {Array<string>}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'tickers'?: Array<string>;
    /**
     * The timeframe of the report (quarterly, annual or ttm).
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'timeframe': string;
}
/**
 * Structured financial statements with detailed data points and metadata.
 * @export
 * @interface ListFinancials200ResponseResultsInnerFinancials
 */
export interface ListFinancials200ResponseResultsInnerFinancials {
    /**
     * 
     * @type {ListFinancials200ResponseResultsInnerFinancialsBalanceSheet}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'balance_sheet'?: ListFinancials200ResponseResultsInnerFinancialsBalanceSheet;
    /**
     * Cash flow statement. The keys in this object can be any of the fields listed in the Cash Flow Statement section of the <a target=\"_blank\" href=\"https://polygon.io/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>. See the attributes of the objects within `balance_sheet` for more details.
     * @type {object}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'cash_flow_statement'?: object;
    /**
     * Comprehensive income. The keys in this object can be any of the fields listed in the Comprehensive Income section of the <a target=\"_blank\" href=\"https://polygon.io/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>. See the attributes of the objects within `balance_sheet` for more details.
     * @type {object}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'comprehensive_income'?: object;
    /**
     * Income statement. The keys in this object can be any of the fields listed in the Income Statement section of the <a target=\"_blank\" href=\"https://polygon.io/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>. See the attributes of the objects within `balance_sheet` for more details.
     * @type {object}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'income_statement'?: object;
}
/**
 * Balance sheet. The keys in this object can be any of the fields listed in the Balance Sheet section of the <a target=\"_blank\" href=\"https://polygon.io/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>.
 * @export
 * @interface ListFinancials200ResponseResultsInnerFinancialsBalanceSheet
 */
export interface ListFinancials200ResponseResultsInnerFinancialsBalanceSheet {
    /**
     * 
     * @type {ListFinancials200ResponseResultsInnerFinancialsBalanceSheet}
     * @memberof ListFinancials200ResponseResultsInnerFinancialsBalanceSheet
     */
    '*'?: ListFinancials200ResponseResultsInnerFinancialsBalanceSheet;
}
/**
 * 
 * @export
 * @interface ListIPOs200Response
 */
export interface ListIPOs200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListIPOs200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListIPOs200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListIPOs200ResponseResultsInner>}
     * @memberof ListIPOs200Response
     */
    'results'?: Array<ListIPOs200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListIPOs200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListIPOs200ResponseResultsInner
 */
export interface ListIPOs200ResponseResultsInner {
    /**
     * The date when the IPO event was announced.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'announced_date'?: string;
    /**
     * Underlying currency of the security.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'currency_code'?: string;
    /**
     * The price set by the company and its underwriters before the IPO goes live.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'final_issue_price'?: number;
    /**
     * The highest price within the IPO price range that the company might use to price the shares.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'highest_offer_price'?: number;
    /**
     * The status of the IPO event. IPO events start out as status \"rumor\" or \"pending\". On listing day, the status changes to \"new\". After the listing day, the status changes to \"history\".  The status \"direct_listing_process\" corresponds to a type of offering where, instead of going through all the IPO processes, the company decides to list its shares directly on an exchange, without using an investment bank or other intermediaries. This is called a direct listing, direct placement, or direct public offering (DPO).
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'ipo_status': ListIPOs200ResponseResultsInnerIpoStatusEnum;
    /**
     * International Securities Identification Number. This is a unique twelve-digit code that is assigned to every security issuance in the world.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'isin'?: string;
    /**
     * Name of issuer.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'issuer_name': string;
    /**
     * The date when the IPO event was last modified.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'last_updated': string;
    /**
     * First trading date for the newly listed entity.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'listing_date'?: string;
    /**
     * The minimum number of shares that can be bought or sold in a single transaction.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'lot_size'?: number;
    /**
     * The lowest price within the IPO price range that the company is willing to offer its shares to investors.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'lowest_offer_price'?: number;
    /**
     * The upper limit of the shares that the company is offering to investors.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'max_shares_offered'?: number;
    /**
     * The lower limit of shares that the company is willing to sell in the IPO.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'min_shares_offered'?: number;
    /**
     * Market Identifier Code (MIC) of the primary exchange where the security is listed. The Market Identifier Code (MIC) (ISO 10383) is a unique identification code used to identify securities trading exchanges, regulated and non-regulated trading markets.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'primary_exchange'?: string;
    /**
     * Description of the security.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'security_description'?: string;
    /**
     * The classification of the stock. For example, \"CS\" stands for Common Stock.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'security_type': string;
    /**
     * The total number of shares that the company has issued and are held by investors.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'shares_outstanding'?: number;
    /**
     * The ticker symbol of the IPO event.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The total amount raised by the company for IPO.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'total_offer_size'?: number;
    /**
     * This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'us_code'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListIPOs200ResponseResultsInnerIpoStatusEnum {
    DirectListingProcess = 'direct_listing_process',
    History = 'history',
    New = 'new',
    Pending = 'pending',
    Postponed = 'postponed',
    Rumor = 'rumor',
    Withdrawn = 'withdrawn'
}

/**
 * 
 * @export
 * @interface ListNews200Response
 */
export interface ListNews200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListNews200Response
     */
    'count'?: number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListNews200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListNews200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListNews200ResponseResultsInner>}
     * @memberof ListNews200Response
     */
    'results'?: Array<ListNews200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListNews200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListNews200ResponseResultsInner
 */
export interface ListNews200ResponseResultsInner {
    /**
     * The mobile friendly Accelerated Mobile Page (AMP) URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'amp_url'?: string;
    /**
     * A link to the news article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'article_url': string;
    /**
     * The article\'s author.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'author': string;
    /**
     * A description of the article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'description'?: string;
    /**
     * Unique identifier for the article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'id': string;
    /**
     * The article\'s image URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'image_url'?: string;
    /**
     * The insights related to the article.
     * @type {Array<ListNews200ResponseResultsInnerInsightsInner>}
     * @memberof ListNews200ResponseResultsInner
     */
    'insights'?: Array<ListNews200ResponseResultsInnerInsightsInner>;
    /**
     * The keywords associated with the article (which will vary depending on the publishing source).
     * @type {Array<string>}
     * @memberof ListNews200ResponseResultsInner
     */
    'keywords'?: Array<string>;
    /**
     * The UTC date and time when the article was published, formatted in RFC3339 standard (e.g. YYYY-MM-DDTHH:MM:SSZ).
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'published_utc': string;
    /**
     * 
     * @type {ListNews200ResponseResultsInnerPublisher}
     * @memberof ListNews200ResponseResultsInner
     */
    'publisher': ListNews200ResponseResultsInnerPublisher;
    /**
     * The ticker symbols associated with the article.
     * @type {Array<string>}
     * @memberof ListNews200ResponseResultsInner
     */
    'tickers': Array<string>;
    /**
     * The title of the news article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ListNews200ResponseResultsInnerInsightsInner
 */
export interface ListNews200ResponseResultsInnerInsightsInner {
    /**
     * The sentiment of the insight.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerInsightsInner
     */
    'sentiment': ListNews200ResponseResultsInnerInsightsInnerSentimentEnum;
    /**
     * The reasoning behind the sentiment.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerInsightsInner
     */
    'sentiment_reasoning': string;
    /**
     * The ticker symbol associated with the insight.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerInsightsInner
     */
    'ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListNews200ResponseResultsInnerInsightsInnerSentimentEnum {
    Positive = 'positive',
    Neutral = 'neutral',
    Negative = 'negative'
}

/**
 * Details the source of the news article, including the publisher\'s name, logo, and homepage URLs. This information helps users identify and access the original source of news content.
 * @export
 * @interface ListNews200ResponseResultsInnerPublisher
 */
export interface ListNews200ResponseResultsInnerPublisher {
    /**
     * The publisher\'s homepage favicon URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'favicon_url'?: string;
    /**
     * The publisher\'s homepage URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'homepage_url': string;
    /**
     * The publisher\'s logo URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'logo_url': string;
    /**
     * The publisher\'s name.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'name': string;
}
/**
 * @type ListNewsPublishedUtcParameter
 * @export
 */
export type ListNewsPublishedUtcParameter = string;

/**
 * 
 * @export
 * @interface ListOptionsContracts200Response
 */
export interface ListOptionsContracts200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListOptionsContracts200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListOptionsContracts200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListOptionsContracts200ResponseResultsInner>}
     * @memberof ListOptionsContracts200Response
     */
    'results'?: Array<ListOptionsContracts200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListOptionsContracts200Response
     */
    'status'?: string;
}
/**
 * Contains the requested data for the specified options contract.
 * @export
 * @interface ListOptionsContracts200ResponseResultsInner
 */
export interface ListOptionsContracts200ResponseResultsInner {
    /**
     * If an option contract has additional underlyings or deliverables associated with it, they will appear here. See <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"https://www.optionseducation.org/referencelibrary/faq/splits-mergers-spinoffs-bankruptcies\">here</a> for some examples of what might cause a contract to have additional underlyings.
     * @type {Array<ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner>}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'additional_underlyings'?: Array<ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner>;
    /**
     * The 6 letter CFI code of the contract (defined in <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/ISO_10962\">ISO 10962</a>)
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'cfi'?: string;
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'contract_type'?: string;
    /**
     * The correction number for this option contract.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'correction'?: number;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'exercise_style'?: ListOptionsContracts200ResponseResultsInnerExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'expiration_date'?: string;
    /**
     * The MIC code of the primary exchange that this contract is listed on.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'primary_exchange'?: string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'shares_per_contract'?: number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'strike_price'?: number;
    /**
     * The ticker for the option contract.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The underlying ticker that the option contract relates to.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'underlying_ticker'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListOptionsContracts200ResponseResultsInnerExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * 
 * @export
 * @interface ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
 */
export interface ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner {
    /**
     * The number of shares per contract of the additional underlying, or the cash-in-lieu amount of the currency.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
     */
    'amount'?: number;
    /**
     * The type of the additional underlying asset, either equity or currency.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
     */
    'type'?: string;
    /**
     * The name of the additional underlying asset.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
     */
    'underlying'?: string;
}
/**
 * 
 * @export
 * @interface ListStockSplits200Response
 */
export interface ListStockSplits200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListStockSplits200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListStockSplits200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListStockSplits200ResponseResultsInner>}
     * @memberof ListStockSplits200Response
     */
    'results'?: Array<ListStockSplits200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListStockSplits200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListStockSplits200ResponseResultsInner
 */
export interface ListStockSplits200ResponseResultsInner {
    /**
     * The execution date of the stock split. On this date the stock split was applied.
     * @type {string}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'execution_date': string;
    /**
     * The unique identifier for this stock split.
     * @type {string}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'id': string;
    /**
     * The second number in the split ratio.  For example: In a 2-for-1 split, split_from would be 1.
     * @type {number}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'split_from': number;
    /**
     * The first number in the split ratio.  For example: In a 2-for-1 split, split_to would be 2.
     * @type {number}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'split_to': number;
    /**
     * The ticker symbol of the stock split.
     * @type {string}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'ticker': string;
}
/**
 * 
 * @export
 * @interface ListTickerTypes200Response
 */
export interface ListTickerTypes200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListTickerTypes200Response
     */
    'count'?: number;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListTickerTypes200Response
     */
    'request_id': string;
    /**
     * 
     * @type {Array<ListTickerTypes200ResponseResultsInner>}
     * @memberof ListTickerTypes200Response
     */
    'results'?: Array<ListTickerTypes200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListTickerTypes200Response
     */
    'status': string;
}
/**
 * Describes the type of financial instrument represented by a ticker.
 * @export
 * @interface ListTickerTypes200ResponseResultsInner
 */
export interface ListTickerTypes200ResponseResultsInner {
    /**
     * An identifier for a group of similar financial instruments.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'asset_class': ListTickerTypes200ResponseResultsInnerAssetClassEnum;
    /**
     * A code used by Polygon.io to refer to this ticker type.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'code': string;
    /**
     * A short description of this ticker type.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'description': string;
    /**
     * An identifier for a geographical location.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'locale': ListTickerTypes200ResponseResultsInnerLocaleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ListTickerTypes200ResponseResultsInnerAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx',
    Indices = 'indices'
}
/**
    * @export
    * @enum {string}
    */
export enum ListTickerTypes200ResponseResultsInnerLocaleEnum {
    Us = 'us',
    Global = 'global'
}

/**
 * 
 * @export
 * @interface ListTickers200Response
 */
export interface ListTickers200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListTickers200Response
     */
    'count'?: number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListTickers200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListTickers200Response
     */
    'request_id'?: string;
    /**
     * An array of tickers that match your query.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
     * @type {Array<ListTickers200ResponseResultsInner>}
     * @memberof ListTickers200Response
     */
    'results'?: Array<ListTickers200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListTickers200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListTickers200ResponseResultsInner
 */
export interface ListTickers200ResponseResultsInner {
    /**
     * Whether or not the asset is actively traded. False means the asset has been delisted.
     * @type {boolean}
     * @memberof ListTickers200ResponseResultsInner
     */
    'active'?: boolean;
    /**
     * The CIK number for this ticker. Find more information [here](https://en.wikipedia.org/wiki/Central_Index_Key).
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'cik'?: string;
    /**
     * The composite OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'composite_figi'?: string;
    /**
     * The name of the currency that this asset is traded with.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'currency_name'?: string;
    /**
     * The last date that the asset was traded.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'delisted_utc'?: string;
    /**
     * The information is accurate up to this time.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'last_updated_utc'?: string;
    /**
     * The locale of the asset.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'locale': ListTickers200ResponseResultsInnerLocaleEnum;
    /**
     * The market type of the asset.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'market': ListTickers200ResponseResultsInnerMarketEnum;
    /**
     * The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'name': string;
    /**
     * The ISO code of the primary listing exchange for this asset.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'primary_exchange'?: string;
    /**
     * The share Class OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'share_class_figi'?: string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The type of the asset. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types).
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'type'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListTickers200ResponseResultsInnerLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
    * @export
    * @enum {string}
    */
export enum ListTickers200ResponseResultsInnerMarketEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Fx = 'fx',
    Otc = 'otc',
    Indices = 'indices'
}

/**
 * 
 * @export
 * @interface Locales
 */
export interface Locales {
    /**
     * 
     * @type {Array<LocalesResultsInner>}
     * @memberof Locales
     */
    'results'?: Array<LocalesResultsInner>;
}
/**
 * 
 * @export
 * @interface LocalesResultsInner
 */
export interface LocalesResultsInner {
    /**
     * An abbreviated country name.
     * @type {string}
     * @memberof LocalesResultsInner
     */
    'locale'?: string;
    /**
     * The name of the country.
     * @type {string}
     * @memberof LocalesResultsInner
     */
    'name'?: string;
}
/**
 * A dynamic key from the results set
 * @export
 * @interface MapKey
 */
export interface MapKey {
    /**
     * The descriptive name of this results key
     * @type {string}
     * @memberof MapKey
     */
    'name'?: string;
    /**
     * The data type of this results key
     * @type {string}
     * @memberof MapKey
     */
    'type'?: MapKeyTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum MapKeyTypeEnum {
    String = 'string',
    Int = 'int',
    Int64 = 'int64',
    Float64 = 'float64'
}

/**
 * 
 * @export
 * @interface MarketHolidayInner
 */
export interface MarketHolidayInner {
    /**
     * The market close time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'close'?: string;
    /**
     * The date of the holiday.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'date': string;
    /**
     * Which market the record is for.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'exchange': string;
    /**
     * The name of the holiday.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'name': string;
    /**
     * The market open time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'open'?: string;
    /**
     * The status of the market on the holiday.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface MarketStatus
 */
export interface MarketStatus {
    /**
     * Whether or not the market is in post-market hours.
     * @type {boolean}
     * @memberof MarketStatus
     */
    'afterHours'?: boolean;
    /**
     * 
     * @type {MarketStatusCurrencies}
     * @memberof MarketStatus
     */
    'currencies'?: MarketStatusCurrencies;
    /**
     * Whether or not the market is in pre-market hours.
     * @type {boolean}
     * @memberof MarketStatus
     */
    'earlyHours'?: boolean;
    /**
     * 
     * @type {MarketStatusExchanges}
     * @memberof MarketStatus
     */
    'exchanges'?: MarketStatusExchanges;
    /**
     * The status of the market as a whole.
     * @type {string}
     * @memberof MarketStatus
     */
    'market'?: string;
    /**
     * The current time of the server.
     * @type {string}
     * @memberof MarketStatus
     */
    'serverTime'?: string;
}
/**
 * 
 * @export
 * @interface MarketStatusCurrencies
 */
export interface MarketStatusCurrencies {
    /**
     * The status of the crypto market.
     * @type {string}
     * @memberof MarketStatusCurrencies
     */
    'crypto'?: string;
    /**
     * The status of the forex market.
     * @type {string}
     * @memberof MarketStatusCurrencies
     */
    'fx'?: string;
}
/**
 * 
 * @export
 * @interface MarketStatusExchanges
 */
export interface MarketStatusExchanges {
    /**
     * The status of the Nasdaq market.
     * @type {string}
     * @memberof MarketStatusExchanges
     */
    'nasdaq'?: string;
    /**
     * The status of the NYSE market.
     * @type {string}
     * @memberof MarketStatusExchanges
     */
    'nyse'?: string;
    /**
     * The status of the OTC market.
     * @type {string}
     * @memberof MarketStatusExchanges
     */
    'otc'?: string;
}
/**
 * 
 * @export
 * @interface Markets
 */
export interface Markets {
    /**
     * A list of supported markets.
     * @type {Array<MarketsResultsInner>}
     * @memberof Markets
     */
    'results'?: Array<MarketsResultsInner>;
}
/**
 * 
 * @export
 * @interface MarketsResultsInner
 */
export interface MarketsResultsInner {
    /**
     * A description of the market.
     * @type {string}
     * @memberof MarketsResultsInner
     */
    'desc'?: string;
    /**
     * The name of the market.
     * @type {string}
     * @memberof MarketsResultsInner
     */
    'market'?: string;
}
/**
 * @type ModelDate
 * @export
 */
export type ModelDate = string;

/**
 * A mapping of the keys returned in the results to their descriptive name and data types.
 * @export
 * @interface ModelMap
 */
export interface ModelMap {
    /**
     * 
     * @type {MapKey}
     * @memberof ModelMap
     */
    'key'?: MapKey;
}
/**
 * 
 * @export
 * @interface NewsInner
 */
export interface NewsInner {
    /**
     * A URL of the image for the news article, if found.
     * @type {string}
     * @memberof NewsInner
     */
    'image'?: string;
    /**
     * A list of common keywords related to the news article.
     * @type {Array<string>}
     * @memberof NewsInner
     */
    'keywords'?: Array<string>;
    /**
     * The publication source of the article.
     * @type {string}
     * @memberof NewsInner
     */
    'source'?: string;
    /**
     * A summary of the news article.
     * @type {string}
     * @memberof NewsInner
     */
    'summary'?: string;
    /**
     * A list of ticker symbols relating to the article.
     * @type {Array<string>}
     * @memberof NewsInner
     */
    'symbols'?: Array<string>;
    /**
     * The timestamp of the news article.
     * @type {string}
     * @memberof NewsInner
     */
    'timestamp'?: string;
    /**
     * The title of the news article.
     * @type {string}
     * @memberof NewsInner
     */
    'title'?: string;
    /**
     * A direct link to the news article from its source publication.
     * @type {string}
     * @memberof NewsInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PaginationHooksBase
 */
export interface PaginationHooksBase {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof PaginationHooksBase
     */
    'next_url'?: string;
}
/**
 * 
 * @export
 * @interface RatingSection
 */
export interface RatingSection {
    /**
     * Analyst Rating at current month
     * @type {number}
     * @memberof RatingSection
     */
    'current': number;
    /**
     * Analyst Ratings at 1 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month1': number;
    /**
     * Analyst Ratings at 2 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month2': number;
    /**
     * Analyst Ratings at 3 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month3': number;
    /**
     * Analyst Ratings at 4 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month4'?: number;
    /**
     * Analyst Ratings at 5 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month5'?: number;
}
/**
 * 
 * @export
 * @interface RequestIdBase
 */
export interface RequestIdBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof RequestIdBase
     */
    'request_id': string;
}
/**
 * 
 * @export
 * @interface SnapshotMinOHLCV
 */
export interface SnapshotMinOHLCV {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'c'?: number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'h'?: number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'l'?: number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'o'?: number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    't'?: number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'v'?: number;
}
/**
 * 
 * @export
 * @interface SnapshotOHLCV
 */
export interface SnapshotOHLCV {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'v': number;
}
/**
 * 
 * @export
 * @interface SnapshotOHLCVVW
 */
export interface SnapshotOHLCVVW {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface SnapshotOHLCVVWOtc
 */
export interface SnapshotOHLCVVWOtc {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof SnapshotOHLCVVWOtc
     */
    'otc'?: boolean;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface StandardBase
 */
export interface StandardBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof StandardBase
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof StandardBase
     */
    'count'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StandardBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface StatusBase
 */
export interface StatusBase {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StatusBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface StatusCountBase
 */
export interface StatusCountBase {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof StatusCountBase
     */
    'count'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StatusCountBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface StocksGroupedResults
 */
export interface StocksGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedStocksAggregates200ResponseAllOfResultsInner>}
     * @memberof StocksGroupedResults
     */
    'results'?: Array<GetGroupedStocksAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface StocksOpenClose
 */
export interface StocksOpenClose {
    /**
     * The close price of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'afterHours'?: number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof StocksOpenClose
     */
    'from': string;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'high': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'low': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'open': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof StocksOpenClose
     */
    'otc'?: boolean;
    /**
     * The open price of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StocksOpenClose
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksOpenClose
     */
    'symbol': string;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'volume': number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotLastQuote
 */
export interface StocksSnapshotLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    'P': number;
    /**
     * The ask size in lots.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    'S': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    'p': number;
    /**
     * The bid size in lots.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    's': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    't': number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotMinute
 */
export interface StocksSnapshotMinute {
    /**
     * The accumulated volume.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'av': number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotMinuteOTC
 */
export interface StocksSnapshotMinuteOTC {
    /**
     * The accumulated volume.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'av': number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof StocksSnapshotMinuteOTC
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotTicker
 */
export interface StocksSnapshotTicker {
    /**
     * 
     * @type {GetStocksSnapshotTicker200ResponseAllOfTicker}
     * @memberof StocksSnapshotTicker
     */
    'ticker'?: GetStocksSnapshotTicker200ResponseAllOfTicker;
}
/**
 * 
 * @export
 * @interface StocksSnapshotTickers
 */
export interface StocksSnapshotTickers {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof StocksSnapshotTickers
     */
    'tickers'?: Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface StocksTickerResultsOTC
 */
export interface StocksTickerResultsOTC {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetStocksAggregates200ResponseAllOfResultsInner>}
     * @memberof StocksTickerResultsOTC
     */
    'results'?: Array<GetStocksAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface StocksV2Base
 */
export interface StocksV2Base {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksV2Base
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof StocksV2Base
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof StocksV2Base
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksV2Base
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof StocksV2Base
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface StocksV2NBBO
 */
export interface StocksV2NBBO {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksV2NBBO
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'y': number;
    /**
     * The ask price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'P': number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'S': number;
    /**
     * The ask exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'X': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof StocksV2NBBO
     */
    'c': Array<number>;
    /**
     * The indicators. For more information, see our glossary of [Conditions and Indicators](https://polygon.io/glossary/us/stocks/conditions-indicators). 
     * @type {Array<number>}
     * @memberof StocksV2NBBO
     */
    'i': Array<number>;
    /**
     * The bid price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'p': number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    's': number;
    /**
     * The bid exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface StocksV2NBBOs
 */
export interface StocksV2NBBOs {
    /**
     * 
     * @type {Array<DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner>}
     * @memberof StocksV2NBBOs
     */
    'results'?: Array<DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface StocksV2Trade
 */
export interface StocksV2Trade {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksV2Trade
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof StocksV2Trade
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksV2Trade
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof StocksV2Trade
     */
    'y': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof StocksV2Trade
     */
    'c': Array<number>;
    /**
     * The trade correction indicator. 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'e': number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof StocksV2Trade
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'p': number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place. 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'r': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof StocksV2Trade
     */
    's': number;
    /**
     * The exchange ID. See <a href=\"https://polygon.io/docs/stocks/get_v3_reference_exchanges\" alt=\"Exchanges\">Exchanges</a> for Polygon.io\'s mapping of exchange IDs.
     * @type {number}
     * @memberof StocksV2Trade
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface StocksV2Trades
 */
export interface StocksV2Trades {
    /**
     * 
     * @type {Array<DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner>}
     * @memberof StocksV2Trades
     */
    'results'?: Array<DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface TickerBase
 */
export interface TickerBase {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof TickerBase
     */
    'ticker': string;
}
/**
 * 
 * @export
 * @interface TickerResults
 */
export interface TickerResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof TickerResults
     */
    'results'?: Array<GetCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface TradeDetailsMapItem
 */
export interface TradeDetailsMapItem {
    /**
     * Name of the trade detail item
     * @type {string}
     * @memberof TradeDetailsMapItem
     */
    'name'?: string;
    /**
     * Actual type of the trade detail item
     * @type {string}
     * @memberof TradeDetailsMapItem
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface V1LastBase
 */
export interface V1LastBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V1LastBase
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V1LastBase
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V1LastBase
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface V2AggsBase
 */
export interface V2AggsBase {
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof V2AggsBase
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof V2AggsBase
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2AggsBase
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2AggsBase
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2AggsBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface V2LastBase
 */
export interface V2LastBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2LastBase
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2LastBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface V2TicksBase
 */
export interface V2TicksBase {
    /**
     * Latency in milliseconds for the query results from the database.
     * @type {number}
     * @memberof V2TicksBase
     */
    'db_latency'?: number;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2TicksBase
     */
    'results_count'?: number;
    /**
     * Whether or not this query was executed successfully.
     * @type {boolean}
     * @memberof V2TicksBase
     */
    'success'?: boolean;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2TicksBase
     */
    'ticker'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker Full Book (L2)
         * @param {string} ticker The cryptocurrency ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetCryptoSnapshotTickerBook: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('deprecatedGetCryptoSnapshotTickerBook', 'ticker', ticker)
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}/book`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historic trade ticks for a cryptocurrency pair. 
         * @summary Historic Crypto Trades
         * @param {string} from The \&quot;from\&quot; symbol of the crypto pair.
         * @param {string} to The \&quot;to\&quot; symbol of the crypto pair.
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricCryptoTrades: async (from: string, to: string, date: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('deprecatedGetHistoricCryptoTrades', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('deprecatedGetHistoricCryptoTrades', 'to', to)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('deprecatedGetHistoricCryptoTrades', 'date', date)
            const localVarPath = `/v1/historic/crypto/{from}/{to}/{date}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historic ticks for a forex currency pair. 
         * @summary Historic Forex Ticks
         * @param {string} from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
         * @param {string} to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricForexQuotes: async (from: string, to: string, date: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('deprecatedGetHistoricForexQuotes', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('deprecatedGetHistoricForexQuotes', 'to', to)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('deprecatedGetHistoricForexQuotes', 'date', date)
            const localVarPath = `/v1/historic/forex/{from}/{to}/{date}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get NBBO quotes for a given ticker symbol on a specified date. 
         * @summary Quotes (NBBO)
         * @param {string} ticker The ticker symbol we want quotes for.
         * @param {string} date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricStocksQuotes: async (ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('deprecatedGetHistoricStocksQuotes', 'ticker', ticker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('deprecatedGetHistoricStocksQuotes', 'date', date)
            const localVarPath = `/v2/ticks/stocks/nbbo/{ticker}/{date}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampLimit !== undefined) {
                localVarQueryParameter['timestampLimit'] = timestampLimit;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a given ticker symbol on a specified date. 
         * @summary Trades
         * @param {string} ticker The ticker symbol we want trades for.
         * @param {string} date The date/day of the trades to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricStocksTrades: async (ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('deprecatedGetHistoricStocksTrades', 'ticker', ticker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('deprecatedGetHistoricStocksTrades', 'date', date)
            const localVarPath = `/v2/ticks/stocks/trades/{ticker}/{date}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampLimit !== undefined) {
                localVarQueryParameter['timestampLimit'] = timestampLimit;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [firm] The name of the research firm or investment bank issuing the rating.
         * @param {string} [firmAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [firmGt] Filter greater than the value.
         * @param {string} [firmGte] Filter greater than or equal to the value.
         * @param {string} [firmLt] Filter less than the value.
         * @param {string} [firmLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The identifer used by Benzinga for the firm record.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaRatingId] The identifier used by Benzinga for the rating record.
         * @param {string} [benzingaRatingIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaRatingIdGt] Filter greater than the value.
         * @param {string} [benzingaRatingIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaRatingIdLt] Filter less than the value.
         * @param {string} [benzingaRatingIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1AnalystInsights: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, firm?: string, firmAnyOf?: string, firmGt?: string, firmGte?: string, firmLt?: string, firmLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, benzingaRatingId?: string, benzingaRatingIdAnyOf?: string, benzingaRatingIdGt?: string, benzingaRatingIdGte?: string, benzingaRatingIdLt?: string, benzingaRatingIdLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/analyst-insights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedAnyOf !== undefined) {
                localVarQueryParameter['last_updated.any_of'] = lastUpdatedAnyOf;
            }

            if (lastUpdatedGt !== undefined) {
                localVarQueryParameter['last_updated.gt'] = lastUpdatedGt;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated.gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLt !== undefined) {
                localVarQueryParameter['last_updated.lt'] = lastUpdatedLt;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated.lte'] = lastUpdatedLte;
            }

            if (firm !== undefined) {
                localVarQueryParameter['firm'] = firm;
            }

            if (firmAnyOf !== undefined) {
                localVarQueryParameter['firm.any_of'] = firmAnyOf;
            }

            if (firmGt !== undefined) {
                localVarQueryParameter['firm.gt'] = firmGt;
            }

            if (firmGte !== undefined) {
                localVarQueryParameter['firm.gte'] = firmGte;
            }

            if (firmLt !== undefined) {
                localVarQueryParameter['firm.lt'] = firmLt;
            }

            if (firmLte !== undefined) {
                localVarQueryParameter['firm.lte'] = firmLte;
            }

            if (benzingaFirmId !== undefined) {
                localVarQueryParameter['benzinga_firm_id'] = benzingaFirmId;
            }

            if (benzingaFirmIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_firm_id.any_of'] = benzingaFirmIdAnyOf;
            }

            if (benzingaFirmIdGt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gt'] = benzingaFirmIdGt;
            }

            if (benzingaFirmIdGte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gte'] = benzingaFirmIdGte;
            }

            if (benzingaFirmIdLt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lt'] = benzingaFirmIdLt;
            }

            if (benzingaFirmIdLte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lte'] = benzingaFirmIdLte;
            }

            if (benzingaRatingId !== undefined) {
                localVarQueryParameter['benzinga_rating_id'] = benzingaRatingId;
            }

            if (benzingaRatingIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_rating_id.any_of'] = benzingaRatingIdAnyOf;
            }

            if (benzingaRatingIdGt !== undefined) {
                localVarQueryParameter['benzinga_rating_id.gt'] = benzingaRatingIdGt;
            }

            if (benzingaRatingIdGte !== undefined) {
                localVarQueryParameter['benzinga_rating_id.gte'] = benzingaRatingIdGte;
            }

            if (benzingaRatingIdLt !== undefined) {
                localVarQueryParameter['benzinga_rating_id.lt'] = benzingaRatingIdLt;
            }

            if (benzingaRatingIdLte !== undefined) {
                localVarQueryParameter['benzinga_rating_id.lte'] = benzingaRatingIdLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [benzingaId] The identifier used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The unique identifier assigned by Benzinga to the research firm or investment bank.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {string} [firmName] The name of the research firm or investment bank issuing the ratings.
         * @param {string} [firmNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [firmNameGt] Filter greater than the value.
         * @param {string} [firmNameGte] Filter greater than or equal to the value.
         * @param {string} [firmNameLt] Filter less than the value.
         * @param {string} [firmNameLte] Filter less than or equal to the value.
         * @param {string} [fullName] The full name of the analyst associated with the ratings.
         * @param {string} [fullNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fullNameGt] Filter greater than the value.
         * @param {string} [fullNameGte] Filter greater than or equal to the value.
         * @param {string} [fullNameLt] Filter less than the value.
         * @param {string} [fullNameLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;full_name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Analysts: async (benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, firmName?: string, firmNameAnyOf?: string, firmNameGt?: string, firmNameGte?: string, firmNameLt?: string, firmNameLte?: string, fullName?: string, fullNameAnyOf?: string, fullNameGt?: string, fullNameGte?: string, fullNameLt?: string, fullNameLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/analysts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (benzingaId !== undefined) {
                localVarQueryParameter['benzinga_id'] = benzingaId;
            }

            if (benzingaIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_id.any_of'] = benzingaIdAnyOf;
            }

            if (benzingaIdGt !== undefined) {
                localVarQueryParameter['benzinga_id.gt'] = benzingaIdGt;
            }

            if (benzingaIdGte !== undefined) {
                localVarQueryParameter['benzinga_id.gte'] = benzingaIdGte;
            }

            if (benzingaIdLt !== undefined) {
                localVarQueryParameter['benzinga_id.lt'] = benzingaIdLt;
            }

            if (benzingaIdLte !== undefined) {
                localVarQueryParameter['benzinga_id.lte'] = benzingaIdLte;
            }

            if (benzingaFirmId !== undefined) {
                localVarQueryParameter['benzinga_firm_id'] = benzingaFirmId;
            }

            if (benzingaFirmIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_firm_id.any_of'] = benzingaFirmIdAnyOf;
            }

            if (benzingaFirmIdGt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gt'] = benzingaFirmIdGt;
            }

            if (benzingaFirmIdGte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gte'] = benzingaFirmIdGte;
            }

            if (benzingaFirmIdLt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lt'] = benzingaFirmIdLt;
            }

            if (benzingaFirmIdLte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lte'] = benzingaFirmIdLte;
            }

            if (firmName !== undefined) {
                localVarQueryParameter['firm_name'] = firmName;
            }

            if (firmNameAnyOf !== undefined) {
                localVarQueryParameter['firm_name.any_of'] = firmNameAnyOf;
            }

            if (firmNameGt !== undefined) {
                localVarQueryParameter['firm_name.gt'] = firmNameGt;
            }

            if (firmNameGte !== undefined) {
                localVarQueryParameter['firm_name.gte'] = firmNameGte;
            }

            if (firmNameLt !== undefined) {
                localVarQueryParameter['firm_name.lt'] = firmNameLt;
            }

            if (firmNameLte !== undefined) {
                localVarQueryParameter['firm_name.lte'] = firmNameLte;
            }

            if (fullName !== undefined) {
                localVarQueryParameter['full_name'] = fullName;
            }

            if (fullNameAnyOf !== undefined) {
                localVarQueryParameter['full_name.any_of'] = fullNameAnyOf;
            }

            if (fullNameGt !== undefined) {
                localVarQueryParameter['full_name.gt'] = fullNameGt;
            }

            if (fullNameGte !== undefined) {
                localVarQueryParameter['full_name.gte'] = fullNameGte;
            }

            if (fullNameLt !== undefined) {
                localVarQueryParameter['full_name.lt'] = fullNameLt;
            }

            if (fullNameLte !== undefined) {
                localVarQueryParameter['full_name.lte'] = fullNameLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ticker The requested ticker.
         * @param {string} [date] Filter equal to the value.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1ConsensusRatings: async (ticker: string, date?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getBenzingaV1ConsensusRatings', 'ticker', ticker)
            const localVarPath = `/benzinga/v1/consensus-ratings/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company reporting earnings.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [dateStatus] Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
         * @param {string} [dateStatusAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateStatusGt] Filter greater than the value.
         * @param {string} [dateStatusGte] Filter greater than or equal to the value.
         * @param {string} [dateStatusLt] Filter less than the value.
         * @param {string} [dateStatusLte] Filter less than or equal to the value.
         * @param {number} [epsSurprisePercent] The percentage difference between the actual and estimated EPS. Value must be a floating point number.
         * @param {string} [epsSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [epsSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercent] The percentage difference between the actual and estimated revenue. Value must be a floating point number.
         * @param {string} [revenueSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalYear] The fiscal year in which the earnings period falls. Value must be an integer.
         * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [fiscalPeriod] The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
         * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fiscalPeriodGt] Filter greater than the value.
         * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
         * @param {string} [fiscalPeriodLt] Filter less than the value.
         * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Earnings: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, dateStatus?: string, dateStatusAnyOf?: string, dateStatusGt?: string, dateStatusGte?: string, dateStatusLt?: string, dateStatusLte?: string, epsSurprisePercent?: number, epsSurprisePercentAnyOf?: string, epsSurprisePercentGt?: number, epsSurprisePercentGte?: number, epsSurprisePercentLt?: number, epsSurprisePercentLte?: number, revenueSurprisePercent?: number, revenueSurprisePercentAnyOf?: string, revenueSurprisePercentGt?: number, revenueSurprisePercentGte?: number, revenueSurprisePercentLt?: number, revenueSurprisePercentLte?: number, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (importance !== undefined) {
                localVarQueryParameter['importance'] = importance;
            }

            if (importanceAnyOf !== undefined) {
                localVarQueryParameter['importance.any_of'] = importanceAnyOf;
            }

            if (importanceGt !== undefined) {
                localVarQueryParameter['importance.gt'] = importanceGt;
            }

            if (importanceGte !== undefined) {
                localVarQueryParameter['importance.gte'] = importanceGte;
            }

            if (importanceLt !== undefined) {
                localVarQueryParameter['importance.lt'] = importanceLt;
            }

            if (importanceLte !== undefined) {
                localVarQueryParameter['importance.lte'] = importanceLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedAnyOf !== undefined) {
                localVarQueryParameter['last_updated.any_of'] = lastUpdatedAnyOf;
            }

            if (lastUpdatedGt !== undefined) {
                localVarQueryParameter['last_updated.gt'] = lastUpdatedGt;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated.gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLt !== undefined) {
                localVarQueryParameter['last_updated.lt'] = lastUpdatedLt;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated.lte'] = lastUpdatedLte;
            }

            if (dateStatus !== undefined) {
                localVarQueryParameter['date_status'] = dateStatus;
            }

            if (dateStatusAnyOf !== undefined) {
                localVarQueryParameter['date_status.any_of'] = dateStatusAnyOf;
            }

            if (dateStatusGt !== undefined) {
                localVarQueryParameter['date_status.gt'] = dateStatusGt;
            }

            if (dateStatusGte !== undefined) {
                localVarQueryParameter['date_status.gte'] = dateStatusGte;
            }

            if (dateStatusLt !== undefined) {
                localVarQueryParameter['date_status.lt'] = dateStatusLt;
            }

            if (dateStatusLte !== undefined) {
                localVarQueryParameter['date_status.lte'] = dateStatusLte;
            }

            if (epsSurprisePercent !== undefined) {
                localVarQueryParameter['eps_surprise_percent'] = epsSurprisePercent;
            }

            if (epsSurprisePercentAnyOf !== undefined) {
                localVarQueryParameter['eps_surprise_percent.any_of'] = epsSurprisePercentAnyOf;
            }

            if (epsSurprisePercentGt !== undefined) {
                localVarQueryParameter['eps_surprise_percent.gt'] = epsSurprisePercentGt;
            }

            if (epsSurprisePercentGte !== undefined) {
                localVarQueryParameter['eps_surprise_percent.gte'] = epsSurprisePercentGte;
            }

            if (epsSurprisePercentLt !== undefined) {
                localVarQueryParameter['eps_surprise_percent.lt'] = epsSurprisePercentLt;
            }

            if (epsSurprisePercentLte !== undefined) {
                localVarQueryParameter['eps_surprise_percent.lte'] = epsSurprisePercentLte;
            }

            if (revenueSurprisePercent !== undefined) {
                localVarQueryParameter['revenue_surprise_percent'] = revenueSurprisePercent;
            }

            if (revenueSurprisePercentAnyOf !== undefined) {
                localVarQueryParameter['revenue_surprise_percent.any_of'] = revenueSurprisePercentAnyOf;
            }

            if (revenueSurprisePercentGt !== undefined) {
                localVarQueryParameter['revenue_surprise_percent.gt'] = revenueSurprisePercentGt;
            }

            if (revenueSurprisePercentGte !== undefined) {
                localVarQueryParameter['revenue_surprise_percent.gte'] = revenueSurprisePercentGte;
            }

            if (revenueSurprisePercentLt !== undefined) {
                localVarQueryParameter['revenue_surprise_percent.lt'] = revenueSurprisePercentLt;
            }

            if (revenueSurprisePercentLte !== undefined) {
                localVarQueryParameter['revenue_surprise_percent.lte'] = revenueSurprisePercentLte;
            }

            if (fiscalYear !== undefined) {
                localVarQueryParameter['fiscal_year'] = fiscalYear;
            }

            if (fiscalYearAnyOf !== undefined) {
                localVarQueryParameter['fiscal_year.any_of'] = fiscalYearAnyOf;
            }

            if (fiscalYearGt !== undefined) {
                localVarQueryParameter['fiscal_year.gt'] = fiscalYearGt;
            }

            if (fiscalYearGte !== undefined) {
                localVarQueryParameter['fiscal_year.gte'] = fiscalYearGte;
            }

            if (fiscalYearLt !== undefined) {
                localVarQueryParameter['fiscal_year.lt'] = fiscalYearLt;
            }

            if (fiscalYearLte !== undefined) {
                localVarQueryParameter['fiscal_year.lte'] = fiscalYearLte;
            }

            if (fiscalPeriod !== undefined) {
                localVarQueryParameter['fiscal_period'] = fiscalPeriod;
            }

            if (fiscalPeriodAnyOf !== undefined) {
                localVarQueryParameter['fiscal_period.any_of'] = fiscalPeriodAnyOf;
            }

            if (fiscalPeriodGt !== undefined) {
                localVarQueryParameter['fiscal_period.gt'] = fiscalPeriodGt;
            }

            if (fiscalPeriodGte !== undefined) {
                localVarQueryParameter['fiscal_period.gte'] = fiscalPeriodGte;
            }

            if (fiscalPeriodLt !== undefined) {
                localVarQueryParameter['fiscal_period.lt'] = fiscalPeriodLt;
            }

            if (fiscalPeriodLte !== undefined) {
                localVarQueryParameter['fiscal_period.lte'] = fiscalPeriodLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [benzingaId] The identifer used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Firms: async (benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/firms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (benzingaId !== undefined) {
                localVarQueryParameter['benzinga_id'] = benzingaId;
            }

            if (benzingaIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_id.any_of'] = benzingaIdAnyOf;
            }

            if (benzingaIdGt !== undefined) {
                localVarQueryParameter['benzinga_id.gt'] = benzingaIdGt;
            }

            if (benzingaIdGte !== undefined) {
                localVarQueryParameter['benzinga_id.gte'] = benzingaIdGte;
            }

            if (benzingaIdLt !== undefined) {
                localVarQueryParameter['benzinga_id.lt'] = benzingaIdLt;
            }

            if (benzingaIdLte !== undefined) {
                localVarQueryParameter['benzinga_id.lte'] = benzingaIdLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company issuing guidance.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [positioning] Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are \&#39;primary\&#39; (the emphasized figure) and \&#39;secondary\&#39; (a supporting or alternate figure)
         * @param {string} [positioningAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [positioningGt] Filter greater than the value.
         * @param {string} [positioningGte] Filter greater than or equal to the value.
         * @param {string} [positioningLt] Filter less than the value.
         * @param {string} [positioningLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {number} [fiscalYear] The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer.
         * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [fiscalPeriod] The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
         * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fiscalPeriodGt] Filter greater than the value.
         * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
         * @param {string} [fiscalPeriodLt] Filter less than the value.
         * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Guidance: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, positioning?: string, positioningAnyOf?: string, positioningGt?: string, positioningGte?: string, positioningLt?: string, positioningLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/guidance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (positioning !== undefined) {
                localVarQueryParameter['positioning'] = positioning;
            }

            if (positioningAnyOf !== undefined) {
                localVarQueryParameter['positioning.any_of'] = positioningAnyOf;
            }

            if (positioningGt !== undefined) {
                localVarQueryParameter['positioning.gt'] = positioningGt;
            }

            if (positioningGte !== undefined) {
                localVarQueryParameter['positioning.gte'] = positioningGte;
            }

            if (positioningLt !== undefined) {
                localVarQueryParameter['positioning.lt'] = positioningLt;
            }

            if (positioningLte !== undefined) {
                localVarQueryParameter['positioning.lte'] = positioningLte;
            }

            if (importance !== undefined) {
                localVarQueryParameter['importance'] = importance;
            }

            if (importanceAnyOf !== undefined) {
                localVarQueryParameter['importance.any_of'] = importanceAnyOf;
            }

            if (importanceGt !== undefined) {
                localVarQueryParameter['importance.gt'] = importanceGt;
            }

            if (importanceGte !== undefined) {
                localVarQueryParameter['importance.gte'] = importanceGte;
            }

            if (importanceLt !== undefined) {
                localVarQueryParameter['importance.lt'] = importanceLt;
            }

            if (importanceLte !== undefined) {
                localVarQueryParameter['importance.lte'] = importanceLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedAnyOf !== undefined) {
                localVarQueryParameter['last_updated.any_of'] = lastUpdatedAnyOf;
            }

            if (lastUpdatedGt !== undefined) {
                localVarQueryParameter['last_updated.gt'] = lastUpdatedGt;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated.gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLt !== undefined) {
                localVarQueryParameter['last_updated.lt'] = lastUpdatedLt;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated.lte'] = lastUpdatedLte;
            }

            if (fiscalYear !== undefined) {
                localVarQueryParameter['fiscal_year'] = fiscalYear;
            }

            if (fiscalYearAnyOf !== undefined) {
                localVarQueryParameter['fiscal_year.any_of'] = fiscalYearAnyOf;
            }

            if (fiscalYearGt !== undefined) {
                localVarQueryParameter['fiscal_year.gt'] = fiscalYearGt;
            }

            if (fiscalYearGte !== undefined) {
                localVarQueryParameter['fiscal_year.gte'] = fiscalYearGte;
            }

            if (fiscalYearLt !== undefined) {
                localVarQueryParameter['fiscal_year.lt'] = fiscalYearLt;
            }

            if (fiscalYearLte !== undefined) {
                localVarQueryParameter['fiscal_year.lte'] = fiscalYearLte;
            }

            if (fiscalPeriod !== undefined) {
                localVarQueryParameter['fiscal_period'] = fiscalPeriod;
            }

            if (fiscalPeriodAnyOf !== undefined) {
                localVarQueryParameter['fiscal_period.any_of'] = fiscalPeriodAnyOf;
            }

            if (fiscalPeriodGt !== undefined) {
                localVarQueryParameter['fiscal_period.gt'] = fiscalPeriodGt;
            }

            if (fiscalPeriodGte !== undefined) {
                localVarQueryParameter['fiscal_period.gte'] = fiscalPeriodGte;
            }

            if (fiscalPeriodLt !== undefined) {
                localVarQueryParameter['fiscal_period.lt'] = fiscalPeriodLt;
            }

            if (fiscalPeriodLte !== undefined) {
                localVarQueryParameter['fiscal_period.lte'] = fiscalPeriodLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [published] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
         * @param {string} [publishedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [publishedGt] Filter greater than the value.
         * @param {string} [publishedGte] Filter greater than or equal to the value.
         * @param {string} [publishedLt] Filter less than the value.
         * @param {string} [publishedLte] Filter less than or equal to the value.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channels] Filter for arrays that contain the value.
         * @param {string} [channelsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channelsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tags] Filter for arrays that contain the value.
         * @param {string} [tagsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tagsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [author] The name of the journalist or entity that authored the news article.
         * @param {string} [authorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [authorGt] Filter greater than the value.
         * @param {string} [authorGte] Filter greater than or equal to the value.
         * @param {string} [authorLt] Filter less than the value.
         * @param {string} [authorLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;published\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1News: async (published?: string, publishedAnyOf?: string, publishedGt?: string, publishedGte?: string, publishedLt?: string, publishedLte?: string, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, channels?: string, channelsAllOf?: string, channelsAnyOf?: string, tags?: string, tagsAllOf?: string, tagsAnyOf?: string, author?: string, authorAnyOf?: string, authorGt?: string, authorGte?: string, authorLt?: string, authorLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }

            if (publishedAnyOf !== undefined) {
                localVarQueryParameter['published.any_of'] = publishedAnyOf;
            }

            if (publishedGt !== undefined) {
                localVarQueryParameter['published.gt'] = publishedGt;
            }

            if (publishedGte !== undefined) {
                localVarQueryParameter['published.gte'] = publishedGte;
            }

            if (publishedLt !== undefined) {
                localVarQueryParameter['published.lt'] = publishedLt;
            }

            if (publishedLte !== undefined) {
                localVarQueryParameter['published.lte'] = publishedLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedAnyOf !== undefined) {
                localVarQueryParameter['last_updated.any_of'] = lastUpdatedAnyOf;
            }

            if (lastUpdatedGt !== undefined) {
                localVarQueryParameter['last_updated.gt'] = lastUpdatedGt;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated.gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLt !== undefined) {
                localVarQueryParameter['last_updated.lt'] = lastUpdatedLt;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated.lte'] = lastUpdatedLte;
            }

            if (tickers !== undefined) {
                localVarQueryParameter['tickers'] = tickers;
            }

            if (tickersAllOf !== undefined) {
                localVarQueryParameter['tickers.all_of'] = tickersAllOf;
            }

            if (tickersAnyOf !== undefined) {
                localVarQueryParameter['tickers.any_of'] = tickersAnyOf;
            }

            if (channels !== undefined) {
                localVarQueryParameter['channels'] = channels;
            }

            if (channelsAllOf !== undefined) {
                localVarQueryParameter['channels.all_of'] = channelsAllOf;
            }

            if (channelsAnyOf !== undefined) {
                localVarQueryParameter['channels.any_of'] = channelsAnyOf;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (tagsAllOf !== undefined) {
                localVarQueryParameter['tags.all_of'] = tagsAllOf;
            }

            if (tagsAnyOf !== undefined) {
                localVarQueryParameter['tags.any_of'] = tagsAnyOf;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (authorAnyOf !== undefined) {
                localVarQueryParameter['author.any_of'] = authorAnyOf;
            }

            if (authorGt !== undefined) {
                localVarQueryParameter['author.gt'] = authorGt;
            }

            if (authorGte !== undefined) {
                localVarQueryParameter['author.gte'] = authorGte;
            }

            if (authorLt !== undefined) {
                localVarQueryParameter['author.lt'] = authorLt;
            }

            if (authorLte !== undefined) {
                localVarQueryParameter['author.lte'] = authorLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
         * @param {string} [ratingActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [ratingActionGt] Filter greater than the value.
         * @param {string} [ratingActionGte] Filter greater than or equal to the value.
         * @param {string} [ratingActionLt] Filter less than the value.
         * @param {string} [ratingActionLte] Filter less than or equal to the value.
         * @param {string} [priceTargetAction] The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
         * @param {string} [priceTargetActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [priceTargetActionGt] Filter greater than the value.
         * @param {string} [priceTargetActionGte] Filter greater than or equal to the value.
         * @param {string} [priceTargetActionLt] Filter less than the value.
         * @param {string} [priceTargetActionLte] Filter less than or equal to the value.
         * @param {string} [benzingaId] The identifer used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaAnalystId] Filter equal to the value.
         * @param {string} [benzingaAnalystIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaAnalystIdGt] Filter greater than the value.
         * @param {string} [benzingaAnalystIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaAnalystIdLt] Filter less than the value.
         * @param {string} [benzingaAnalystIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] Filter equal to the value.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Ratings: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, ratingAction?: string, ratingActionAnyOf?: string, ratingActionGt?: string, ratingActionGte?: string, ratingActionLt?: string, ratingActionLte?: string, priceTargetAction?: string, priceTargetActionAnyOf?: string, priceTargetActionGt?: string, priceTargetActionGte?: string, priceTargetActionLt?: string, priceTargetActionLte?: string, benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaAnalystId?: string, benzingaAnalystIdAnyOf?: string, benzingaAnalystIdGt?: string, benzingaAnalystIdGte?: string, benzingaAnalystIdLt?: string, benzingaAnalystIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (importance !== undefined) {
                localVarQueryParameter['importance'] = importance;
            }

            if (importanceAnyOf !== undefined) {
                localVarQueryParameter['importance.any_of'] = importanceAnyOf;
            }

            if (importanceGt !== undefined) {
                localVarQueryParameter['importance.gt'] = importanceGt;
            }

            if (importanceGte !== undefined) {
                localVarQueryParameter['importance.gte'] = importanceGte;
            }

            if (importanceLt !== undefined) {
                localVarQueryParameter['importance.lt'] = importanceLt;
            }

            if (importanceLte !== undefined) {
                localVarQueryParameter['importance.lte'] = importanceLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedAnyOf !== undefined) {
                localVarQueryParameter['last_updated.any_of'] = lastUpdatedAnyOf;
            }

            if (lastUpdatedGt !== undefined) {
                localVarQueryParameter['last_updated.gt'] = lastUpdatedGt;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated.gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLt !== undefined) {
                localVarQueryParameter['last_updated.lt'] = lastUpdatedLt;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated.lte'] = lastUpdatedLte;
            }

            if (ratingAction !== undefined) {
                localVarQueryParameter['rating_action'] = ratingAction;
            }

            if (ratingActionAnyOf !== undefined) {
                localVarQueryParameter['rating_action.any_of'] = ratingActionAnyOf;
            }

            if (ratingActionGt !== undefined) {
                localVarQueryParameter['rating_action.gt'] = ratingActionGt;
            }

            if (ratingActionGte !== undefined) {
                localVarQueryParameter['rating_action.gte'] = ratingActionGte;
            }

            if (ratingActionLt !== undefined) {
                localVarQueryParameter['rating_action.lt'] = ratingActionLt;
            }

            if (ratingActionLte !== undefined) {
                localVarQueryParameter['rating_action.lte'] = ratingActionLte;
            }

            if (priceTargetAction !== undefined) {
                localVarQueryParameter['price_target_action'] = priceTargetAction;
            }

            if (priceTargetActionAnyOf !== undefined) {
                localVarQueryParameter['price_target_action.any_of'] = priceTargetActionAnyOf;
            }

            if (priceTargetActionGt !== undefined) {
                localVarQueryParameter['price_target_action.gt'] = priceTargetActionGt;
            }

            if (priceTargetActionGte !== undefined) {
                localVarQueryParameter['price_target_action.gte'] = priceTargetActionGte;
            }

            if (priceTargetActionLt !== undefined) {
                localVarQueryParameter['price_target_action.lt'] = priceTargetActionLt;
            }

            if (priceTargetActionLte !== undefined) {
                localVarQueryParameter['price_target_action.lte'] = priceTargetActionLte;
            }

            if (benzingaId !== undefined) {
                localVarQueryParameter['benzinga_id'] = benzingaId;
            }

            if (benzingaIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_id.any_of'] = benzingaIdAnyOf;
            }

            if (benzingaIdGt !== undefined) {
                localVarQueryParameter['benzinga_id.gt'] = benzingaIdGt;
            }

            if (benzingaIdGte !== undefined) {
                localVarQueryParameter['benzinga_id.gte'] = benzingaIdGte;
            }

            if (benzingaIdLt !== undefined) {
                localVarQueryParameter['benzinga_id.lt'] = benzingaIdLt;
            }

            if (benzingaIdLte !== undefined) {
                localVarQueryParameter['benzinga_id.lte'] = benzingaIdLte;
            }

            if (benzingaAnalystId !== undefined) {
                localVarQueryParameter['benzinga_analyst_id'] = benzingaAnalystId;
            }

            if (benzingaAnalystIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_analyst_id.any_of'] = benzingaAnalystIdAnyOf;
            }

            if (benzingaAnalystIdGt !== undefined) {
                localVarQueryParameter['benzinga_analyst_id.gt'] = benzingaAnalystIdGt;
            }

            if (benzingaAnalystIdGte !== undefined) {
                localVarQueryParameter['benzinga_analyst_id.gte'] = benzingaAnalystIdGte;
            }

            if (benzingaAnalystIdLt !== undefined) {
                localVarQueryParameter['benzinga_analyst_id.lt'] = benzingaAnalystIdLt;
            }

            if (benzingaAnalystIdLte !== undefined) {
                localVarQueryParameter['benzinga_analyst_id.lte'] = benzingaAnalystIdLte;
            }

            if (benzingaFirmId !== undefined) {
                localVarQueryParameter['benzinga_firm_id'] = benzingaFirmId;
            }

            if (benzingaFirmIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_firm_id.any_of'] = benzingaFirmIdAnyOf;
            }

            if (benzingaFirmIdGt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gt'] = benzingaFirmIdGt;
            }

            if (benzingaFirmIdGte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gte'] = benzingaFirmIdGte;
            }

            if (benzingaFirmIdLt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lt'] = benzingaFirmIdLt;
            }

            if (benzingaFirmIdLte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lte'] = benzingaFirmIdLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetCryptoAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetCryptoAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoAggregates: async (cryptoTicker: string, multiplier: number, timespan: GetCryptoAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetCryptoAggregatesSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoAggregates', 'cryptoTicker', cryptoTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('getCryptoAggregates', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('getCryptoAggregates', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getCryptoAggregates', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getCryptoAggregates', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{cryptoTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoEMA: async (cryptoTicker: string, timestamp?: string, timespan?: GetCryptoEMATimespanEnum, window?: number, seriesType?: GetCryptoEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoEMA', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/ema/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} cryptoTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetCryptoMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate MACD data. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoMACD: async (cryptoTicker: string, timestamp?: string, timespan?: GetCryptoMACDTimespanEnum, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetCryptoMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoMACD', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/macd/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close prices of a cryptocurrency symbol on a certain day. 
         * @summary Daily Open/Close
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoOpenClose: async (from: string, to: string, date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getCryptoOpenClose', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getCryptoOpenClose', 'to', to)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getCryptoOpenClose', 'date', date)
            const localVarPath = `/v1/open-close/crypto/{from}/{to}/{date}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoRSI: async (cryptoTicker: string, timestamp?: string, timespan?: GetCryptoRSITimespanEnum, window?: number, seriesType?: GetCryptoRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoRSI', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/rsi/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSMA: async (cryptoTicker: string, timestamp?: string, timespan?: GetCryptoSMATimespanEnum, window?: number, seriesType?: GetCryptoSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoSMA', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/sma/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetCryptoSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotDirection: async (direction: GetCryptoSnapshotDirectionDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('getCryptoSnapshotDirection', 'direction', direction)
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/{direction}`
                .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker Ticker of the snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotTicker: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getCryptoSnapshotTicker', 'ticker', ticker)
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotTickers: async (tickers?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickers) {
                localVarQueryParameter['tickers'] = tickers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a crypto ticker symbol in a given time range.
         * @summary Trades
         * @param {string} cryptoTicker The ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetCryptoTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetCryptoTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoTrades: async (cryptoTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetCryptoTradesOrderEnum, limit?: number, sort?: GetCryptoTradesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoTrades', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v3/trades/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
         * @summary Real-time Currency Conversion
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {number} [amount] The amount to convert, with a decimal.
         * @param {GetCurrencyConversionPrecisionEnum} [precision] The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyConversion: async (from: string, to: string, amount?: number, precision?: GetCurrencyConversionPrecisionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getCurrencyConversion', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getCurrencyConversion', 'to', to)
            const localVarPath = `/v1/conversion/{from}/{to}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (precision !== undefined) {
                localVarQueryParameter['precision'] = precision;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
         * @summary Ticker Events
         * @param {string} id Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the  [Ticker Details Endpoint](https://polygon.io/docs/stocks/get_v3_reference_tickers__ticker)
         * @param {string} [types] A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (id: string, types?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEvents', 'id', id)
            const localVarPath = `/vX/reference/tickers/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [date] Calendar date of the yield observation (YYYYMMDD).
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFedV1TreasuryYields: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fed/v1/treasury-yields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetForexAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetForexAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexAggregates: async (forexTicker: string, multiplier: number, timespan: GetForexAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetForexAggregatesSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forexTicker' is not null or undefined
            assertParamExists('getForexAggregates', 'forexTicker', forexTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('getForexAggregates', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('getForexAggregates', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getForexAggregates', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getForexAggregates', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{forexTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"forexTicker"}}`, encodeURIComponent(String(forexTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetForexEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexEMA: async (fxTicker: string, timestamp?: string, timespan?: GetForexEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('getForexEMA', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/ema/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} fxTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetForexMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexMACD: async (fxTicker: string, timestamp?: string, timespan?: GetForexMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetForexMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('getForexMACD', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/macd/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get BBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (BBO)
         * @param {string} fxTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetForexQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetForexQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexQuotes: async (fxTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetForexQuotesOrderEnum, limit?: number, sort?: GetForexQuotesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('getForexQuotes', 'fxTicker', fxTicker)
            const localVarPath = `/v3/quotes/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} fxTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetForexRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexRSI: async (fxTicker: string, timestamp?: string, timespan?: GetForexRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('getForexRSI', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/rsi/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} fxTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetForexSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSMA: async (fxTicker: string, timestamp?: string, timespan?: GetForexSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('getForexSMA', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/sma/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetForexSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotDirection: async (direction: GetForexSnapshotDirectionDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('getForexSnapshotDirection', 'direction', direction)
            const localVarPath = `/v2/snapshot/locale/global/markets/forex/{direction}`
                .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker The forex ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotTicker: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getForexSnapshotTicker', 'ticker', ticker)
            const localVarPath = `/v2/snapshot/locale/global/markets/forex/tickers/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotTickers: async (tickers?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/snapshot/locale/global/markets/forex/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickers) {
                localVarQueryParameter['tickers'] = tickers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedCryptoAggregates: async (date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getGroupedCryptoAggregates', 'date', date)
            const localVarPath = `/v2/aggs/grouped/locale/global/market/crypto/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedForexAggregates: async (date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getGroupedForexAggregates', 'date', date)
            const localVarPath = `/v2/aggs/grouped/locale/global/market/fx/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedStocksAggregates: async (date: string, adjusted?: boolean, includeOtc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getGroupedStocksAggregates', 'date', date)
            const localVarPath = `/v2/aggs/grouped/locale/us/market/stocks/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (includeOtc !== undefined) {
                localVarQueryParameter['include_otc'] = includeOtc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetIndicesAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesAggregates: async (indicesTicker: string, multiplier: number, timespan: GetIndicesAggregatesTimespanEnum, from: string, to: string, sort?: GetIndicesAggregatesSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesAggregates', 'indicesTicker', indicesTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('getIndicesAggregates', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('getIndicesAggregates', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getIndicesAggregates', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getIndicesAggregates', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{indicesTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetIndicesEMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesEMA: async (indicesTicker: string, timestamp?: string, timespan?: GetIndicesEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesEMA', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/ema/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} indicesTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetIndicesMACDSeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close values to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesMACD: async (indicesTicker: string, timestamp?: string, timespan?: GetIndicesMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetIndicesMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesMACD', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/macd/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close and afterhours values of a index symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesOpenClose: async (indicesTicker: string, date: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesOpenClose', 'indicesTicker', indicesTicker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getIndicesOpenClose', 'date', date)
            const localVarPath = `/v1/open-close/{indicesTicker}/{date}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetIndicesRSISeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close values to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesRSI: async (indicesTicker: string, timestamp?: string, timespan?: GetIndicesRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesRSI', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/rsi/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetIndicesSMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesSMA: async (indicesTicker: string, timestamp?: string, timespan?: GetIndicesSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesSMA', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/sma/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Snapshot of indices data for said tickers
         * @summary Indices Snapshot
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {GetIndicesSnapshotOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetIndicesSnapshotSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesSnapshot: async (tickerAnyOf?: string, ticker?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: GetIndicesSnapshotOrderEnum, limit?: number, sort?: GetIndicesSnapshotSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/snapshot/indices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the last trade tick for a cryptocurrency pair.
         * @summary Last Trade for a Crypto Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCryptoTrade: async (from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getLastCryptoTrade', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getLastCryptoTrade', 'to', to)
            const localVarPath = `/v1/last/crypto/{from}/{to}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the last quote tick for a forex currency pair.
         * @summary Last Quote for a Currency Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCurrencyQuote: async (from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getLastCurrencyQuote', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getLastCurrencyQuote', 'to', to)
            const localVarPath = `/v1/last_quote/currencies/{from}/{to}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent trade for a given options contract.
         * @summary Last Trade
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastOptionsTrade: async (optionsTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getLastOptionsTrade', 'optionsTicker', optionsTicker)
            const localVarPath = `/v2/last/trade/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent NBBO (Quote) tick for a given stock.
         * @summary Last Quote
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastStocksQuote: async (stocksTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getLastStocksQuote', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/last/nbbo/{stocksTicker}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent trade for a given stock.
         * @summary Last Trade
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastStocksTrade: async (stocksTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getLastStocksTrade', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/last/trade/{stocksTicker}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get upcoming market holidays and their open/close times.
         * @summary Market Holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketHolidays: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketstatus/upcoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current trading status of the exchanges and overall financial markets.
         * @summary Market Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketstatus/now`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the snapshot of an option contract for a stock equity.
         * @summary Option Contract
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {string} optionContract The option contract identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionContract: async (underlyingAsset: string, optionContract: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'underlyingAsset' is not null or undefined
            assertParamExists('getOptionContract', 'underlyingAsset', underlyingAsset)
            // verify required parameter 'optionContract' is not null or undefined
            assertParamExists('getOptionContract', 'optionContract', optionContract)
            const localVarPath = `/v3/snapshot/options/{underlyingAsset}/{optionContract}`
                .replace(`{${"underlyingAsset"}}`, encodeURIComponent(String(underlyingAsset)))
                .replace(`{${"optionContract"}}`, encodeURIComponent(String(optionContract)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetOptionsAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetOptionsAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsAggregates: async (optionsTicker: string, multiplier: number, timespan: GetOptionsAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetOptionsAggregatesSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsAggregates', 'optionsTicker', optionsTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('getOptionsAggregates', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('getOptionsAggregates', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getOptionsAggregates', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getOptionsAggregates', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{optionsTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the snapshot of all options contracts for an underlying ticker.
         * @summary Options Chain
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {GetOptionsChainContractTypeEnum} [contractType] Query by the type of contract.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {GetOptionsChainOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetOptionsChainSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsChain: async (underlyingAsset: string, strikePrice?: number, expirationDate?: string, contractType?: GetOptionsChainContractTypeEnum, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, order?: GetOptionsChainOrderEnum, limit?: number, sort?: GetOptionsChainSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'underlyingAsset' is not null or undefined
            assertParamExists('getOptionsChain', 'underlyingAsset', underlyingAsset)
            const localVarPath = `/v3/snapshot/options/{underlyingAsset}`
                .replace(`{${"underlyingAsset"}}`, encodeURIComponent(String(underlyingAsset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (strikePrice !== undefined) {
                localVarQueryParameter['strike_price'] = strikePrice;
            }

            if (expirationDate !== undefined) {
                localVarQueryParameter['expiration_date'] = expirationDate;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contract_type'] = contractType;
            }

            if (strikePriceGte !== undefined) {
                localVarQueryParameter['strike_price.gte'] = strikePriceGte;
            }

            if (strikePriceGt !== undefined) {
                localVarQueryParameter['strike_price.gt'] = strikePriceGt;
            }

            if (strikePriceLte !== undefined) {
                localVarQueryParameter['strike_price.lte'] = strikePriceLte;
            }

            if (strikePriceLt !== undefined) {
                localVarQueryParameter['strike_price.lt'] = strikePriceLt;
            }

            if (expirationDateGte !== undefined) {
                localVarQueryParameter['expiration_date.gte'] = expirationDateGte;
            }

            if (expirationDateGt !== undefined) {
                localVarQueryParameter['expiration_date.gt'] = expirationDateGt;
            }

            if (expirationDateLte !== undefined) {
                localVarQueryParameter['expiration_date.lte'] = expirationDateLte;
            }

            if (expirationDateLt !== undefined) {
                localVarQueryParameter['expiration_date.lt'] = expirationDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an options contract
         * @summary Options Contract
         * @param {string} optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://polygon.io/blog/how-to-read-a-stock-options-ticker/).
         * @param {string} [asOf] Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsContract: async (optionsTicker: string, asOf?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsContract', 'optionsTicker', optionsTicker)
            const localVarPath = `/v3/reference/options/contracts/{options_ticker}`
                .replace(`{${"options_ticker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (asOf !== undefined) {
                localVarQueryParameter['as_of'] = asOf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetOptionsEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsEMA: async (optionsTicker: string, timestamp?: string, timespan?: GetOptionsEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsEMA', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/ema/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} optionsTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetOptionsMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsMACD: async (optionsTicker: string, timestamp?: string, timespan?: GetOptionsMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetOptionsMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsMACD', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/macd/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close and afterhours prices of an options contract on a certain date. 
         * @summary Daily Open/Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsOpenClose: async (optionsTicker: string, date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsOpenClose', 'optionsTicker', optionsTicker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getOptionsOpenClose', 'date', date)
            const localVarPath = `/v1/open-close/{optionsTicker}/{date}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get quotes for an options ticker symbol in a given time range.
         * @summary Quotes
         * @param {string} optionsTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetOptionsQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetOptionsQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsQuotes: async (optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsQuotesOrderEnum, limit?: number, sort?: GetOptionsQuotesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsQuotes', 'optionsTicker', optionsTicker)
            const localVarPath = `/v3/quotes/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetOptionsRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsRSI: async (optionsTicker: string, timestamp?: string, timespan?: GetOptionsRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsRSI', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/rsi/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetOptionsSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsSMA: async (optionsTicker: string, timestamp?: string, timespan?: GetOptionsSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsSMA', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/sma/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for an options ticker symbol in a given time range.
         * @summary Trades
         * @param {string} optionsTicker The options ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetOptionsTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetOptionsTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsTrades: async (optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsTradesOrderEnum, limit?: number, sort?: GetOptionsTradesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsTrades', 'optionsTicker', optionsTicker)
            const localVarPath = `/v3/trades/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
         * @summary Previous Close
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousCryptoAggregates: async (cryptoTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getPreviousCryptoAggregates', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v2/aggs/ticker/{cryptoTicker}/prev`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
         * @summary Previous Close
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousForexAggregates: async (forexTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forexTicker' is not null or undefined
            assertParamExists('getPreviousForexAggregates', 'forexTicker', forexTicker)
            const localVarPath = `/v2/aggs/ticker/{forexTicker}/prev`
                .replace(`{${"forexTicker"}}`, encodeURIComponent(String(forexTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
         * @summary Previous Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousIndicesAggregates: async (indicesTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getPreviousIndicesAggregates', 'indicesTicker', indicesTicker)
            const localVarPath = `/v2/aggs/ticker/{indicesTicker}/prev`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
         * @summary Previous Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousOptionsAggregates: async (optionsTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getPreviousOptionsAggregates', 'optionsTicker', optionsTicker)
            const localVarPath = `/v2/aggs/ticker/{optionsTicker}/prev`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
         * @summary Previous Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousStocksAggregates: async (stocksTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getPreviousStocksAggregates', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/aggs/ticker/{stocksTicker}/prev`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of tickers related to the queried ticker based on News and Returns data.
         * @summary Related Companies
         * @param {string} ticker The ticker symbol to search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedCompanies: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getRelatedCompanies', 'ticker', ticker)
            const localVarPath = `/v1/related-companies/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
         * @summary Summaries
         * @param {string} [tickerAnyOf] Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://polygon.io/docs/stocks/get_v3_reference_tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotSummary: async (tickerAnyOf?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/summaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get snapshots for assets of all types
         * @summary Universal Snapshot
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {GetSnapshotsTypeEnum} [type] Query by the type of asset.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. 
         * @param {GetSnapshotsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetSnapshotsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots: async (ticker?: string, type?: GetSnapshotsTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, tickerAnyOf?: string, order?: GetSnapshotsOrderEnum, limit?: number, sort?: GetSnapshotsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/snapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetStocksAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetStocksAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksAggregates: async (stocksTicker: string, multiplier: number, timespan: GetStocksAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetStocksAggregatesSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getStocksAggregates', 'stocksTicker', stocksTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('getStocksAggregates', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('getStocksAggregates', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getStocksAggregates', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getStocksAggregates', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetStocksEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksEMA: async (stockTicker: string, timestamp?: string, timespan?: GetStocksEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksEMA', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/ema/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetStocksMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksMACD: async (stockTicker: string, timestamp?: string, timespan?: GetStocksMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetStocksMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksMACD', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/macd/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close and afterhours prices of a stock symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksOpenClose: async (stocksTicker: string, date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getStocksOpenClose', 'stocksTicker', stocksTicker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getStocksOpenClose', 'date', date)
            const localVarPath = `/v1/open-close/{stocksTicker}/{date}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get NBBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (NBBO)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetStocksQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetStocksQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksQuotes: async (stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksQuotesOrderEnum, limit?: number, sort?: GetStocksQuotesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksQuotes', 'stockTicker', stockTicker)
            const localVarPath = `/v3/quotes/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetStocksRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksRSI: async (stockTicker: string, timestamp?: string, timespan?: GetStocksRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksRSI', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/rsi/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetStocksSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSMA: async (stockTicker: string, timestamp?: string, timespan?: GetStocksSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksSMA', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/sma/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetStocksSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotDirection: async (direction: GetStocksSnapshotDirectionDirectionEnum, includeOtc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('getStocksSnapshotDirection', 'direction', direction)
            const localVarPath = `/v2/snapshot/locale/us/markets/stocks/{direction}`
                .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (includeOtc !== undefined) {
                localVarQueryParameter['include_otc'] = includeOtc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary Ticker
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotTicker: async (stocksTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getStocksSnapshotTicker', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/snapshot/locale/us/markets/stocks/tickers/{stocksTicker}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotTickers: async (tickers?: Array<string>, includeOtc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/snapshot/locale/us/markets/stocks/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickers) {
                localVarQueryParameter['tickers'] = tickers;
            }

            if (includeOtc !== undefined) {
                localVarQueryParameter['include_otc'] = includeOtc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a ticker symbol in a given time range.
         * @summary Trades
         * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetStocksTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetStocksTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksTrades: async (stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksTradesOrderEnum, limit?: number, sort?: GetStocksTradesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksTrades', 'stockTicker', stockTicker)
            const localVarPath = `/v3/trades/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [daysToCover] Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number.
         * @param {string} [daysToCoverAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [daysToCoverGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [daysToCoverGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [daysToCoverLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [daysToCoverLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [settlementDate] The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
         * @param {string} [settlementDateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [settlementDateGt] Filter greater than the value.
         * @param {string} [settlementDateGte] Filter greater than or equal to the value.
         * @param {string} [settlementDateLt] Filter less than the value.
         * @param {string} [settlementDateLte] Filter less than or equal to the value.
         * @param {number} [avgDailyVolume] The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer.
         * @param {string} [avgDailyVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [avgDailyVolumeGt] Filter greater than the value. Value must be an integer.
         * @param {number} [avgDailyVolumeGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [avgDailyVolumeLt] Filter less than the value. Value must be an integer.
         * @param {number} [avgDailyVolumeLte] Filter less than or equal to the value. Value must be an integer.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1ShortInterest: async (ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, daysToCover?: number, daysToCoverAnyOf?: string, daysToCoverGt?: number, daysToCoverGte?: number, daysToCoverLt?: number, daysToCoverLte?: number, settlementDate?: string, settlementDateAnyOf?: string, settlementDateGt?: string, settlementDateGte?: string, settlementDateLt?: string, settlementDateLte?: string, avgDailyVolume?: number, avgDailyVolumeAnyOf?: string, avgDailyVolumeGt?: number, avgDailyVolumeGte?: number, avgDailyVolumeLt?: number, avgDailyVolumeLte?: number, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/v1/short-interest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (daysToCover !== undefined) {
                localVarQueryParameter['days_to_cover'] = daysToCover;
            }

            if (daysToCoverAnyOf !== undefined) {
                localVarQueryParameter['days_to_cover.any_of'] = daysToCoverAnyOf;
            }

            if (daysToCoverGt !== undefined) {
                localVarQueryParameter['days_to_cover.gt'] = daysToCoverGt;
            }

            if (daysToCoverGte !== undefined) {
                localVarQueryParameter['days_to_cover.gte'] = daysToCoverGte;
            }

            if (daysToCoverLt !== undefined) {
                localVarQueryParameter['days_to_cover.lt'] = daysToCoverLt;
            }

            if (daysToCoverLte !== undefined) {
                localVarQueryParameter['days_to_cover.lte'] = daysToCoverLte;
            }

            if (settlementDate !== undefined) {
                localVarQueryParameter['settlement_date'] = settlementDate;
            }

            if (settlementDateAnyOf !== undefined) {
                localVarQueryParameter['settlement_date.any_of'] = settlementDateAnyOf;
            }

            if (settlementDateGt !== undefined) {
                localVarQueryParameter['settlement_date.gt'] = settlementDateGt;
            }

            if (settlementDateGte !== undefined) {
                localVarQueryParameter['settlement_date.gte'] = settlementDateGte;
            }

            if (settlementDateLt !== undefined) {
                localVarQueryParameter['settlement_date.lt'] = settlementDateLt;
            }

            if (settlementDateLte !== undefined) {
                localVarQueryParameter['settlement_date.lte'] = settlementDateLte;
            }

            if (avgDailyVolume !== undefined) {
                localVarQueryParameter['avg_daily_volume'] = avgDailyVolume;
            }

            if (avgDailyVolumeAnyOf !== undefined) {
                localVarQueryParameter['avg_daily_volume.any_of'] = avgDailyVolumeAnyOf;
            }

            if (avgDailyVolumeGt !== undefined) {
                localVarQueryParameter['avg_daily_volume.gt'] = avgDailyVolumeGt;
            }

            if (avgDailyVolumeGte !== undefined) {
                localVarQueryParameter['avg_daily_volume.gte'] = avgDailyVolumeGte;
            }

            if (avgDailyVolumeLt !== undefined) {
                localVarQueryParameter['avg_daily_volume.lt'] = avgDailyVolumeLt;
            }

            if (avgDailyVolumeLte !== undefined) {
                localVarQueryParameter['avg_daily_volume.lte'] = avgDailyVolumeLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [date] The date of trade activity reported in the format YYYY-MM-DD
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [shortVolumeRatio] The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number.
         * @param {string} [shortVolumeRatioAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [shortVolumeRatioGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [totalVolume] Total reported volume across all venues for the ticker on the given date. Value must be an integer.
         * @param {string} [totalVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [totalVolumeGt] Filter greater than the value. Value must be an integer.
         * @param {number} [totalVolumeGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [totalVolumeLt] Filter less than the value. Value must be an integer.
         * @param {number} [totalVolumeLte] Filter less than or equal to the value. Value must be an integer.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1ShortVolume: async (ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, shortVolumeRatio?: number, shortVolumeRatioAnyOf?: string, shortVolumeRatioGt?: number, shortVolumeRatioGte?: number, shortVolumeRatioLt?: number, shortVolumeRatioLte?: number, totalVolume?: number, totalVolumeAnyOf?: string, totalVolumeGt?: number, totalVolumeGte?: number, totalVolumeLt?: number, totalVolumeLte?: number, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/v1/short-volume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (shortVolumeRatio !== undefined) {
                localVarQueryParameter['short_volume_ratio'] = shortVolumeRatio;
            }

            if (shortVolumeRatioAnyOf !== undefined) {
                localVarQueryParameter['short_volume_ratio.any_of'] = shortVolumeRatioAnyOf;
            }

            if (shortVolumeRatioGt !== undefined) {
                localVarQueryParameter['short_volume_ratio.gt'] = shortVolumeRatioGt;
            }

            if (shortVolumeRatioGte !== undefined) {
                localVarQueryParameter['short_volume_ratio.gte'] = shortVolumeRatioGte;
            }

            if (shortVolumeRatioLt !== undefined) {
                localVarQueryParameter['short_volume_ratio.lt'] = shortVolumeRatioLt;
            }

            if (shortVolumeRatioLte !== undefined) {
                localVarQueryParameter['short_volume_ratio.lte'] = shortVolumeRatioLte;
            }

            if (totalVolume !== undefined) {
                localVarQueryParameter['total_volume'] = totalVolume;
            }

            if (totalVolumeAnyOf !== undefined) {
                localVarQueryParameter['total_volume.any_of'] = totalVolumeAnyOf;
            }

            if (totalVolumeGt !== undefined) {
                localVarQueryParameter['total_volume.gt'] = totalVolumeGt;
            }

            if (totalVolumeGte !== undefined) {
                localVarQueryParameter['total_volume.gte'] = totalVolumeGte;
            }

            if (totalVolumeLt !== undefined) {
                localVarQueryParameter['total_volume.lt'] = totalVolumeLt;
            }

            if (totalVolumeLte !== undefined) {
                localVarQueryParameter['total_volume.lte'] = totalVolumeLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
         * @summary Ticker Details v3
         * @param {string} ticker The ticker symbol of the asset.
         * @param {string} [date] Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker: async (ticker: string, date?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getTicker', 'ticker', ticker)
            const localVarPath = `/v3/reference/tickers/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all conditions that Polygon.io uses.
         * @summary Conditions
         * @param {ListConditionsAssetClassEnum} [assetClass] Filter for conditions within a given asset class.
         * @param {ListConditionsDataTypeEnum} [dataType] Filter by data type.
         * @param {number} [id] Filter for conditions with a given ID.
         * @param {ListConditionsSipEnum} [sip] Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
         * @param {ListConditionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListConditionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConditions: async (assetClass?: ListConditionsAssetClassEnum, dataType?: ListConditionsDataTypeEnum, id?: number, sip?: ListConditionsSipEnum, order?: ListConditionsOrderEnum, limit?: number, sort?: ListConditionsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/conditions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (assetClass !== undefined) {
                localVarQueryParameter['asset_class'] = assetClass;
            }

            if (dataType !== undefined) {
                localVarQueryParameter['data_type'] = dataType;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (sip !== undefined) {
                localVarQueryParameter['sip'] = sip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
         * @summary Dividends v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [exDividendDate] Query by ex-dividend date with the format YYYY-MM-DD.
         * @param {string} [recordDate] Query by record date with the format YYYY-MM-DD.
         * @param {string} [declarationDate] Query by declaration date with the format YYYY-MM-DD.
         * @param {string} [payDate] Query by pay date with the format YYYY-MM-DD.
         * @param {ListDividendsFrequencyEnum} [frequency] Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
         * @param {number} [cashAmount] Query by the cash amount of the dividend.
         * @param {ListDividendsDividendTypeEnum} [dividendType] Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [exDividendDateGte] Range by ex_dividend_date.
         * @param {string} [exDividendDateGt] Range by ex_dividend_date.
         * @param {string} [exDividendDateLte] Range by ex_dividend_date.
         * @param {string} [exDividendDateLt] Range by ex_dividend_date.
         * @param {string} [recordDateGte] Range by record_date.
         * @param {string} [recordDateGt] Range by record_date.
         * @param {string} [recordDateLte] Range by record_date.
         * @param {string} [recordDateLt] Range by record_date.
         * @param {string} [declarationDateGte] Range by declaration_date.
         * @param {string} [declarationDateGt] Range by declaration_date.
         * @param {string} [declarationDateLte] Range by declaration_date.
         * @param {string} [declarationDateLt] Range by declaration_date.
         * @param {string} [payDateGte] Range by pay_date.
         * @param {string} [payDateGt] Range by pay_date.
         * @param {string} [payDateLte] Range by pay_date.
         * @param {string} [payDateLt] Range by pay_date.
         * @param {number} [cashAmountGte] Range by cash_amount.
         * @param {number} [cashAmountGt] Range by cash_amount.
         * @param {number} [cashAmountLte] Range by cash_amount.
         * @param {number} [cashAmountLt] Range by cash_amount.
         * @param {ListDividendsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListDividendsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDividends: async (ticker?: string, exDividendDate?: string, recordDate?: string, declarationDate?: string, payDate?: string, frequency?: ListDividendsFrequencyEnum, cashAmount?: number, dividendType?: ListDividendsDividendTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, exDividendDateGte?: string, exDividendDateGt?: string, exDividendDateLte?: string, exDividendDateLt?: string, recordDateGte?: string, recordDateGt?: string, recordDateLte?: string, recordDateLt?: string, declarationDateGte?: string, declarationDateGt?: string, declarationDateLte?: string, declarationDateLt?: string, payDateGte?: string, payDateGt?: string, payDateLte?: string, payDateLt?: string, cashAmountGte?: number, cashAmountGt?: number, cashAmountLte?: number, cashAmountLt?: number, order?: ListDividendsOrderEnum, limit?: number, sort?: ListDividendsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/dividends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (exDividendDate !== undefined) {
                localVarQueryParameter['ex_dividend_date'] = (exDividendDate as any instanceof Date) ?
                    (exDividendDate as any).toISOString().substring(0,10) :
                    exDividendDate;
            }

            if (recordDate !== undefined) {
                localVarQueryParameter['record_date'] = (recordDate as any instanceof Date) ?
                    (recordDate as any).toISOString().substring(0,10) :
                    recordDate;
            }

            if (declarationDate !== undefined) {
                localVarQueryParameter['declaration_date'] = (declarationDate as any instanceof Date) ?
                    (declarationDate as any).toISOString().substring(0,10) :
                    declarationDate;
            }

            if (payDate !== undefined) {
                localVarQueryParameter['pay_date'] = (payDate as any instanceof Date) ?
                    (payDate as any).toISOString().substring(0,10) :
                    payDate;
            }

            if (frequency !== undefined) {
                localVarQueryParameter['frequency'] = frequency;
            }

            if (cashAmount !== undefined) {
                localVarQueryParameter['cash_amount'] = cashAmount;
            }

            if (dividendType !== undefined) {
                localVarQueryParameter['dividend_type'] = dividendType;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (exDividendDateGte !== undefined) {
                localVarQueryParameter['ex_dividend_date.gte'] = (exDividendDateGte as any instanceof Date) ?
                    (exDividendDateGte as any).toISOString().substring(0,10) :
                    exDividendDateGte;
            }

            if (exDividendDateGt !== undefined) {
                localVarQueryParameter['ex_dividend_date.gt'] = (exDividendDateGt as any instanceof Date) ?
                    (exDividendDateGt as any).toISOString().substring(0,10) :
                    exDividendDateGt;
            }

            if (exDividendDateLte !== undefined) {
                localVarQueryParameter['ex_dividend_date.lte'] = (exDividendDateLte as any instanceof Date) ?
                    (exDividendDateLte as any).toISOString().substring(0,10) :
                    exDividendDateLte;
            }

            if (exDividendDateLt !== undefined) {
                localVarQueryParameter['ex_dividend_date.lt'] = (exDividendDateLt as any instanceof Date) ?
                    (exDividendDateLt as any).toISOString().substring(0,10) :
                    exDividendDateLt;
            }

            if (recordDateGte !== undefined) {
                localVarQueryParameter['record_date.gte'] = (recordDateGte as any instanceof Date) ?
                    (recordDateGte as any).toISOString().substring(0,10) :
                    recordDateGte;
            }

            if (recordDateGt !== undefined) {
                localVarQueryParameter['record_date.gt'] = (recordDateGt as any instanceof Date) ?
                    (recordDateGt as any).toISOString().substring(0,10) :
                    recordDateGt;
            }

            if (recordDateLte !== undefined) {
                localVarQueryParameter['record_date.lte'] = (recordDateLte as any instanceof Date) ?
                    (recordDateLte as any).toISOString().substring(0,10) :
                    recordDateLte;
            }

            if (recordDateLt !== undefined) {
                localVarQueryParameter['record_date.lt'] = (recordDateLt as any instanceof Date) ?
                    (recordDateLt as any).toISOString().substring(0,10) :
                    recordDateLt;
            }

            if (declarationDateGte !== undefined) {
                localVarQueryParameter['declaration_date.gte'] = (declarationDateGte as any instanceof Date) ?
                    (declarationDateGte as any).toISOString().substring(0,10) :
                    declarationDateGte;
            }

            if (declarationDateGt !== undefined) {
                localVarQueryParameter['declaration_date.gt'] = (declarationDateGt as any instanceof Date) ?
                    (declarationDateGt as any).toISOString().substring(0,10) :
                    declarationDateGt;
            }

            if (declarationDateLte !== undefined) {
                localVarQueryParameter['declaration_date.lte'] = (declarationDateLte as any instanceof Date) ?
                    (declarationDateLte as any).toISOString().substring(0,10) :
                    declarationDateLte;
            }

            if (declarationDateLt !== undefined) {
                localVarQueryParameter['declaration_date.lt'] = (declarationDateLt as any instanceof Date) ?
                    (declarationDateLt as any).toISOString().substring(0,10) :
                    declarationDateLt;
            }

            if (payDateGte !== undefined) {
                localVarQueryParameter['pay_date.gte'] = (payDateGte as any instanceof Date) ?
                    (payDateGte as any).toISOString().substring(0,10) :
                    payDateGte;
            }

            if (payDateGt !== undefined) {
                localVarQueryParameter['pay_date.gt'] = (payDateGt as any instanceof Date) ?
                    (payDateGt as any).toISOString().substring(0,10) :
                    payDateGt;
            }

            if (payDateLte !== undefined) {
                localVarQueryParameter['pay_date.lte'] = (payDateLte as any instanceof Date) ?
                    (payDateLte as any).toISOString().substring(0,10) :
                    payDateLte;
            }

            if (payDateLt !== undefined) {
                localVarQueryParameter['pay_date.lt'] = (payDateLt as any instanceof Date) ?
                    (payDateLt as any).toISOString().substring(0,10) :
                    payDateLt;
            }

            if (cashAmountGte !== undefined) {
                localVarQueryParameter['cash_amount.gte'] = cashAmountGte;
            }

            if (cashAmountGt !== undefined) {
                localVarQueryParameter['cash_amount.gt'] = cashAmountGt;
            }

            if (cashAmountLte !== undefined) {
                localVarQueryParameter['cash_amount.lte'] = cashAmountLte;
            }

            if (cashAmountLt !== undefined) {
                localVarQueryParameter['cash_amount.lt'] = cashAmountLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all exchanges that Polygon.io knows about.
         * @summary Exchanges
         * @param {ListExchangesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListExchangesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExchanges: async (assetClass?: ListExchangesAssetClassEnum, locale?: ListExchangesLocaleEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (assetClass !== undefined) {
                localVarQueryParameter['asset_class'] = assetClass;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
         * @summary Stock Financials vX
         * @param {string} [ticker] Query by company ticker.
         * @param {string} [cik] Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number
         * @param {string} [companyName] Query by company name.
         * @param {string} [sic] Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;)
         * @param {string} [filingDate] Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01
         * @param {string} [periodOfReportDate] The period of report for the filing with financials data in YYYY-MM-DD format.
         * @param {ListFinancialsTimeframeEnum} [timeframe] Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
         * @param {boolean} [includeSources] Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default.
         * @param {string} [companyNameSearch] Search by company_name.
         * @param {string} [filingDateGte] Search by filing_date.
         * @param {string} [filingDateGt] Search by filing_date.
         * @param {string} [filingDateLte] Search by filing_date.
         * @param {string} [filingDateLt] Search by filing_date.
         * @param {string} [periodOfReportDateGte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateGt] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLt] Search by period_of_report_date.
         * @param {ListFinancialsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 100.
         * @param {ListFinancialsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFinancials: async (ticker?: string, cik?: string, companyName?: string, sic?: string, filingDate?: string, periodOfReportDate?: string, timeframe?: ListFinancialsTimeframeEnum, includeSources?: boolean, companyNameSearch?: string, filingDateGte?: string, filingDateGt?: string, filingDateLte?: string, filingDateLt?: string, periodOfReportDateGte?: string, periodOfReportDateGt?: string, periodOfReportDateLte?: string, periodOfReportDateLt?: string, order?: ListFinancialsOrderEnum, limit?: number, sort?: ListFinancialsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vX/reference/financials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (companyName !== undefined) {
                localVarQueryParameter['company_name'] = companyName;
            }

            if (sic !== undefined) {
                localVarQueryParameter['sic'] = sic;
            }

            if (filingDate !== undefined) {
                localVarQueryParameter['filing_date'] = (filingDate as any instanceof Date) ?
                    (filingDate as any).toISOString().substring(0,10) :
                    filingDate;
            }

            if (periodOfReportDate !== undefined) {
                localVarQueryParameter['period_of_report_date'] = (periodOfReportDate as any instanceof Date) ?
                    (periodOfReportDate as any).toISOString().substring(0,10) :
                    periodOfReportDate;
            }

            if (timeframe !== undefined) {
                localVarQueryParameter['timeframe'] = timeframe;
            }

            if (includeSources !== undefined) {
                localVarQueryParameter['include_sources'] = includeSources;
            }

            if (companyNameSearch !== undefined) {
                localVarQueryParameter['company_name.search'] = companyNameSearch;
            }

            if (filingDateGte !== undefined) {
                localVarQueryParameter['filing_date.gte'] = (filingDateGte as any instanceof Date) ?
                    (filingDateGte as any).toISOString().substring(0,10) :
                    filingDateGte;
            }

            if (filingDateGt !== undefined) {
                localVarQueryParameter['filing_date.gt'] = (filingDateGt as any instanceof Date) ?
                    (filingDateGt as any).toISOString().substring(0,10) :
                    filingDateGt;
            }

            if (filingDateLte !== undefined) {
                localVarQueryParameter['filing_date.lte'] = (filingDateLte as any instanceof Date) ?
                    (filingDateLte as any).toISOString().substring(0,10) :
                    filingDateLte;
            }

            if (filingDateLt !== undefined) {
                localVarQueryParameter['filing_date.lt'] = (filingDateLt as any instanceof Date) ?
                    (filingDateLt as any).toISOString().substring(0,10) :
                    filingDateLt;
            }

            if (periodOfReportDateGte !== undefined) {
                localVarQueryParameter['period_of_report_date.gte'] = (periodOfReportDateGte as any instanceof Date) ?
                    (periodOfReportDateGte as any).toISOString().substring(0,10) :
                    periodOfReportDateGte;
            }

            if (periodOfReportDateGt !== undefined) {
                localVarQueryParameter['period_of_report_date.gt'] = (periodOfReportDateGt as any instanceof Date) ?
                    (periodOfReportDateGt as any).toISOString().substring(0,10) :
                    periodOfReportDateGt;
            }

            if (periodOfReportDateLte !== undefined) {
                localVarQueryParameter['period_of_report_date.lte'] = (periodOfReportDateLte as any instanceof Date) ?
                    (periodOfReportDateLte as any).toISOString().substring(0,10) :
                    periodOfReportDateLte;
            }

            if (periodOfReportDateLt !== undefined) {
                localVarQueryParameter['period_of_report_date.lt'] = (periodOfReportDateLt as any instanceof Date) ?
                    (periodOfReportDateLt as any).toISOString().substring(0,10) :
                    periodOfReportDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
         * @summary IPOs
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc.
         * @param {string} [usCode] Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
         * @param {string} [isin] Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
         * @param {string} [listingDate] Specify a listing date. This is the first trading date for the newly listed entity.
         * @param {ListIPOsIpoStatusEnum} [ipoStatus] Specify an IPO status.
         * @param {string} [listingDateGte] Range by listing_date.
         * @param {string} [listingDateGt] Range by listing_date.
         * @param {string} [listingDateLte] Range by listing_date.
         * @param {string} [listingDateLt] Range by listing_date.
         * @param {ListIPOsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListIPOsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIPOs: async (ticker?: string, usCode?: string, isin?: string, listingDate?: string, ipoStatus?: ListIPOsIpoStatusEnum, listingDateGte?: string, listingDateGt?: string, listingDateLte?: string, listingDateLt?: string, order?: ListIPOsOrderEnum, limit?: number, sort?: ListIPOsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vX/reference/ipos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (usCode !== undefined) {
                localVarQueryParameter['us_code'] = usCode;
            }

            if (isin !== undefined) {
                localVarQueryParameter['isin'] = isin;
            }

            if (listingDate !== undefined) {
                localVarQueryParameter['listing_date'] = (listingDate as any instanceof Date) ?
                    (listingDate as any).toISOString().substring(0,10) :
                    listingDate;
            }

            if (ipoStatus !== undefined) {
                localVarQueryParameter['ipo_status'] = ipoStatus;
            }

            if (listingDateGte !== undefined) {
                localVarQueryParameter['listing_date.gte'] = (listingDateGte as any instanceof Date) ?
                    (listingDateGte as any).toISOString().substring(0,10) :
                    listingDateGte;
            }

            if (listingDateGt !== undefined) {
                localVarQueryParameter['listing_date.gt'] = (listingDateGt as any instanceof Date) ?
                    (listingDateGt as any).toISOString().substring(0,10) :
                    listingDateGt;
            }

            if (listingDateLte !== undefined) {
                localVarQueryParameter['listing_date.lte'] = (listingDateLte as any instanceof Date) ?
                    (listingDateLte as any).toISOString().substring(0,10) :
                    listingDateLte;
            }

            if (listingDateLt !== undefined) {
                localVarQueryParameter['listing_date.lt'] = (listingDateLt as any instanceof Date) ?
                    (listingDateLt as any).toISOString().substring(0,10) :
                    listingDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
         * @summary Ticker News
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtc] Return results published on, before, or after this date.
         * @param {string} [tickerGte] Search by ticker.
         * @param {string} [tickerGt] Search by ticker.
         * @param {string} [tickerLte] Search by ticker.
         * @param {string} [tickerLt] Search by ticker.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGt] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLt] Search by published_utc.
         * @param {ListNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListNewsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNews: async (ticker?: string, publishedUtc?: ListNewsPublishedUtcParameter, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, publishedUtcGte?: ListNewsPublishedUtcParameter, publishedUtcGt?: ListNewsPublishedUtcParameter, publishedUtcLte?: ListNewsPublishedUtcParameter, publishedUtcLt?: ListNewsPublishedUtcParameter, order?: ListNewsOrderEnum, limit?: number, sort?: ListNewsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/reference/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (publishedUtc !== undefined) {
                for (const [key, value] of Object.entries(publishedUtc)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (publishedUtcGte !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcGte)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (publishedUtcGt !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcGt)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (publishedUtcLte !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcLte)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (publishedUtcLt !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcLt)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for historical options contracts. This provides both active and expired options contracts.
         * @summary Options Contracts
         * @param {string} [underlyingTicker] Query for contracts relating to an underlying stock ticker.
         * @param {string} [ticker] This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://polygon.io/docs/options/get_v3_reference_options_contracts__options_ticker).
         * @param {ListOptionsContractsContractTypeEnum} [contractType] Query by the type of contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {string} [asOf] Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {boolean} [expired] Query for expired contracts. Default is false.
         * @param {string} [underlyingTickerGte] Range by underlying_ticker.
         * @param {string} [underlyingTickerGt] Range by underlying_ticker.
         * @param {string} [underlyingTickerLte] Range by underlying_ticker.
         * @param {string} [underlyingTickerLt] Range by underlying_ticker.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {ListOptionsContractsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListOptionsContractsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOptionsContracts: async (underlyingTicker?: string, ticker?: string, contractType?: ListOptionsContractsContractTypeEnum, expirationDate?: string, asOf?: string, strikePrice?: number, expired?: boolean, underlyingTickerGte?: string, underlyingTickerGt?: string, underlyingTickerLte?: string, underlyingTickerLt?: string, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, order?: ListOptionsContractsOrderEnum, limit?: number, sort?: ListOptionsContractsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/options/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (underlyingTicker !== undefined) {
                localVarQueryParameter['underlying_ticker'] = underlyingTicker;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contract_type'] = contractType;
            }

            if (expirationDate !== undefined) {
                localVarQueryParameter['expiration_date'] = expirationDate;
            }

            if (asOf !== undefined) {
                localVarQueryParameter['as_of'] = asOf;
            }

            if (strikePrice !== undefined) {
                localVarQueryParameter['strike_price'] = strikePrice;
            }

            if (expired !== undefined) {
                localVarQueryParameter['expired'] = expired;
            }

            if (underlyingTickerGte !== undefined) {
                localVarQueryParameter['underlying_ticker.gte'] = underlyingTickerGte;
            }

            if (underlyingTickerGt !== undefined) {
                localVarQueryParameter['underlying_ticker.gt'] = underlyingTickerGt;
            }

            if (underlyingTickerLte !== undefined) {
                localVarQueryParameter['underlying_ticker.lte'] = underlyingTickerLte;
            }

            if (underlyingTickerLt !== undefined) {
                localVarQueryParameter['underlying_ticker.lt'] = underlyingTickerLt;
            }

            if (expirationDateGte !== undefined) {
                localVarQueryParameter['expiration_date.gte'] = expirationDateGte;
            }

            if (expirationDateGt !== undefined) {
                localVarQueryParameter['expiration_date.gt'] = expirationDateGt;
            }

            if (expirationDateLte !== undefined) {
                localVarQueryParameter['expiration_date.lte'] = expirationDateLte;
            }

            if (expirationDateLt !== undefined) {
                localVarQueryParameter['expiration_date.lt'] = expirationDateLt;
            }

            if (strikePriceGte !== undefined) {
                localVarQueryParameter['strike_price.gte'] = strikePriceGte;
            }

            if (strikePriceGt !== undefined) {
                localVarQueryParameter['strike_price.gt'] = strikePriceGt;
            }

            if (strikePriceLte !== undefined) {
                localVarQueryParameter['strike_price.lte'] = strikePriceLte;
            }

            if (strikePriceLt !== undefined) {
                localVarQueryParameter['strike_price.lt'] = strikePriceLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
         * @summary Stock Splits v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [executionDate] Query by execution date with the format YYYY-MM-DD.
         * @param {boolean | null} [reverseSplit] Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [executionDateGte] Range by execution_date.
         * @param {string} [executionDateGt] Range by execution_date.
         * @param {string} [executionDateLte] Range by execution_date.
         * @param {string} [executionDateLt] Range by execution_date.
         * @param {ListStockSplitsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListStockSplitsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStockSplits: async (ticker?: string, executionDate?: string, reverseSplit?: boolean | null, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, executionDateGte?: string, executionDateGt?: string, executionDateLte?: string, executionDateLt?: string, order?: ListStockSplitsOrderEnum, limit?: number, sort?: ListStockSplitsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/splits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (executionDate !== undefined) {
                localVarQueryParameter['execution_date'] = (executionDate as any instanceof Date) ?
                    (executionDate as any).toISOString().substring(0,10) :
                    executionDate;
            }

            if (reverseSplit !== undefined) {
                localVarQueryParameter['reverse_split'] = reverseSplit;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (executionDateGte !== undefined) {
                localVarQueryParameter['execution_date.gte'] = (executionDateGte as any instanceof Date) ?
                    (executionDateGte as any).toISOString().substring(0,10) :
                    executionDateGte;
            }

            if (executionDateGt !== undefined) {
                localVarQueryParameter['execution_date.gt'] = (executionDateGt as any instanceof Date) ?
                    (executionDateGt as any).toISOString().substring(0,10) :
                    executionDateGt;
            }

            if (executionDateLte !== undefined) {
                localVarQueryParameter['execution_date.lte'] = (executionDateLte as any instanceof Date) ?
                    (executionDateLte as any).toISOString().substring(0,10) :
                    executionDateLte;
            }

            if (executionDateLt !== undefined) {
                localVarQueryParameter['execution_date.lt'] = (executionDateLt as any instanceof Date) ?
                    (executionDateLt as any).toISOString().substring(0,10) :
                    executionDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all ticker types that Polygon.io has.
         * @summary Ticker Types
         * @param {ListTickerTypesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListTickerTypesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickerTypes: async (assetClass?: ListTickerTypesAssetClassEnum, locale?: ListTickerTypesLocaleEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/tickers/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (assetClass !== undefined) {
                localVarQueryParameter['asset_class'] = assetClass;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
         * @summary Tickers
         * @param {string} [ticker] Specify a ticker symbol. Defaults to empty string which queries all tickers.
         * @param {ListTickersTypeEnum} [type] Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types). Defaults to empty string which queries all types.
         * @param {ListTickersMarketEnum} [market] Filter by market type. By default all markets are included.
         * @param {string} [exchange] Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes [at the ISO org website](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges.
         * @param {string} [cusip] Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
         * @param {string} [cik] Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs.
         * @param {string} [date] Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.
         * @param {string} [search] Search for terms within the ticker and/or company name.
         * @param {boolean} [active] Specify if the tickers returned should be actively traded on the queried date. Default is true.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {ListTickersOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 1000.
         * @param {ListTickersSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickers: async (ticker?: string, type?: ListTickersTypeEnum, market?: ListTickersMarketEnum, exchange?: string, cusip?: string, cik?: string, date?: string, search?: string, active?: boolean, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: ListTickersOrderEnum, limit?: number, sort?: ListTickersSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (exchange !== undefined) {
                localVarQueryParameter['exchange'] = exchange;
            }

            if (cusip !== undefined) {
                localVarQueryParameter['cusip'] = cusip;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker Full Book (L2)
         * @param {string} ticker The cryptocurrency ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedGetCryptoSnapshotTickerBook(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeprecatedGetCryptoSnapshotTickerBook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedGetCryptoSnapshotTickerBook(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedGetCryptoSnapshotTickerBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get historic trade ticks for a cryptocurrency pair. 
         * @summary Historic Crypto Trades
         * @param {string} from The \&quot;from\&quot; symbol of the crypto pair.
         * @param {string} to The \&quot;to\&quot; symbol of the crypto pair.
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedGetHistoricCryptoTrades(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeprecatedGetHistoricCryptoTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedGetHistoricCryptoTrades(from, to, date, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedGetHistoricCryptoTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get historic ticks for a forex currency pair. 
         * @summary Historic Forex Ticks
         * @param {string} from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
         * @param {string} to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedGetHistoricForexQuotes(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeprecatedGetHistoricForexQuotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedGetHistoricForexQuotes(from, to, date, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedGetHistoricForexQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get NBBO quotes for a given ticker symbol on a specified date. 
         * @summary Quotes (NBBO)
         * @param {string} ticker The ticker symbol we want quotes for.
         * @param {string} date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedGetHistoricStocksQuotes(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeprecatedGetHistoricStocksQuotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedGetHistoricStocksQuotes(ticker, date, timestamp, timestampLimit, reverse, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedGetHistoricStocksQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a given ticker symbol on a specified date. 
         * @summary Trades
         * @param {string} ticker The ticker symbol we want trades for.
         * @param {string} date The date/day of the trades to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedGetHistoricStocksTrades(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeprecatedGetHistoricStocksTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedGetHistoricStocksTrades(ticker, date, timestamp, timestampLimit, reverse, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedGetHistoricStocksTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [firm] The name of the research firm or investment bank issuing the rating.
         * @param {string} [firmAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [firmGt] Filter greater than the value.
         * @param {string} [firmGte] Filter greater than or equal to the value.
         * @param {string} [firmLt] Filter less than the value.
         * @param {string} [firmLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The identifer used by Benzinga for the firm record.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaRatingId] The identifier used by Benzinga for the rating record.
         * @param {string} [benzingaRatingIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaRatingIdGt] Filter greater than the value.
         * @param {string} [benzingaRatingIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaRatingIdLt] Filter less than the value.
         * @param {string} [benzingaRatingIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1AnalystInsights(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, firm?: string, firmAnyOf?: string, firmGt?: string, firmGte?: string, firmLt?: string, firmLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, benzingaRatingId?: string, benzingaRatingIdAnyOf?: string, benzingaRatingIdGt?: string, benzingaRatingIdGte?: string, benzingaRatingIdLt?: string, benzingaRatingIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1AnalystInsights200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1AnalystInsights(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, firm, firmAnyOf, firmGt, firmGte, firmLt, firmLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, benzingaRatingId, benzingaRatingIdAnyOf, benzingaRatingIdGt, benzingaRatingIdGte, benzingaRatingIdLt, benzingaRatingIdLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1AnalystInsights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [benzingaId] The identifier used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The unique identifier assigned by Benzinga to the research firm or investment bank.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {string} [firmName] The name of the research firm or investment bank issuing the ratings.
         * @param {string} [firmNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [firmNameGt] Filter greater than the value.
         * @param {string} [firmNameGte] Filter greater than or equal to the value.
         * @param {string} [firmNameLt] Filter less than the value.
         * @param {string} [firmNameLte] Filter less than or equal to the value.
         * @param {string} [fullName] The full name of the analyst associated with the ratings.
         * @param {string} [fullNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fullNameGt] Filter greater than the value.
         * @param {string} [fullNameGte] Filter greater than or equal to the value.
         * @param {string} [fullNameLt] Filter less than the value.
         * @param {string} [fullNameLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;full_name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1Analysts(benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, firmName?: string, firmNameAnyOf?: string, firmNameGt?: string, firmNameGte?: string, firmNameLt?: string, firmNameLte?: string, fullName?: string, fullNameAnyOf?: string, fullNameGt?: string, fullNameGte?: string, fullNameLt?: string, fullNameLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1Analysts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1Analysts(benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, firmName, firmNameAnyOf, firmNameGt, firmNameGte, firmNameLt, firmNameLte, fullName, fullNameAnyOf, fullNameGt, fullNameGte, fullNameLt, fullNameLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1Analysts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ticker The requested ticker.
         * @param {string} [date] Filter equal to the value.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1ConsensusRatings(ticker: string, date?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1ConsensusRatings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1ConsensusRatings(ticker, date, dateGt, dateGte, dateLt, dateLte, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1ConsensusRatings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company reporting earnings.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [dateStatus] Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
         * @param {string} [dateStatusAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateStatusGt] Filter greater than the value.
         * @param {string} [dateStatusGte] Filter greater than or equal to the value.
         * @param {string} [dateStatusLt] Filter less than the value.
         * @param {string} [dateStatusLte] Filter less than or equal to the value.
         * @param {number} [epsSurprisePercent] The percentage difference between the actual and estimated EPS. Value must be a floating point number.
         * @param {string} [epsSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [epsSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercent] The percentage difference between the actual and estimated revenue. Value must be a floating point number.
         * @param {string} [revenueSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalYear] The fiscal year in which the earnings period falls. Value must be an integer.
         * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [fiscalPeriod] The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
         * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fiscalPeriodGt] Filter greater than the value.
         * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
         * @param {string} [fiscalPeriodLt] Filter less than the value.
         * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1Earnings(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, dateStatus?: string, dateStatusAnyOf?: string, dateStatusGt?: string, dateStatusGte?: string, dateStatusLt?: string, dateStatusLte?: string, epsSurprisePercent?: number, epsSurprisePercentAnyOf?: string, epsSurprisePercentGt?: number, epsSurprisePercentGte?: number, epsSurprisePercentLt?: number, epsSurprisePercentLte?: number, revenueSurprisePercent?: number, revenueSurprisePercentAnyOf?: string, revenueSurprisePercentGt?: number, revenueSurprisePercentGte?: number, revenueSurprisePercentLt?: number, revenueSurprisePercentLte?: number, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1Earnings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1Earnings(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, importance, importanceAnyOf, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, dateStatus, dateStatusAnyOf, dateStatusGt, dateStatusGte, dateStatusLt, dateStatusLte, epsSurprisePercent, epsSurprisePercentAnyOf, epsSurprisePercentGt, epsSurprisePercentGte, epsSurprisePercentLt, epsSurprisePercentLte, revenueSurprisePercent, revenueSurprisePercentAnyOf, revenueSurprisePercentGt, revenueSurprisePercentGte, revenueSurprisePercentLt, revenueSurprisePercentLte, fiscalYear, fiscalYearAnyOf, fiscalYearGt, fiscalYearGte, fiscalYearLt, fiscalYearLte, fiscalPeriod, fiscalPeriodAnyOf, fiscalPeriodGt, fiscalPeriodGte, fiscalPeriodLt, fiscalPeriodLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1Earnings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [benzingaId] The identifer used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1Firms(benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1Firms200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1Firms(benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1Firms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company issuing guidance.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [positioning] Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are \&#39;primary\&#39; (the emphasized figure) and \&#39;secondary\&#39; (a supporting or alternate figure)
         * @param {string} [positioningAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [positioningGt] Filter greater than the value.
         * @param {string} [positioningGte] Filter greater than or equal to the value.
         * @param {string} [positioningLt] Filter less than the value.
         * @param {string} [positioningLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {number} [fiscalYear] The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer.
         * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [fiscalPeriod] The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
         * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fiscalPeriodGt] Filter greater than the value.
         * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
         * @param {string} [fiscalPeriodLt] Filter less than the value.
         * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1Guidance(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, positioning?: string, positioningAnyOf?: string, positioningGt?: string, positioningGte?: string, positioningLt?: string, positioningLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1Guidance200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1Guidance(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, positioning, positioningAnyOf, positioningGt, positioningGte, positioningLt, positioningLte, importance, importanceAnyOf, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, fiscalYear, fiscalYearAnyOf, fiscalYearGt, fiscalYearGte, fiscalYearLt, fiscalYearLte, fiscalPeriod, fiscalPeriodAnyOf, fiscalPeriodGt, fiscalPeriodGte, fiscalPeriodLt, fiscalPeriodLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1Guidance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [published] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
         * @param {string} [publishedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [publishedGt] Filter greater than the value.
         * @param {string} [publishedGte] Filter greater than or equal to the value.
         * @param {string} [publishedLt] Filter less than the value.
         * @param {string} [publishedLte] Filter less than or equal to the value.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channels] Filter for arrays that contain the value.
         * @param {string} [channelsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channelsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tags] Filter for arrays that contain the value.
         * @param {string} [tagsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tagsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [author] The name of the journalist or entity that authored the news article.
         * @param {string} [authorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [authorGt] Filter greater than the value.
         * @param {string} [authorGte] Filter greater than or equal to the value.
         * @param {string} [authorLt] Filter less than the value.
         * @param {string} [authorLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;published\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1News(published?: string, publishedAnyOf?: string, publishedGt?: string, publishedGte?: string, publishedLt?: string, publishedLte?: string, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, channels?: string, channelsAllOf?: string, channelsAnyOf?: string, tags?: string, tagsAllOf?: string, tagsAnyOf?: string, author?: string, authorAnyOf?: string, authorGt?: string, authorGte?: string, authorLt?: string, authorLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1News200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1News(published, publishedAnyOf, publishedGt, publishedGte, publishedLt, publishedLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, tickers, tickersAllOf, tickersAnyOf, channels, channelsAllOf, channelsAnyOf, tags, tagsAllOf, tagsAnyOf, author, authorAnyOf, authorGt, authorGte, authorLt, authorLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1News']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
         * @param {string} [ratingActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [ratingActionGt] Filter greater than the value.
         * @param {string} [ratingActionGte] Filter greater than or equal to the value.
         * @param {string} [ratingActionLt] Filter less than the value.
         * @param {string} [ratingActionLte] Filter less than or equal to the value.
         * @param {string} [priceTargetAction] The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
         * @param {string} [priceTargetActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [priceTargetActionGt] Filter greater than the value.
         * @param {string} [priceTargetActionGte] Filter greater than or equal to the value.
         * @param {string} [priceTargetActionLt] Filter less than the value.
         * @param {string} [priceTargetActionLte] Filter less than or equal to the value.
         * @param {string} [benzingaId] The identifer used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaAnalystId] Filter equal to the value.
         * @param {string} [benzingaAnalystIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaAnalystIdGt] Filter greater than the value.
         * @param {string} [benzingaAnalystIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaAnalystIdLt] Filter less than the value.
         * @param {string} [benzingaAnalystIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] Filter equal to the value.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1Ratings(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, ratingAction?: string, ratingActionAnyOf?: string, ratingActionGt?: string, ratingActionGte?: string, ratingActionLt?: string, ratingActionLte?: string, priceTargetAction?: string, priceTargetActionAnyOf?: string, priceTargetActionGt?: string, priceTargetActionGte?: string, priceTargetActionLt?: string, priceTargetActionLte?: string, benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaAnalystId?: string, benzingaAnalystIdAnyOf?: string, benzingaAnalystIdGt?: string, benzingaAnalystIdGte?: string, benzingaAnalystIdLt?: string, benzingaAnalystIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1Ratings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1Ratings(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, importance, importanceAnyOf, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, ratingAction, ratingActionAnyOf, ratingActionGt, ratingActionGte, ratingActionLt, ratingActionLte, priceTargetAction, priceTargetActionAnyOf, priceTargetActionGt, priceTargetActionGte, priceTargetActionLt, priceTargetActionLte, benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, benzingaAnalystId, benzingaAnalystIdAnyOf, benzingaAnalystIdGt, benzingaAnalystIdGte, benzingaAnalystIdLt, benzingaAnalystIdLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1Ratings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetCryptoAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetCryptoAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoAggregates(cryptoTicker: string, multiplier: number, timespan: GetCryptoAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetCryptoAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoAggregates(cryptoTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoEMA(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoEMATimespanEnum, window?: number, seriesType?: GetCryptoEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoEMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} cryptoTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetCryptoMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate MACD data. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoMACD(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoMACDTimespanEnum, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetCryptoMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoMACD(cryptoTicker, timestamp, timespan, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close prices of a cryptocurrency symbol on a certain day. 
         * @summary Daily Open/Close
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoOpenClose(from: string, to: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoOpenClose200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoOpenClose(from, to, date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoOpenClose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoRSI(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoRSITimespanEnum, window?: number, seriesType?: GetCryptoRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoRSI(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoSMA(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoSMATimespanEnum, window?: number, seriesType?: GetCryptoSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoSMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetCryptoSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoSnapshotDirection(direction: GetCryptoSnapshotDirectionDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSnapshotDirection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoSnapshotDirection(direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoSnapshotDirection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker Ticker of the snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoSnapshotTicker(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSnapshotTicker200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoSnapshotTicker(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoSnapshotTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoSnapshotTickers(tickers?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSnapshotTickers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoSnapshotTickers(tickers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoSnapshotTickers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a crypto ticker symbol in a given time range.
         * @summary Trades
         * @param {string} cryptoTicker The ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetCryptoTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetCryptoTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoTrades(cryptoTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetCryptoTradesOrderEnum, limit?: number, sort?: GetCryptoTradesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoTrades(cryptoTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
         * @summary Real-time Currency Conversion
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {number} [amount] The amount to convert, with a decimal.
         * @param {GetCurrencyConversionPrecisionEnum} [precision] The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencyConversion(from: string, to: string, amount?: number, precision?: GetCurrencyConversionPrecisionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCurrencyConversion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencyConversion(from, to, amount, precision, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCurrencyConversion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
         * @summary Ticker Events
         * @param {string} id Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the  [Ticker Details Endpoint](https://polygon.io/docs/stocks/get_v3_reference_tickers__ticker)
         * @param {string} [types] A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(id: string, types?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(id, types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [date] Calendar date of the yield observation (YYYYMMDD).
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFedV1TreasuryYields(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFedV1TreasuryYields200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFedV1TreasuryYields(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFedV1TreasuryYields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetForexAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetForexAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexAggregates(forexTicker: string, multiplier: number, timespan: GetForexAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetForexAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexAggregates(forexTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetForexEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexEMA(fxTicker: string, timestamp?: string, timespan?: GetForexEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexEMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} fxTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetForexMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexMACD(fxTicker: string, timestamp?: string, timespan?: GetForexMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetForexMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexMACD(fxTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get BBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (BBO)
         * @param {string} fxTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetForexQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetForexQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexQuotes(fxTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetForexQuotesOrderEnum, limit?: number, sort?: GetForexQuotesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetForexQuotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexQuotes(fxTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} fxTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetForexRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexRSI(fxTicker: string, timestamp?: string, timespan?: GetForexRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexRSI(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} fxTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetForexSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexSMA(fxTicker: string, timestamp?: string, timespan?: GetForexSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexSMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetForexSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexSnapshotDirection(direction: GetForexSnapshotDirectionDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetForexSnapshotTickers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexSnapshotDirection(direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexSnapshotDirection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker The forex ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexSnapshotTicker(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetForexSnapshotTicker200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexSnapshotTicker(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexSnapshotTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexSnapshotTickers(tickers?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetForexSnapshotTickers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexSnapshotTickers(tickers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexSnapshotTickers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupedCryptoAggregates(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetGroupedCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupedCryptoAggregates(date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGroupedCryptoAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupedForexAggregates(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetGroupedCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupedForexAggregates(date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGroupedForexAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupedStocksAggregates(date: string, adjusted?: boolean, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetGroupedStocksAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupedStocksAggregates(date, adjusted, includeOtc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGroupedStocksAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetIndicesAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesAggregates(indicesTicker: string, multiplier: number, timespan: GetIndicesAggregatesTimespanEnum, from: string, to: string, sort?: GetIndicesAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPreviousIndicesAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesAggregates(indicesTicker, multiplier, timespan, from, to, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetIndicesEMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesEMA(indicesTicker: string, timestamp?: string, timespan?: GetIndicesEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesEMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} indicesTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetIndicesMACDSeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close values to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesMACD(indicesTicker: string, timestamp?: string, timespan?: GetIndicesMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetIndicesMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesMACD(indicesTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close and afterhours values of a index symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesOpenClose(indicesTicker: string, date: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetIndicesOpenClose200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesOpenClose(indicesTicker, date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesOpenClose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetIndicesRSISeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close values to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesRSI(indicesTicker: string, timestamp?: string, timespan?: GetIndicesRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesRSI(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetIndicesSMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesSMA(indicesTicker: string, timestamp?: string, timespan?: GetIndicesSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesSMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Snapshot of indices data for said tickers
         * @summary Indices Snapshot
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {GetIndicesSnapshotOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetIndicesSnapshotSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesSnapshot(tickerAnyOf?: string, ticker?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: GetIndicesSnapshotOrderEnum, limit?: number, sort?: GetIndicesSnapshotSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetIndicesSnapshot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesSnapshot(tickerAnyOf, ticker, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the last trade tick for a cryptocurrency pair.
         * @summary Last Trade for a Crypto Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastCryptoTrade(from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLastCryptoTrade200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastCryptoTrade(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLastCryptoTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the last quote tick for a forex currency pair.
         * @summary Last Quote for a Currency Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastCurrencyQuote(from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLastCurrencyQuote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastCurrencyQuote(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLastCurrencyQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent trade for a given options contract.
         * @summary Last Trade
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastOptionsTrade(optionsTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLastOptionsTrade200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastOptionsTrade(optionsTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLastOptionsTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent NBBO (Quote) tick for a given stock.
         * @summary Last Quote
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastStocksQuote(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLastStocksQuote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastStocksQuote(stocksTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLastStocksQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent trade for a given stock.
         * @summary Last Trade
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastStocksTrade(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLastOptionsTrade200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastStocksTrade(stocksTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLastStocksTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get upcoming market holidays and their open/close times.
         * @summary Market Holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketHolidays(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Array<GetMarketHolidays200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketHolidays(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMarketHolidays']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current trading status of the exchanges and overall financial markets.
         * @summary Market Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetMarketStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMarketStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the snapshot of an option contract for a stock equity.
         * @summary Option Contract
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {string} optionContract The option contract identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionContract(underlyingAsset: string, optionContract: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionContract(underlyingAsset, optionContract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetOptionsAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetOptionsAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsAggregates(optionsTicker: string, multiplier: number, timespan: GetOptionsAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetOptionsAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsAggregates(optionsTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the snapshot of all options contracts for an underlying ticker.
         * @summary Options Chain
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {GetOptionsChainContractTypeEnum} [contractType] Query by the type of contract.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {GetOptionsChainOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetOptionsChainSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsChain(underlyingAsset: string, strikePrice?: number, expirationDate?: string, contractType?: GetOptionsChainContractTypeEnum, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, order?: GetOptionsChainOrderEnum, limit?: number, sort?: GetOptionsChainSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsChain200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsChain(underlyingAsset, strikePrice, expirationDate, contractType, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsChain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an options contract
         * @summary Options Contract
         * @param {string} optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://polygon.io/blog/how-to-read-a-stock-options-ticker/).
         * @param {string} [asOf] Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsContract(optionsTicker: string, asOf?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsContract(optionsTicker, asOf, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetOptionsEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsEMA(optionsTicker: string, timestamp?: string, timespan?: GetOptionsEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsEMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} optionsTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetOptionsMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsMACD(optionsTicker: string, timestamp?: string, timespan?: GetOptionsMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetOptionsMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsMACD(optionsTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close and afterhours prices of an options contract on a certain date. 
         * @summary Daily Open/Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsOpenClose(optionsTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsOpenClose200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsOpenClose(optionsTicker, date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsOpenClose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get quotes for an options ticker symbol in a given time range.
         * @summary Quotes
         * @param {string} optionsTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetOptionsQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetOptionsQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsQuotes(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsQuotesOrderEnum, limit?: number, sort?: GetOptionsQuotesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsQuotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsQuotes(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetOptionsRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsRSI(optionsTicker: string, timestamp?: string, timespan?: GetOptionsRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsRSI(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetOptionsSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsSMA(optionsTicker: string, timestamp?: string, timespan?: GetOptionsSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsSMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for an options ticker symbol in a given time range.
         * @summary Trades
         * @param {string} optionsTicker The options ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetOptionsTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetOptionsTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsTrades(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsTradesOrderEnum, limit?: number, sort?: GetOptionsTradesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsTrades(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
         * @summary Previous Close
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousCryptoAggregates(cryptoTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPreviousCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousCryptoAggregates(cryptoTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPreviousCryptoAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
         * @summary Previous Close
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousForexAggregates(forexTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPreviousForexAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousForexAggregates(forexTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPreviousForexAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
         * @summary Previous Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousIndicesAggregates(indicesTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPreviousIndicesAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousIndicesAggregates(indicesTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPreviousIndicesAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
         * @summary Previous Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousOptionsAggregates(optionsTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousOptionsAggregates(optionsTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPreviousOptionsAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
         * @summary Previous Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousStocksAggregates(stocksTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousStocksAggregates(stocksTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPreviousStocksAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of tickers related to the queried ticker based on News and Returns data.
         * @summary Related Companies
         * @param {string} ticker The ticker symbol to search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelatedCompanies(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetRelatedCompanies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelatedCompanies(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRelatedCompanies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
         * @summary Summaries
         * @param {string} [tickerAnyOf] Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://polygon.io/docs/stocks/get_v3_reference_tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshotSummary(tickerAnyOf?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSnapshotSummary200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshotSummary(tickerAnyOf, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSnapshotSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get snapshots for assets of all types
         * @summary Universal Snapshot
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {GetSnapshotsTypeEnum} [type] Query by the type of asset.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. 
         * @param {GetSnapshotsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetSnapshotsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshots(ticker?: string, type?: GetSnapshotsTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, tickerAnyOf?: string, order?: GetSnapshotsOrderEnum, limit?: number, sort?: GetSnapshotsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSnapshots200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshots(ticker, type, tickerGte, tickerGt, tickerLte, tickerLt, tickerAnyOf, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSnapshots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetStocksAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetStocksAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksAggregates(stocksTicker: string, multiplier: number, timespan: GetStocksAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetStocksAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksAggregates(stocksTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetStocksEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksEMA(stockTicker: string, timestamp?: string, timespan?: GetStocksEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksEMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetStocksMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksMACD(stockTicker: string, timestamp?: string, timespan?: GetStocksMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetStocksMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksMACD(stockTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close and afterhours prices of a stock symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksOpenClose(stocksTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsOpenClose200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksOpenClose(stocksTicker, date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksOpenClose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get NBBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (NBBO)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetStocksQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetStocksQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksQuotes(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksQuotesOrderEnum, limit?: number, sort?: GetStocksQuotesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksQuotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksQuotes(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetStocksRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksRSI(stockTicker: string, timestamp?: string, timespan?: GetStocksRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksRSI(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetStocksSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksSMA(stockTicker: string, timestamp?: string, timespan?: GetStocksSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksSMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetStocksSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksSnapshotDirection(direction: GetStocksSnapshotDirectionDirectionEnum, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksSnapshotDirection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksSnapshotDirection(direction, includeOtc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksSnapshotDirection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary Ticker
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksSnapshotTicker(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksSnapshotTicker200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksSnapshotTicker(stocksTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksSnapshotTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksSnapshotTickers(tickers?: Array<string>, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksSnapshotTickers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksSnapshotTickers(tickers, includeOtc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksSnapshotTickers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a ticker symbol in a given time range.
         * @summary Trades
         * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetStocksTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetStocksTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksTrades(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksTradesOrderEnum, limit?: number, sort?: GetStocksTradesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksTrades(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [daysToCover] Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number.
         * @param {string} [daysToCoverAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [daysToCoverGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [daysToCoverGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [daysToCoverLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [daysToCoverLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [settlementDate] The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
         * @param {string} [settlementDateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [settlementDateGt] Filter greater than the value.
         * @param {string} [settlementDateGte] Filter greater than or equal to the value.
         * @param {string} [settlementDateLt] Filter less than the value.
         * @param {string} [settlementDateLte] Filter less than or equal to the value.
         * @param {number} [avgDailyVolume] The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer.
         * @param {string} [avgDailyVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [avgDailyVolumeGt] Filter greater than the value. Value must be an integer.
         * @param {number} [avgDailyVolumeGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [avgDailyVolumeLt] Filter less than the value. Value must be an integer.
         * @param {number} [avgDailyVolumeLte] Filter less than or equal to the value. Value must be an integer.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksV1ShortInterest(ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, daysToCover?: number, daysToCoverAnyOf?: string, daysToCoverGt?: number, daysToCoverGte?: number, daysToCoverLt?: number, daysToCoverLte?: number, settlementDate?: string, settlementDateAnyOf?: string, settlementDateGt?: string, settlementDateGte?: string, settlementDateLt?: string, settlementDateLte?: string, avgDailyVolume?: number, avgDailyVolumeAnyOf?: string, avgDailyVolumeGt?: number, avgDailyVolumeGte?: number, avgDailyVolumeLt?: number, avgDailyVolumeLte?: number, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksV1ShortInterest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksV1ShortInterest(ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, daysToCover, daysToCoverAnyOf, daysToCoverGt, daysToCoverGte, daysToCoverLt, daysToCoverLte, settlementDate, settlementDateAnyOf, settlementDateGt, settlementDateGte, settlementDateLt, settlementDateLte, avgDailyVolume, avgDailyVolumeAnyOf, avgDailyVolumeGt, avgDailyVolumeGte, avgDailyVolumeLt, avgDailyVolumeLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksV1ShortInterest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [date] The date of trade activity reported in the format YYYY-MM-DD
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [shortVolumeRatio] The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number.
         * @param {string} [shortVolumeRatioAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [shortVolumeRatioGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [totalVolume] Total reported volume across all venues for the ticker on the given date. Value must be an integer.
         * @param {string} [totalVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [totalVolumeGt] Filter greater than the value. Value must be an integer.
         * @param {number} [totalVolumeGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [totalVolumeLt] Filter less than the value. Value must be an integer.
         * @param {number} [totalVolumeLte] Filter less than or equal to the value. Value must be an integer.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksV1ShortVolume(ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, shortVolumeRatio?: number, shortVolumeRatioAnyOf?: string, shortVolumeRatioGt?: number, shortVolumeRatioGte?: number, shortVolumeRatioLt?: number, shortVolumeRatioLte?: number, totalVolume?: number, totalVolumeAnyOf?: string, totalVolumeGt?: number, totalVolumeGte?: number, totalVolumeLt?: number, totalVolumeLte?: number, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksV1ShortVolume200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksV1ShortVolume(ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, shortVolumeRatio, shortVolumeRatioAnyOf, shortVolumeRatioGt, shortVolumeRatioGte, shortVolumeRatioLt, shortVolumeRatioLte, totalVolume, totalVolumeAnyOf, totalVolumeGt, totalVolumeGte, totalVolumeLt, totalVolumeLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksV1ShortVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
         * @summary Ticker Details v3
         * @param {string} ticker The ticker symbol of the asset.
         * @param {string} [date] Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicker(ticker: string, date?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetTicker200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicker(ticker, date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all conditions that Polygon.io uses.
         * @summary Conditions
         * @param {ListConditionsAssetClassEnum} [assetClass] Filter for conditions within a given asset class.
         * @param {ListConditionsDataTypeEnum} [dataType] Filter by data type.
         * @param {number} [id] Filter for conditions with a given ID.
         * @param {ListConditionsSipEnum} [sip] Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
         * @param {ListConditionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListConditionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConditions(assetClass?: ListConditionsAssetClassEnum, dataType?: ListConditionsDataTypeEnum, id?: number, sip?: ListConditionsSipEnum, order?: ListConditionsOrderEnum, limit?: number, sort?: ListConditionsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListConditions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConditions(assetClass, dataType, id, sip, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listConditions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
         * @summary Dividends v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [exDividendDate] Query by ex-dividend date with the format YYYY-MM-DD.
         * @param {string} [recordDate] Query by record date with the format YYYY-MM-DD.
         * @param {string} [declarationDate] Query by declaration date with the format YYYY-MM-DD.
         * @param {string} [payDate] Query by pay date with the format YYYY-MM-DD.
         * @param {ListDividendsFrequencyEnum} [frequency] Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
         * @param {number} [cashAmount] Query by the cash amount of the dividend.
         * @param {ListDividendsDividendTypeEnum} [dividendType] Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [exDividendDateGte] Range by ex_dividend_date.
         * @param {string} [exDividendDateGt] Range by ex_dividend_date.
         * @param {string} [exDividendDateLte] Range by ex_dividend_date.
         * @param {string} [exDividendDateLt] Range by ex_dividend_date.
         * @param {string} [recordDateGte] Range by record_date.
         * @param {string} [recordDateGt] Range by record_date.
         * @param {string} [recordDateLte] Range by record_date.
         * @param {string} [recordDateLt] Range by record_date.
         * @param {string} [declarationDateGte] Range by declaration_date.
         * @param {string} [declarationDateGt] Range by declaration_date.
         * @param {string} [declarationDateLte] Range by declaration_date.
         * @param {string} [declarationDateLt] Range by declaration_date.
         * @param {string} [payDateGte] Range by pay_date.
         * @param {string} [payDateGt] Range by pay_date.
         * @param {string} [payDateLte] Range by pay_date.
         * @param {string} [payDateLt] Range by pay_date.
         * @param {number} [cashAmountGte] Range by cash_amount.
         * @param {number} [cashAmountGt] Range by cash_amount.
         * @param {number} [cashAmountLte] Range by cash_amount.
         * @param {number} [cashAmountLt] Range by cash_amount.
         * @param {ListDividendsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListDividendsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDividends(ticker?: string, exDividendDate?: string, recordDate?: string, declarationDate?: string, payDate?: string, frequency?: ListDividendsFrequencyEnum, cashAmount?: number, dividendType?: ListDividendsDividendTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, exDividendDateGte?: string, exDividendDateGt?: string, exDividendDateLte?: string, exDividendDateLt?: string, recordDateGte?: string, recordDateGt?: string, recordDateLte?: string, recordDateLt?: string, declarationDateGte?: string, declarationDateGt?: string, declarationDateLte?: string, declarationDateLt?: string, payDateGte?: string, payDateGt?: string, payDateLte?: string, payDateLt?: string, cashAmountGte?: number, cashAmountGt?: number, cashAmountLte?: number, cashAmountLt?: number, order?: ListDividendsOrderEnum, limit?: number, sort?: ListDividendsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListDividends200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDividends(ticker, exDividendDate, recordDate, declarationDate, payDate, frequency, cashAmount, dividendType, tickerGte, tickerGt, tickerLte, tickerLt, exDividendDateGte, exDividendDateGt, exDividendDateLte, exDividendDateLt, recordDateGte, recordDateGt, recordDateLte, recordDateLt, declarationDateGte, declarationDateGt, declarationDateLte, declarationDateLt, payDateGte, payDateGt, payDateLte, payDateLt, cashAmountGte, cashAmountGt, cashAmountLte, cashAmountLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listDividends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all exchanges that Polygon.io knows about.
         * @summary Exchanges
         * @param {ListExchangesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListExchangesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExchanges(assetClass?: ListExchangesAssetClassEnum, locale?: ListExchangesLocaleEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListExchanges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExchanges(assetClass, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listExchanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
         * @summary Stock Financials vX
         * @param {string} [ticker] Query by company ticker.
         * @param {string} [cik] Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number
         * @param {string} [companyName] Query by company name.
         * @param {string} [sic] Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;)
         * @param {string} [filingDate] Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01
         * @param {string} [periodOfReportDate] The period of report for the filing with financials data in YYYY-MM-DD format.
         * @param {ListFinancialsTimeframeEnum} [timeframe] Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
         * @param {boolean} [includeSources] Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default.
         * @param {string} [companyNameSearch] Search by company_name.
         * @param {string} [filingDateGte] Search by filing_date.
         * @param {string} [filingDateGt] Search by filing_date.
         * @param {string} [filingDateLte] Search by filing_date.
         * @param {string} [filingDateLt] Search by filing_date.
         * @param {string} [periodOfReportDateGte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateGt] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLt] Search by period_of_report_date.
         * @param {ListFinancialsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 100.
         * @param {ListFinancialsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFinancials(ticker?: string, cik?: string, companyName?: string, sic?: string, filingDate?: string, periodOfReportDate?: string, timeframe?: ListFinancialsTimeframeEnum, includeSources?: boolean, companyNameSearch?: string, filingDateGte?: string, filingDateGt?: string, filingDateLte?: string, filingDateLt?: string, periodOfReportDateGte?: string, periodOfReportDateGt?: string, periodOfReportDateLte?: string, periodOfReportDateLt?: string, order?: ListFinancialsOrderEnum, limit?: number, sort?: ListFinancialsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListFinancials200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFinancials(ticker, cik, companyName, sic, filingDate, periodOfReportDate, timeframe, includeSources, companyNameSearch, filingDateGte, filingDateGt, filingDateLte, filingDateLt, periodOfReportDateGte, periodOfReportDateGt, periodOfReportDateLte, periodOfReportDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listFinancials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
         * @summary IPOs
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc.
         * @param {string} [usCode] Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
         * @param {string} [isin] Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
         * @param {string} [listingDate] Specify a listing date. This is the first trading date for the newly listed entity.
         * @param {ListIPOsIpoStatusEnum} [ipoStatus] Specify an IPO status.
         * @param {string} [listingDateGte] Range by listing_date.
         * @param {string} [listingDateGt] Range by listing_date.
         * @param {string} [listingDateLte] Range by listing_date.
         * @param {string} [listingDateLt] Range by listing_date.
         * @param {ListIPOsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListIPOsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIPOs(ticker?: string, usCode?: string, isin?: string, listingDate?: string, ipoStatus?: ListIPOsIpoStatusEnum, listingDateGte?: string, listingDateGt?: string, listingDateLte?: string, listingDateLt?: string, order?: ListIPOsOrderEnum, limit?: number, sort?: ListIPOsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListIPOs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIPOs(ticker, usCode, isin, listingDate, ipoStatus, listingDateGte, listingDateGt, listingDateLte, listingDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listIPOs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
         * @summary Ticker News
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtc] Return results published on, before, or after this date.
         * @param {string} [tickerGte] Search by ticker.
         * @param {string} [tickerGt] Search by ticker.
         * @param {string} [tickerLte] Search by ticker.
         * @param {string} [tickerLt] Search by ticker.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGt] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLt] Search by published_utc.
         * @param {ListNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListNewsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNews(ticker?: string, publishedUtc?: ListNewsPublishedUtcParameter, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, publishedUtcGte?: ListNewsPublishedUtcParameter, publishedUtcGt?: ListNewsPublishedUtcParameter, publishedUtcLte?: ListNewsPublishedUtcParameter, publishedUtcLt?: ListNewsPublishedUtcParameter, order?: ListNewsOrderEnum, limit?: number, sort?: ListNewsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListNews200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNews(ticker, publishedUtc, tickerGte, tickerGt, tickerLte, tickerLt, publishedUtcGte, publishedUtcGt, publishedUtcLte, publishedUtcLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query for historical options contracts. This provides both active and expired options contracts.
         * @summary Options Contracts
         * @param {string} [underlyingTicker] Query for contracts relating to an underlying stock ticker.
         * @param {string} [ticker] This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://polygon.io/docs/options/get_v3_reference_options_contracts__options_ticker).
         * @param {ListOptionsContractsContractTypeEnum} [contractType] Query by the type of contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {string} [asOf] Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {boolean} [expired] Query for expired contracts. Default is false.
         * @param {string} [underlyingTickerGte] Range by underlying_ticker.
         * @param {string} [underlyingTickerGt] Range by underlying_ticker.
         * @param {string} [underlyingTickerLte] Range by underlying_ticker.
         * @param {string} [underlyingTickerLt] Range by underlying_ticker.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {ListOptionsContractsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListOptionsContractsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOptionsContracts(underlyingTicker?: string, ticker?: string, contractType?: ListOptionsContractsContractTypeEnum, expirationDate?: string, asOf?: string, strikePrice?: number, expired?: boolean, underlyingTickerGte?: string, underlyingTickerGt?: string, underlyingTickerLte?: string, underlyingTickerLt?: string, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, order?: ListOptionsContractsOrderEnum, limit?: number, sort?: ListOptionsContractsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListOptionsContracts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOptionsContracts(underlyingTicker, ticker, contractType, expirationDate, asOf, strikePrice, expired, underlyingTickerGte, underlyingTickerGt, underlyingTickerLte, underlyingTickerLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listOptionsContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
         * @summary Stock Splits v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [executionDate] Query by execution date with the format YYYY-MM-DD.
         * @param {boolean | null} [reverseSplit] Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [executionDateGte] Range by execution_date.
         * @param {string} [executionDateGt] Range by execution_date.
         * @param {string} [executionDateLte] Range by execution_date.
         * @param {string} [executionDateLt] Range by execution_date.
         * @param {ListStockSplitsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListStockSplitsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStockSplits(ticker?: string, executionDate?: string, reverseSplit?: boolean | null, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, executionDateGte?: string, executionDateGt?: string, executionDateLte?: string, executionDateLt?: string, order?: ListStockSplitsOrderEnum, limit?: number, sort?: ListStockSplitsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListStockSplits200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStockSplits(ticker, executionDate, reverseSplit, tickerGte, tickerGt, tickerLte, tickerLt, executionDateGte, executionDateGt, executionDateLte, executionDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listStockSplits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all ticker types that Polygon.io has.
         * @summary Ticker Types
         * @param {ListTickerTypesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListTickerTypesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTickerTypes(assetClass?: ListTickerTypesAssetClassEnum, locale?: ListTickerTypesLocaleEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListTickerTypes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTickerTypes(assetClass, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listTickerTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
         * @summary Tickers
         * @param {string} [ticker] Specify a ticker symbol. Defaults to empty string which queries all tickers.
         * @param {ListTickersTypeEnum} [type] Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types). Defaults to empty string which queries all types.
         * @param {ListTickersMarketEnum} [market] Filter by market type. By default all markets are included.
         * @param {string} [exchange] Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes [at the ISO org website](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges.
         * @param {string} [cusip] Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
         * @param {string} [cik] Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs.
         * @param {string} [date] Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.
         * @param {string} [search] Search for terms within the ticker and/or company name.
         * @param {boolean} [active] Specify if the tickers returned should be actively traded on the queried date. Default is true.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {ListTickersOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 1000.
         * @param {ListTickersSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTickers(ticker?: string, type?: ListTickersTypeEnum, market?: ListTickersMarketEnum, exchange?: string, cusip?: string, cik?: string, date?: string, search?: string, active?: boolean, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: ListTickersOrderEnum, limit?: number, sort?: ListTickersSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListTickers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTickers(ticker, type, market, exchange, cusip, cik, date, search, active, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listTickers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker Full Book (L2)
         * @param {string} ticker The cryptocurrency ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetCryptoSnapshotTickerBook(ticker: string, options?: RawAxiosRequestConfig): Promise<DeprecatedGetCryptoSnapshotTickerBook200Response> {
            return localVarFp.deprecatedGetCryptoSnapshotTickerBook(ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get historic trade ticks for a cryptocurrency pair. 
         * @summary Historic Crypto Trades
         * @param {string} from The \&quot;from\&quot; symbol of the crypto pair.
         * @param {string} to The \&quot;to\&quot; symbol of the crypto pair.
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricCryptoTrades(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<DeprecatedGetHistoricCryptoTrades200Response> {
            return localVarFp.deprecatedGetHistoricCryptoTrades(from, to, date, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get historic ticks for a forex currency pair. 
         * @summary Historic Forex Ticks
         * @param {string} from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
         * @param {string} to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricForexQuotes(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<DeprecatedGetHistoricForexQuotes200Response> {
            return localVarFp.deprecatedGetHistoricForexQuotes(from, to, date, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get NBBO quotes for a given ticker symbol on a specified date. 
         * @summary Quotes (NBBO)
         * @param {string} ticker The ticker symbol we want quotes for.
         * @param {string} date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricStocksQuotes(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig): Promise<DeprecatedGetHistoricStocksQuotes200Response> {
            return localVarFp.deprecatedGetHistoricStocksQuotes(ticker, date, timestamp, timestampLimit, reverse, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a given ticker symbol on a specified date. 
         * @summary Trades
         * @param {string} ticker The ticker symbol we want trades for.
         * @param {string} date The date/day of the trades to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricStocksTrades(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig): Promise<DeprecatedGetHistoricStocksTrades200Response> {
            return localVarFp.deprecatedGetHistoricStocksTrades(ticker, date, timestamp, timestampLimit, reverse, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [firm] The name of the research firm or investment bank issuing the rating.
         * @param {string} [firmAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [firmGt] Filter greater than the value.
         * @param {string} [firmGte] Filter greater than or equal to the value.
         * @param {string} [firmLt] Filter less than the value.
         * @param {string} [firmLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The identifer used by Benzinga for the firm record.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaRatingId] The identifier used by Benzinga for the rating record.
         * @param {string} [benzingaRatingIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaRatingIdGt] Filter greater than the value.
         * @param {string} [benzingaRatingIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaRatingIdLt] Filter less than the value.
         * @param {string} [benzingaRatingIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1AnalystInsights(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, firm?: string, firmAnyOf?: string, firmGt?: string, firmGte?: string, firmLt?: string, firmLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, benzingaRatingId?: string, benzingaRatingIdAnyOf?: string, benzingaRatingIdGt?: string, benzingaRatingIdGte?: string, benzingaRatingIdLt?: string, benzingaRatingIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1AnalystInsights200Response> {
            return localVarFp.getBenzingaV1AnalystInsights(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, firm, firmAnyOf, firmGt, firmGte, firmLt, firmLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, benzingaRatingId, benzingaRatingIdAnyOf, benzingaRatingIdGt, benzingaRatingIdGte, benzingaRatingIdLt, benzingaRatingIdLte, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [benzingaId] The identifier used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The unique identifier assigned by Benzinga to the research firm or investment bank.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {string} [firmName] The name of the research firm or investment bank issuing the ratings.
         * @param {string} [firmNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [firmNameGt] Filter greater than the value.
         * @param {string} [firmNameGte] Filter greater than or equal to the value.
         * @param {string} [firmNameLt] Filter less than the value.
         * @param {string} [firmNameLte] Filter less than or equal to the value.
         * @param {string} [fullName] The full name of the analyst associated with the ratings.
         * @param {string} [fullNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fullNameGt] Filter greater than the value.
         * @param {string} [fullNameGte] Filter greater than or equal to the value.
         * @param {string} [fullNameLt] Filter less than the value.
         * @param {string} [fullNameLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;full_name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Analysts(benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, firmName?: string, firmNameAnyOf?: string, firmNameGt?: string, firmNameGte?: string, firmNameLt?: string, firmNameLte?: string, fullName?: string, fullNameAnyOf?: string, fullNameGt?: string, fullNameGte?: string, fullNameLt?: string, fullNameLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1Analysts200Response> {
            return localVarFp.getBenzingaV1Analysts(benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, firmName, firmNameAnyOf, firmNameGt, firmNameGte, firmNameLt, firmNameLte, fullName, fullNameAnyOf, fullNameGt, fullNameGte, fullNameLt, fullNameLte, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ticker The requested ticker.
         * @param {string} [date] Filter equal to the value.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1ConsensusRatings(ticker: string, date?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1ConsensusRatings200Response> {
            return localVarFp.getBenzingaV1ConsensusRatings(ticker, date, dateGt, dateGte, dateLt, dateLte, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company reporting earnings.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [dateStatus] Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
         * @param {string} [dateStatusAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateStatusGt] Filter greater than the value.
         * @param {string} [dateStatusGte] Filter greater than or equal to the value.
         * @param {string} [dateStatusLt] Filter less than the value.
         * @param {string} [dateStatusLte] Filter less than or equal to the value.
         * @param {number} [epsSurprisePercent] The percentage difference between the actual and estimated EPS. Value must be a floating point number.
         * @param {string} [epsSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [epsSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercent] The percentage difference between the actual and estimated revenue. Value must be a floating point number.
         * @param {string} [revenueSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalYear] The fiscal year in which the earnings period falls. Value must be an integer.
         * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [fiscalPeriod] The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
         * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fiscalPeriodGt] Filter greater than the value.
         * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
         * @param {string} [fiscalPeriodLt] Filter less than the value.
         * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Earnings(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, dateStatus?: string, dateStatusAnyOf?: string, dateStatusGt?: string, dateStatusGte?: string, dateStatusLt?: string, dateStatusLte?: string, epsSurprisePercent?: number, epsSurprisePercentAnyOf?: string, epsSurprisePercentGt?: number, epsSurprisePercentGte?: number, epsSurprisePercentLt?: number, epsSurprisePercentLte?: number, revenueSurprisePercent?: number, revenueSurprisePercentAnyOf?: string, revenueSurprisePercentGt?: number, revenueSurprisePercentGte?: number, revenueSurprisePercentLt?: number, revenueSurprisePercentLte?: number, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1Earnings200Response> {
            return localVarFp.getBenzingaV1Earnings(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, importance, importanceAnyOf, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, dateStatus, dateStatusAnyOf, dateStatusGt, dateStatusGte, dateStatusLt, dateStatusLte, epsSurprisePercent, epsSurprisePercentAnyOf, epsSurprisePercentGt, epsSurprisePercentGte, epsSurprisePercentLt, epsSurprisePercentLte, revenueSurprisePercent, revenueSurprisePercentAnyOf, revenueSurprisePercentGt, revenueSurprisePercentGte, revenueSurprisePercentLt, revenueSurprisePercentLte, fiscalYear, fiscalYearAnyOf, fiscalYearGt, fiscalYearGte, fiscalYearLt, fiscalYearLte, fiscalPeriod, fiscalPeriodAnyOf, fiscalPeriodGt, fiscalPeriodGte, fiscalPeriodLt, fiscalPeriodLte, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [benzingaId] The identifer used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Firms(benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1Firms200Response> {
            return localVarFp.getBenzingaV1Firms(benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company issuing guidance.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [positioning] Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are \&#39;primary\&#39; (the emphasized figure) and \&#39;secondary\&#39; (a supporting or alternate figure)
         * @param {string} [positioningAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [positioningGt] Filter greater than the value.
         * @param {string} [positioningGte] Filter greater than or equal to the value.
         * @param {string} [positioningLt] Filter less than the value.
         * @param {string} [positioningLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {number} [fiscalYear] The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer.
         * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [fiscalPeriod] The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
         * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fiscalPeriodGt] Filter greater than the value.
         * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
         * @param {string} [fiscalPeriodLt] Filter less than the value.
         * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Guidance(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, positioning?: string, positioningAnyOf?: string, positioningGt?: string, positioningGte?: string, positioningLt?: string, positioningLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1Guidance200Response> {
            return localVarFp.getBenzingaV1Guidance(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, positioning, positioningAnyOf, positioningGt, positioningGte, positioningLt, positioningLte, importance, importanceAnyOf, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, fiscalYear, fiscalYearAnyOf, fiscalYearGt, fiscalYearGte, fiscalYearLt, fiscalYearLte, fiscalPeriod, fiscalPeriodAnyOf, fiscalPeriodGt, fiscalPeriodGte, fiscalPeriodLt, fiscalPeriodLte, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [published] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
         * @param {string} [publishedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [publishedGt] Filter greater than the value.
         * @param {string} [publishedGte] Filter greater than or equal to the value.
         * @param {string} [publishedLt] Filter less than the value.
         * @param {string} [publishedLte] Filter less than or equal to the value.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channels] Filter for arrays that contain the value.
         * @param {string} [channelsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channelsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tags] Filter for arrays that contain the value.
         * @param {string} [tagsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tagsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [author] The name of the journalist or entity that authored the news article.
         * @param {string} [authorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [authorGt] Filter greater than the value.
         * @param {string} [authorGte] Filter greater than or equal to the value.
         * @param {string} [authorLt] Filter less than the value.
         * @param {string} [authorLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;published\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1News(published?: string, publishedAnyOf?: string, publishedGt?: string, publishedGte?: string, publishedLt?: string, publishedLte?: string, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, channels?: string, channelsAllOf?: string, channelsAnyOf?: string, tags?: string, tagsAllOf?: string, tagsAnyOf?: string, author?: string, authorAnyOf?: string, authorGt?: string, authorGte?: string, authorLt?: string, authorLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1News200Response> {
            return localVarFp.getBenzingaV1News(published, publishedAnyOf, publishedGt, publishedGte, publishedLt, publishedLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, tickers, tickersAllOf, tickersAnyOf, channels, channelsAllOf, channelsAnyOf, tags, tagsAllOf, tagsAnyOf, author, authorAnyOf, authorGt, authorGte, authorLt, authorLte, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
         * @param {string} [ratingActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [ratingActionGt] Filter greater than the value.
         * @param {string} [ratingActionGte] Filter greater than or equal to the value.
         * @param {string} [ratingActionLt] Filter less than the value.
         * @param {string} [ratingActionLte] Filter less than or equal to the value.
         * @param {string} [priceTargetAction] The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
         * @param {string} [priceTargetActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [priceTargetActionGt] Filter greater than the value.
         * @param {string} [priceTargetActionGte] Filter greater than or equal to the value.
         * @param {string} [priceTargetActionLt] Filter less than the value.
         * @param {string} [priceTargetActionLte] Filter less than or equal to the value.
         * @param {string} [benzingaId] The identifer used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaAnalystId] Filter equal to the value.
         * @param {string} [benzingaAnalystIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaAnalystIdGt] Filter greater than the value.
         * @param {string} [benzingaAnalystIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaAnalystIdLt] Filter less than the value.
         * @param {string} [benzingaAnalystIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] Filter equal to the value.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Ratings(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, ratingAction?: string, ratingActionAnyOf?: string, ratingActionGt?: string, ratingActionGte?: string, ratingActionLt?: string, ratingActionLte?: string, priceTargetAction?: string, priceTargetActionAnyOf?: string, priceTargetActionGt?: string, priceTargetActionGte?: string, priceTargetActionLt?: string, priceTargetActionLte?: string, benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaAnalystId?: string, benzingaAnalystIdAnyOf?: string, benzingaAnalystIdGt?: string, benzingaAnalystIdGte?: string, benzingaAnalystIdLt?: string, benzingaAnalystIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1Ratings200Response> {
            return localVarFp.getBenzingaV1Ratings(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, importance, importanceAnyOf, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, ratingAction, ratingActionAnyOf, ratingActionGt, ratingActionGte, ratingActionLt, ratingActionLte, priceTargetAction, priceTargetActionAnyOf, priceTargetActionGt, priceTargetActionGte, priceTargetActionLt, priceTargetActionLte, benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, benzingaAnalystId, benzingaAnalystIdAnyOf, benzingaAnalystIdGt, benzingaAnalystIdGte, benzingaAnalystIdLt, benzingaAnalystIdLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetCryptoAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetCryptoAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoAggregates(cryptoTicker: string, multiplier: number, timespan: GetCryptoAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetCryptoAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<GetCryptoAggregates200Response> {
            return localVarFp.getCryptoAggregates(cryptoTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoEMA(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoEMATimespanEnum, window?: number, seriesType?: GetCryptoEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoEMA200Response> {
            return localVarFp.getCryptoEMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} cryptoTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetCryptoMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate MACD data. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoMACD(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoMACDTimespanEnum, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetCryptoMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoMACD200Response> {
            return localVarFp.getCryptoMACD(cryptoTicker, timestamp, timespan, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close prices of a cryptocurrency symbol on a certain day. 
         * @summary Daily Open/Close
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoOpenClose(from: string, to: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<GetCryptoOpenClose200Response> {
            return localVarFp.getCryptoOpenClose(from, to, date, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoRSI(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoRSITimespanEnum, window?: number, seriesType?: GetCryptoRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoRSI200Response> {
            return localVarFp.getCryptoRSI(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSMA(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoSMATimespanEnum, window?: number, seriesType?: GetCryptoSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoSMA200Response> {
            return localVarFp.getCryptoSMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetCryptoSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotDirection(direction: GetCryptoSnapshotDirectionDirectionEnum, options?: RawAxiosRequestConfig): Promise<GetCryptoSnapshotDirection200Response> {
            return localVarFp.getCryptoSnapshotDirection(direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker Ticker of the snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotTicker(ticker: string, options?: RawAxiosRequestConfig): Promise<GetCryptoSnapshotTicker200Response> {
            return localVarFp.getCryptoSnapshotTicker(ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotTickers(tickers?: Array<string>, options?: RawAxiosRequestConfig): Promise<GetCryptoSnapshotTickers200Response> {
            return localVarFp.getCryptoSnapshotTickers(tickers, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a crypto ticker symbol in a given time range.
         * @summary Trades
         * @param {string} cryptoTicker The ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetCryptoTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetCryptoTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoTrades(cryptoTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetCryptoTradesOrderEnum, limit?: number, sort?: GetCryptoTradesSortEnum, options?: RawAxiosRequestConfig): Promise<GetCryptoTrades200Response> {
            return localVarFp.getCryptoTrades(cryptoTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
         * @summary Real-time Currency Conversion
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {number} [amount] The amount to convert, with a decimal.
         * @param {GetCurrencyConversionPrecisionEnum} [precision] The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyConversion(from: string, to: string, amount?: number, precision?: GetCurrencyConversionPrecisionEnum, options?: RawAxiosRequestConfig): Promise<GetCurrencyConversion200Response> {
            return localVarFp.getCurrencyConversion(from, to, amount, precision, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
         * @summary Ticker Events
         * @param {string} id Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the  [Ticker Details Endpoint](https://polygon.io/docs/stocks/get_v3_reference_tickers__ticker)
         * @param {string} [types] A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(id: string, types?: string, options?: RawAxiosRequestConfig): Promise<GetEvents200Response> {
            return localVarFp.getEvents(id, types, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [date] Calendar date of the yield observation (YYYYMMDD).
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFedV1TreasuryYields(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<GetFedV1TreasuryYields200Response> {
            return localVarFp.getFedV1TreasuryYields(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetForexAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetForexAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexAggregates(forexTicker: string, multiplier: number, timespan: GetForexAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetForexAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<GetCryptoAggregates200Response> {
            return localVarFp.getForexAggregates(forexTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetForexEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexEMA(fxTicker: string, timestamp?: string, timespan?: GetForexEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoEMA200Response> {
            return localVarFp.getForexEMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} fxTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetForexMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexMACD(fxTicker: string, timestamp?: string, timespan?: GetForexMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetForexMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoMACD200Response> {
            return localVarFp.getForexMACD(fxTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get BBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (BBO)
         * @param {string} fxTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetForexQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetForexQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexQuotes(fxTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetForexQuotesOrderEnum, limit?: number, sort?: GetForexQuotesSortEnum, options?: RawAxiosRequestConfig): Promise<GetForexQuotes200Response> {
            return localVarFp.getForexQuotes(fxTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} fxTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetForexRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexRSI(fxTicker: string, timestamp?: string, timespan?: GetForexRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoRSI200Response> {
            return localVarFp.getForexRSI(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} fxTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetForexSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSMA(fxTicker: string, timestamp?: string, timespan?: GetForexSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoSMA200Response> {
            return localVarFp.getForexSMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetForexSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotDirection(direction: GetForexSnapshotDirectionDirectionEnum, options?: RawAxiosRequestConfig): Promise<GetForexSnapshotTickers200Response> {
            return localVarFp.getForexSnapshotDirection(direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker The forex ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotTicker(ticker: string, options?: RawAxiosRequestConfig): Promise<GetForexSnapshotTicker200Response> {
            return localVarFp.getForexSnapshotTicker(ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotTickers(tickers?: Array<string>, options?: RawAxiosRequestConfig): Promise<GetForexSnapshotTickers200Response> {
            return localVarFp.getForexSnapshotTickers(tickers, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedCryptoAggregates(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<GetGroupedCryptoAggregates200Response> {
            return localVarFp.getGroupedCryptoAggregates(date, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedForexAggregates(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<GetGroupedCryptoAggregates200Response> {
            return localVarFp.getGroupedForexAggregates(date, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedStocksAggregates(date: string, adjusted?: boolean, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<GetGroupedStocksAggregates200Response> {
            return localVarFp.getGroupedStocksAggregates(date, adjusted, includeOtc, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetIndicesAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesAggregates(indicesTicker: string, multiplier: number, timespan: GetIndicesAggregatesTimespanEnum, from: string, to: string, sort?: GetIndicesAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<GetPreviousIndicesAggregates200Response> {
            return localVarFp.getIndicesAggregates(indicesTicker, multiplier, timespan, from, to, sort, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetIndicesEMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesEMA(indicesTicker: string, timestamp?: string, timespan?: GetIndicesEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoEMA200Response> {
            return localVarFp.getIndicesEMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} indicesTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetIndicesMACDSeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close values to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesMACD(indicesTicker: string, timestamp?: string, timespan?: GetIndicesMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetIndicesMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoMACD200Response> {
            return localVarFp.getIndicesMACD(indicesTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close and afterhours values of a index symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesOpenClose(indicesTicker: string, date: string, options?: RawAxiosRequestConfig): Promise<GetIndicesOpenClose200Response> {
            return localVarFp.getIndicesOpenClose(indicesTicker, date, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetIndicesRSISeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close values to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesRSI(indicesTicker: string, timestamp?: string, timespan?: GetIndicesRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoRSI200Response> {
            return localVarFp.getIndicesRSI(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetIndicesSMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesSMA(indicesTicker: string, timestamp?: string, timespan?: GetIndicesSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoSMA200Response> {
            return localVarFp.getIndicesSMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Snapshot of indices data for said tickers
         * @summary Indices Snapshot
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {GetIndicesSnapshotOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetIndicesSnapshotSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesSnapshot(tickerAnyOf?: string, ticker?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: GetIndicesSnapshotOrderEnum, limit?: number, sort?: GetIndicesSnapshotSortEnum, options?: RawAxiosRequestConfig): Promise<GetIndicesSnapshot200Response> {
            return localVarFp.getIndicesSnapshot(tickerAnyOf, ticker, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the last trade tick for a cryptocurrency pair.
         * @summary Last Trade for a Crypto Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCryptoTrade(from: string, to: string, options?: RawAxiosRequestConfig): Promise<GetLastCryptoTrade200Response> {
            return localVarFp.getLastCryptoTrade(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the last quote tick for a forex currency pair.
         * @summary Last Quote for a Currency Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCurrencyQuote(from: string, to: string, options?: RawAxiosRequestConfig): Promise<GetLastCurrencyQuote200Response> {
            return localVarFp.getLastCurrencyQuote(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent trade for a given options contract.
         * @summary Last Trade
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastOptionsTrade(optionsTicker: string, options?: RawAxiosRequestConfig): Promise<GetLastOptionsTrade200Response> {
            return localVarFp.getLastOptionsTrade(optionsTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent NBBO (Quote) tick for a given stock.
         * @summary Last Quote
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastStocksQuote(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<GetLastStocksQuote200Response> {
            return localVarFp.getLastStocksQuote(stocksTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent trade for a given stock.
         * @summary Last Trade
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastStocksTrade(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<GetLastOptionsTrade200Response> {
            return localVarFp.getLastStocksTrade(stocksTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get upcoming market holidays and their open/close times.
         * @summary Market Holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketHolidays(options?: RawAxiosRequestConfig): Promise<Array<GetMarketHolidays200ResponseInner>> {
            return localVarFp.getMarketHolidays(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current trading status of the exchanges and overall financial markets.
         * @summary Market Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketStatus(options?: RawAxiosRequestConfig): Promise<GetMarketStatus200Response> {
            return localVarFp.getMarketStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the snapshot of an option contract for a stock equity.
         * @summary Option Contract
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {string} optionContract The option contract identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionContract(underlyingAsset: string, optionContract: string, options?: RawAxiosRequestConfig): Promise<GetOptionContract200Response> {
            return localVarFp.getOptionContract(underlyingAsset, optionContract, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetOptionsAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetOptionsAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsAggregates(optionsTicker: string, multiplier: number, timespan: GetOptionsAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetOptionsAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<GetCryptoAggregates200Response> {
            return localVarFp.getOptionsAggregates(optionsTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the snapshot of all options contracts for an underlying ticker.
         * @summary Options Chain
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {GetOptionsChainContractTypeEnum} [contractType] Query by the type of contract.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {GetOptionsChainOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetOptionsChainSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsChain(underlyingAsset: string, strikePrice?: number, expirationDate?: string, contractType?: GetOptionsChainContractTypeEnum, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, order?: GetOptionsChainOrderEnum, limit?: number, sort?: GetOptionsChainSortEnum, options?: RawAxiosRequestConfig): Promise<GetOptionsChain200Response> {
            return localVarFp.getOptionsChain(underlyingAsset, strikePrice, expirationDate, contractType, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an options contract
         * @summary Options Contract
         * @param {string} optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://polygon.io/blog/how-to-read-a-stock-options-ticker/).
         * @param {string} [asOf] Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsContract(optionsTicker: string, asOf?: string, options?: RawAxiosRequestConfig): Promise<GetOptionsContract200Response> {
            return localVarFp.getOptionsContract(optionsTicker, asOf, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetOptionsEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsEMA(optionsTicker: string, timestamp?: string, timespan?: GetOptionsEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoEMA200Response> {
            return localVarFp.getOptionsEMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} optionsTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetOptionsMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsMACD(optionsTicker: string, timestamp?: string, timespan?: GetOptionsMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetOptionsMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoMACD200Response> {
            return localVarFp.getOptionsMACD(optionsTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close and afterhours prices of an options contract on a certain date. 
         * @summary Daily Open/Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsOpenClose(optionsTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<GetOptionsOpenClose200Response> {
            return localVarFp.getOptionsOpenClose(optionsTicker, date, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get quotes for an options ticker symbol in a given time range.
         * @summary Quotes
         * @param {string} optionsTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetOptionsQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetOptionsQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsQuotes(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsQuotesOrderEnum, limit?: number, sort?: GetOptionsQuotesSortEnum, options?: RawAxiosRequestConfig): Promise<GetOptionsQuotes200Response> {
            return localVarFp.getOptionsQuotes(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetOptionsRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsRSI(optionsTicker: string, timestamp?: string, timespan?: GetOptionsRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoRSI200Response> {
            return localVarFp.getOptionsRSI(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetOptionsSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsSMA(optionsTicker: string, timestamp?: string, timespan?: GetOptionsSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoSMA200Response> {
            return localVarFp.getOptionsSMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for an options ticker symbol in a given time range.
         * @summary Trades
         * @param {string} optionsTicker The options ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetOptionsTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetOptionsTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsTrades(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsTradesOrderEnum, limit?: number, sort?: GetOptionsTradesSortEnum, options?: RawAxiosRequestConfig): Promise<GetOptionsTrades200Response> {
            return localVarFp.getOptionsTrades(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
         * @summary Previous Close
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousCryptoAggregates(cryptoTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<GetPreviousCryptoAggregates200Response> {
            return localVarFp.getPreviousCryptoAggregates(cryptoTicker, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
         * @summary Previous Close
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousForexAggregates(forexTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<GetPreviousForexAggregates200Response> {
            return localVarFp.getPreviousForexAggregates(forexTicker, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
         * @summary Previous Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousIndicesAggregates(indicesTicker: string, options?: RawAxiosRequestConfig): Promise<GetPreviousIndicesAggregates200Response> {
            return localVarFp.getPreviousIndicesAggregates(indicesTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
         * @summary Previous Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousOptionsAggregates(optionsTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<GetCryptoAggregates200Response> {
            return localVarFp.getPreviousOptionsAggregates(optionsTicker, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
         * @summary Previous Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousStocksAggregates(stocksTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<GetCryptoAggregates200Response> {
            return localVarFp.getPreviousStocksAggregates(stocksTicker, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of tickers related to the queried ticker based on News and Returns data.
         * @summary Related Companies
         * @param {string} ticker The ticker symbol to search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedCompanies(ticker: string, options?: RawAxiosRequestConfig): Promise<GetRelatedCompanies200Response> {
            return localVarFp.getRelatedCompanies(ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
         * @summary Summaries
         * @param {string} [tickerAnyOf] Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://polygon.io/docs/stocks/get_v3_reference_tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotSummary(tickerAnyOf?: string, options?: RawAxiosRequestConfig): Promise<GetSnapshotSummary200Response> {
            return localVarFp.getSnapshotSummary(tickerAnyOf, options).then((request) => request(axios, basePath));
        },
        /**
         * Get snapshots for assets of all types
         * @summary Universal Snapshot
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {GetSnapshotsTypeEnum} [type] Query by the type of asset.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. 
         * @param {GetSnapshotsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetSnapshotsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots(ticker?: string, type?: GetSnapshotsTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, tickerAnyOf?: string, order?: GetSnapshotsOrderEnum, limit?: number, sort?: GetSnapshotsSortEnum, options?: RawAxiosRequestConfig): Promise<GetSnapshots200Response> {
            return localVarFp.getSnapshots(ticker, type, tickerGte, tickerGt, tickerLte, tickerLt, tickerAnyOf, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetStocksAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetStocksAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksAggregates(stocksTicker: string, multiplier: number, timespan: GetStocksAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetStocksAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<GetStocksAggregates200Response> {
            return localVarFp.getStocksAggregates(stocksTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetStocksEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksEMA(stockTicker: string, timestamp?: string, timespan?: GetStocksEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoEMA200Response> {
            return localVarFp.getStocksEMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetStocksMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksMACD(stockTicker: string, timestamp?: string, timespan?: GetStocksMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetStocksMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoMACD200Response> {
            return localVarFp.getStocksMACD(stockTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close and afterhours prices of a stock symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksOpenClose(stocksTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<GetOptionsOpenClose200Response> {
            return localVarFp.getStocksOpenClose(stocksTicker, date, adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get NBBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (NBBO)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetStocksQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetStocksQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksQuotes(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksQuotesOrderEnum, limit?: number, sort?: GetStocksQuotesSortEnum, options?: RawAxiosRequestConfig): Promise<GetStocksQuotes200Response> {
            return localVarFp.getStocksQuotes(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetStocksRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksRSI(stockTicker: string, timestamp?: string, timespan?: GetStocksRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoRSI200Response> {
            return localVarFp.getStocksRSI(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetStocksSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSMA(stockTicker: string, timestamp?: string, timespan?: GetStocksSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<GetCryptoSMA200Response> {
            return localVarFp.getStocksSMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetStocksSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotDirection(direction: GetStocksSnapshotDirectionDirectionEnum, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<GetStocksSnapshotDirection200Response> {
            return localVarFp.getStocksSnapshotDirection(direction, includeOtc, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary Ticker
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotTicker(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<GetStocksSnapshotTicker200Response> {
            return localVarFp.getStocksSnapshotTicker(stocksTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotTickers(tickers?: Array<string>, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<GetStocksSnapshotTickers200Response> {
            return localVarFp.getStocksSnapshotTickers(tickers, includeOtc, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a ticker symbol in a given time range.
         * @summary Trades
         * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetStocksTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetStocksTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksTrades(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksTradesOrderEnum, limit?: number, sort?: GetStocksTradesSortEnum, options?: RawAxiosRequestConfig): Promise<GetStocksTrades200Response> {
            return localVarFp.getStocksTrades(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [daysToCover] Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number.
         * @param {string} [daysToCoverAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [daysToCoverGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [daysToCoverGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [daysToCoverLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [daysToCoverLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [settlementDate] The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
         * @param {string} [settlementDateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [settlementDateGt] Filter greater than the value.
         * @param {string} [settlementDateGte] Filter greater than or equal to the value.
         * @param {string} [settlementDateLt] Filter less than the value.
         * @param {string} [settlementDateLte] Filter less than or equal to the value.
         * @param {number} [avgDailyVolume] The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer.
         * @param {string} [avgDailyVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [avgDailyVolumeGt] Filter greater than the value. Value must be an integer.
         * @param {number} [avgDailyVolumeGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [avgDailyVolumeLt] Filter less than the value. Value must be an integer.
         * @param {number} [avgDailyVolumeLte] Filter less than or equal to the value. Value must be an integer.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1ShortInterest(ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, daysToCover?: number, daysToCoverAnyOf?: string, daysToCoverGt?: number, daysToCoverGte?: number, daysToCoverLt?: number, daysToCoverLte?: number, settlementDate?: string, settlementDateAnyOf?: string, settlementDateGt?: string, settlementDateGte?: string, settlementDateLt?: string, settlementDateLte?: string, avgDailyVolume?: number, avgDailyVolumeAnyOf?: string, avgDailyVolumeGt?: number, avgDailyVolumeGte?: number, avgDailyVolumeLt?: number, avgDailyVolumeLte?: number, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<GetStocksV1ShortInterest200Response> {
            return localVarFp.getStocksV1ShortInterest(ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, daysToCover, daysToCoverAnyOf, daysToCoverGt, daysToCoverGte, daysToCoverLt, daysToCoverLte, settlementDate, settlementDateAnyOf, settlementDateGt, settlementDateGte, settlementDateLt, settlementDateLte, avgDailyVolume, avgDailyVolumeAnyOf, avgDailyVolumeGt, avgDailyVolumeGte, avgDailyVolumeLt, avgDailyVolumeLte, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [date] The date of trade activity reported in the format YYYY-MM-DD
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [shortVolumeRatio] The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number.
         * @param {string} [shortVolumeRatioAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [shortVolumeRatioGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [totalVolume] Total reported volume across all venues for the ticker on the given date. Value must be an integer.
         * @param {string} [totalVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [totalVolumeGt] Filter greater than the value. Value must be an integer.
         * @param {number} [totalVolumeGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [totalVolumeLt] Filter less than the value. Value must be an integer.
         * @param {number} [totalVolumeLte] Filter less than or equal to the value. Value must be an integer.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1ShortVolume(ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, shortVolumeRatio?: number, shortVolumeRatioAnyOf?: string, shortVolumeRatioGt?: number, shortVolumeRatioGte?: number, shortVolumeRatioLt?: number, shortVolumeRatioLte?: number, totalVolume?: number, totalVolumeAnyOf?: string, totalVolumeGt?: number, totalVolumeGte?: number, totalVolumeLt?: number, totalVolumeLte?: number, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<GetStocksV1ShortVolume200Response> {
            return localVarFp.getStocksV1ShortVolume(ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, shortVolumeRatio, shortVolumeRatioAnyOf, shortVolumeRatioGt, shortVolumeRatioGte, shortVolumeRatioLt, shortVolumeRatioLte, totalVolume, totalVolumeAnyOf, totalVolumeGt, totalVolumeGte, totalVolumeLt, totalVolumeLte, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
         * @summary Ticker Details v3
         * @param {string} ticker The ticker symbol of the asset.
         * @param {string} [date] Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker(ticker: string, date?: string, options?: RawAxiosRequestConfig): Promise<GetTicker200Response> {
            return localVarFp.getTicker(ticker, date, options).then((request) => request(axios, basePath));
        },
        /**
         * List all conditions that Polygon.io uses.
         * @summary Conditions
         * @param {ListConditionsAssetClassEnum} [assetClass] Filter for conditions within a given asset class.
         * @param {ListConditionsDataTypeEnum} [dataType] Filter by data type.
         * @param {number} [id] Filter for conditions with a given ID.
         * @param {ListConditionsSipEnum} [sip] Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
         * @param {ListConditionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListConditionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConditions(assetClass?: ListConditionsAssetClassEnum, dataType?: ListConditionsDataTypeEnum, id?: number, sip?: ListConditionsSipEnum, order?: ListConditionsOrderEnum, limit?: number, sort?: ListConditionsSortEnum, options?: RawAxiosRequestConfig): Promise<ListConditions200Response> {
            return localVarFp.listConditions(assetClass, dataType, id, sip, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
         * @summary Dividends v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [exDividendDate] Query by ex-dividend date with the format YYYY-MM-DD.
         * @param {string} [recordDate] Query by record date with the format YYYY-MM-DD.
         * @param {string} [declarationDate] Query by declaration date with the format YYYY-MM-DD.
         * @param {string} [payDate] Query by pay date with the format YYYY-MM-DD.
         * @param {ListDividendsFrequencyEnum} [frequency] Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
         * @param {number} [cashAmount] Query by the cash amount of the dividend.
         * @param {ListDividendsDividendTypeEnum} [dividendType] Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [exDividendDateGte] Range by ex_dividend_date.
         * @param {string} [exDividendDateGt] Range by ex_dividend_date.
         * @param {string} [exDividendDateLte] Range by ex_dividend_date.
         * @param {string} [exDividendDateLt] Range by ex_dividend_date.
         * @param {string} [recordDateGte] Range by record_date.
         * @param {string} [recordDateGt] Range by record_date.
         * @param {string} [recordDateLte] Range by record_date.
         * @param {string} [recordDateLt] Range by record_date.
         * @param {string} [declarationDateGte] Range by declaration_date.
         * @param {string} [declarationDateGt] Range by declaration_date.
         * @param {string} [declarationDateLte] Range by declaration_date.
         * @param {string} [declarationDateLt] Range by declaration_date.
         * @param {string} [payDateGte] Range by pay_date.
         * @param {string} [payDateGt] Range by pay_date.
         * @param {string} [payDateLte] Range by pay_date.
         * @param {string} [payDateLt] Range by pay_date.
         * @param {number} [cashAmountGte] Range by cash_amount.
         * @param {number} [cashAmountGt] Range by cash_amount.
         * @param {number} [cashAmountLte] Range by cash_amount.
         * @param {number} [cashAmountLt] Range by cash_amount.
         * @param {ListDividendsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListDividendsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDividends(ticker?: string, exDividendDate?: string, recordDate?: string, declarationDate?: string, payDate?: string, frequency?: ListDividendsFrequencyEnum, cashAmount?: number, dividendType?: ListDividendsDividendTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, exDividendDateGte?: string, exDividendDateGt?: string, exDividendDateLte?: string, exDividendDateLt?: string, recordDateGte?: string, recordDateGt?: string, recordDateLte?: string, recordDateLt?: string, declarationDateGte?: string, declarationDateGt?: string, declarationDateLte?: string, declarationDateLt?: string, payDateGte?: string, payDateGt?: string, payDateLte?: string, payDateLt?: string, cashAmountGte?: number, cashAmountGt?: number, cashAmountLte?: number, cashAmountLt?: number, order?: ListDividendsOrderEnum, limit?: number, sort?: ListDividendsSortEnum, options?: RawAxiosRequestConfig): Promise<ListDividends200Response> {
            return localVarFp.listDividends(ticker, exDividendDate, recordDate, declarationDate, payDate, frequency, cashAmount, dividendType, tickerGte, tickerGt, tickerLte, tickerLt, exDividendDateGte, exDividendDateGt, exDividendDateLte, exDividendDateLt, recordDateGte, recordDateGt, recordDateLte, recordDateLt, declarationDateGte, declarationDateGt, declarationDateLte, declarationDateLt, payDateGte, payDateGt, payDateLte, payDateLt, cashAmountGte, cashAmountGt, cashAmountLte, cashAmountLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * List all exchanges that Polygon.io knows about.
         * @summary Exchanges
         * @param {ListExchangesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListExchangesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExchanges(assetClass?: ListExchangesAssetClassEnum, locale?: ListExchangesLocaleEnum, options?: RawAxiosRequestConfig): Promise<ListExchanges200Response> {
            return localVarFp.listExchanges(assetClass, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
         * @summary Stock Financials vX
         * @param {string} [ticker] Query by company ticker.
         * @param {string} [cik] Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number
         * @param {string} [companyName] Query by company name.
         * @param {string} [sic] Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;)
         * @param {string} [filingDate] Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01
         * @param {string} [periodOfReportDate] The period of report for the filing with financials data in YYYY-MM-DD format.
         * @param {ListFinancialsTimeframeEnum} [timeframe] Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
         * @param {boolean} [includeSources] Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default.
         * @param {string} [companyNameSearch] Search by company_name.
         * @param {string} [filingDateGte] Search by filing_date.
         * @param {string} [filingDateGt] Search by filing_date.
         * @param {string} [filingDateLte] Search by filing_date.
         * @param {string} [filingDateLt] Search by filing_date.
         * @param {string} [periodOfReportDateGte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateGt] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLt] Search by period_of_report_date.
         * @param {ListFinancialsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 100.
         * @param {ListFinancialsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFinancials(ticker?: string, cik?: string, companyName?: string, sic?: string, filingDate?: string, periodOfReportDate?: string, timeframe?: ListFinancialsTimeframeEnum, includeSources?: boolean, companyNameSearch?: string, filingDateGte?: string, filingDateGt?: string, filingDateLte?: string, filingDateLt?: string, periodOfReportDateGte?: string, periodOfReportDateGt?: string, periodOfReportDateLte?: string, periodOfReportDateLt?: string, order?: ListFinancialsOrderEnum, limit?: number, sort?: ListFinancialsSortEnum, options?: RawAxiosRequestConfig): Promise<ListFinancials200Response> {
            return localVarFp.listFinancials(ticker, cik, companyName, sic, filingDate, periodOfReportDate, timeframe, includeSources, companyNameSearch, filingDateGte, filingDateGt, filingDateLte, filingDateLt, periodOfReportDateGte, periodOfReportDateGt, periodOfReportDateLte, periodOfReportDateLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
         * @summary IPOs
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc.
         * @param {string} [usCode] Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
         * @param {string} [isin] Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
         * @param {string} [listingDate] Specify a listing date. This is the first trading date for the newly listed entity.
         * @param {ListIPOsIpoStatusEnum} [ipoStatus] Specify an IPO status.
         * @param {string} [listingDateGte] Range by listing_date.
         * @param {string} [listingDateGt] Range by listing_date.
         * @param {string} [listingDateLte] Range by listing_date.
         * @param {string} [listingDateLt] Range by listing_date.
         * @param {ListIPOsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListIPOsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIPOs(ticker?: string, usCode?: string, isin?: string, listingDate?: string, ipoStatus?: ListIPOsIpoStatusEnum, listingDateGte?: string, listingDateGt?: string, listingDateLte?: string, listingDateLt?: string, order?: ListIPOsOrderEnum, limit?: number, sort?: ListIPOsSortEnum, options?: RawAxiosRequestConfig): Promise<ListIPOs200Response> {
            return localVarFp.listIPOs(ticker, usCode, isin, listingDate, ipoStatus, listingDateGte, listingDateGt, listingDateLte, listingDateLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
         * @summary Ticker News
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtc] Return results published on, before, or after this date.
         * @param {string} [tickerGte] Search by ticker.
         * @param {string} [tickerGt] Search by ticker.
         * @param {string} [tickerLte] Search by ticker.
         * @param {string} [tickerLt] Search by ticker.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGt] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLt] Search by published_utc.
         * @param {ListNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListNewsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNews(ticker?: string, publishedUtc?: ListNewsPublishedUtcParameter, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, publishedUtcGte?: ListNewsPublishedUtcParameter, publishedUtcGt?: ListNewsPublishedUtcParameter, publishedUtcLte?: ListNewsPublishedUtcParameter, publishedUtcLt?: ListNewsPublishedUtcParameter, order?: ListNewsOrderEnum, limit?: number, sort?: ListNewsSortEnum, options?: RawAxiosRequestConfig): Promise<ListNews200Response> {
            return localVarFp.listNews(ticker, publishedUtc, tickerGte, tickerGt, tickerLte, tickerLt, publishedUtcGte, publishedUtcGt, publishedUtcLte, publishedUtcLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Query for historical options contracts. This provides both active and expired options contracts.
         * @summary Options Contracts
         * @param {string} [underlyingTicker] Query for contracts relating to an underlying stock ticker.
         * @param {string} [ticker] This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://polygon.io/docs/options/get_v3_reference_options_contracts__options_ticker).
         * @param {ListOptionsContractsContractTypeEnum} [contractType] Query by the type of contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {string} [asOf] Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {boolean} [expired] Query for expired contracts. Default is false.
         * @param {string} [underlyingTickerGte] Range by underlying_ticker.
         * @param {string} [underlyingTickerGt] Range by underlying_ticker.
         * @param {string} [underlyingTickerLte] Range by underlying_ticker.
         * @param {string} [underlyingTickerLt] Range by underlying_ticker.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {ListOptionsContractsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListOptionsContractsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOptionsContracts(underlyingTicker?: string, ticker?: string, contractType?: ListOptionsContractsContractTypeEnum, expirationDate?: string, asOf?: string, strikePrice?: number, expired?: boolean, underlyingTickerGte?: string, underlyingTickerGt?: string, underlyingTickerLte?: string, underlyingTickerLt?: string, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, order?: ListOptionsContractsOrderEnum, limit?: number, sort?: ListOptionsContractsSortEnum, options?: RawAxiosRequestConfig): Promise<ListOptionsContracts200Response> {
            return localVarFp.listOptionsContracts(underlyingTicker, ticker, contractType, expirationDate, asOf, strikePrice, expired, underlyingTickerGte, underlyingTickerGt, underlyingTickerLte, underlyingTickerLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
         * @summary Stock Splits v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [executionDate] Query by execution date with the format YYYY-MM-DD.
         * @param {boolean | null} [reverseSplit] Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [executionDateGte] Range by execution_date.
         * @param {string} [executionDateGt] Range by execution_date.
         * @param {string} [executionDateLte] Range by execution_date.
         * @param {string} [executionDateLt] Range by execution_date.
         * @param {ListStockSplitsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListStockSplitsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStockSplits(ticker?: string, executionDate?: string, reverseSplit?: boolean | null, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, executionDateGte?: string, executionDateGt?: string, executionDateLte?: string, executionDateLt?: string, order?: ListStockSplitsOrderEnum, limit?: number, sort?: ListStockSplitsSortEnum, options?: RawAxiosRequestConfig): Promise<ListStockSplits200Response> {
            return localVarFp.listStockSplits(ticker, executionDate, reverseSplit, tickerGte, tickerGt, tickerLte, tickerLt, executionDateGte, executionDateGt, executionDateLte, executionDateLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * List all ticker types that Polygon.io has.
         * @summary Ticker Types
         * @param {ListTickerTypesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListTickerTypesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickerTypes(assetClass?: ListTickerTypesAssetClassEnum, locale?: ListTickerTypesLocaleEnum, options?: RawAxiosRequestConfig): Promise<ListTickerTypes200Response> {
            return localVarFp.listTickerTypes(assetClass, locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
         * @summary Tickers
         * @param {string} [ticker] Specify a ticker symbol. Defaults to empty string which queries all tickers.
         * @param {ListTickersTypeEnum} [type] Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types). Defaults to empty string which queries all types.
         * @param {ListTickersMarketEnum} [market] Filter by market type. By default all markets are included.
         * @param {string} [exchange] Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes [at the ISO org website](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges.
         * @param {string} [cusip] Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
         * @param {string} [cik] Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs.
         * @param {string} [date] Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.
         * @param {string} [search] Search for terms within the ticker and/or company name.
         * @param {boolean} [active] Specify if the tickers returned should be actively traded on the queried date. Default is true.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {ListTickersOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 1000.
         * @param {ListTickersSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickers(ticker?: string, type?: ListTickersTypeEnum, market?: ListTickersMarketEnum, exchange?: string, cusip?: string, cik?: string, date?: string, search?: string, active?: boolean, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: ListTickersOrderEnum, limit?: number, sort?: ListTickersSortEnum, options?: RawAxiosRequestConfig): Promise<ListTickers200Response> {
            return localVarFp.listTickers(ticker, type, market, exchange, cusip, cik, date, search, active, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Ticker Full Book (L2)
     * @param {string} ticker The cryptocurrency ticker.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedGetCryptoSnapshotTickerBook(ticker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedGetCryptoSnapshotTickerBook(ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historic trade ticks for a cryptocurrency pair. 
     * @summary Historic Crypto Trades
     * @param {string} from The \&quot;from\&quot; symbol of the crypto pair.
     * @param {string} to The \&quot;to\&quot; symbol of the crypto pair.
     * @param {string} date The date/day of the historic ticks to retrieve.
     * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param {number} [limit] Limit the size of the response, max 10000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedGetHistoricCryptoTrades(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedGetHistoricCryptoTrades(from, to, date, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historic ticks for a forex currency pair. 
     * @summary Historic Forex Ticks
     * @param {string} from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
     * @param {string} to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
     * @param {string} date The date/day of the historic ticks to retrieve.
     * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param {number} [limit] Limit the size of the response, max 10000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedGetHistoricForexQuotes(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedGetHistoricForexQuotes(from, to, date, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get NBBO quotes for a given ticker symbol on a specified date. 
     * @summary Quotes (NBBO)
     * @param {string} ticker The ticker symbol we want quotes for.
     * @param {string} date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
     * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
     * @param {boolean} [reverse] Reverse the order of the results. 
     * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedGetHistoricStocksQuotes(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedGetHistoricStocksQuotes(ticker, date, timestamp, timestampLimit, reverse, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a given ticker symbol on a specified date. 
     * @summary Trades
     * @param {string} ticker The ticker symbol we want trades for.
     * @param {string} date The date/day of the trades to retrieve in the format YYYY-MM-DD.
     * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
     * @param {boolean} [reverse] Reverse the order of the results. 
     * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedGetHistoricStocksTrades(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedGetHistoricStocksTrades(ticker, date, timestamp, timestampLimit, reverse, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
     * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [dateGt] Filter greater than the value.
     * @param {string} [dateGte] Filter greater than or equal to the value.
     * @param {string} [dateLt] Filter less than the value.
     * @param {string} [dateLte] Filter less than or equal to the value.
     * @param {string} [ticker] The stock symbol of the company being rated.
     * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [tickerGt] Filter greater than the value.
     * @param {string} [tickerGte] Filter greater than or equal to the value.
     * @param {string} [tickerLt] Filter less than the value.
     * @param {string} [tickerLte] Filter less than or equal to the value.
     * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
     * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [lastUpdatedGt] Filter greater than the value.
     * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
     * @param {string} [lastUpdatedLt] Filter less than the value.
     * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
     * @param {string} [firm] The name of the research firm or investment bank issuing the rating.
     * @param {string} [firmAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [firmGt] Filter greater than the value.
     * @param {string} [firmGte] Filter greater than or equal to the value.
     * @param {string} [firmLt] Filter less than the value.
     * @param {string} [firmLte] Filter less than or equal to the value.
     * @param {string} [benzingaFirmId] The identifer used by Benzinga for the firm record.
     * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [benzingaFirmIdGt] Filter greater than the value.
     * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
     * @param {string} [benzingaFirmIdLt] Filter less than the value.
     * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
     * @param {string} [benzingaRatingId] The identifier used by Benzinga for the rating record.
     * @param {string} [benzingaRatingIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [benzingaRatingIdGt] Filter greater than the value.
     * @param {string} [benzingaRatingIdGte] Filter greater than or equal to the value.
     * @param {string} [benzingaRatingIdLt] Filter less than the value.
     * @param {string} [benzingaRatingIdLte] Filter less than or equal to the value.
     * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1AnalystInsights(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, firm?: string, firmAnyOf?: string, firmGt?: string, firmGte?: string, firmLt?: string, firmLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, benzingaRatingId?: string, benzingaRatingIdAnyOf?: string, benzingaRatingIdGt?: string, benzingaRatingIdGte?: string, benzingaRatingIdLt?: string, benzingaRatingIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1AnalystInsights(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, firm, firmAnyOf, firmGt, firmGte, firmLt, firmLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, benzingaRatingId, benzingaRatingIdAnyOf, benzingaRatingIdGt, benzingaRatingIdGte, benzingaRatingIdLt, benzingaRatingIdLte, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [benzingaId] The identifier used by Benzinga for this record.
     * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [benzingaIdGt] Filter greater than the value.
     * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
     * @param {string} [benzingaIdLt] Filter less than the value.
     * @param {string} [benzingaIdLte] Filter less than or equal to the value.
     * @param {string} [benzingaFirmId] The unique identifier assigned by Benzinga to the research firm or investment bank.
     * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [benzingaFirmIdGt] Filter greater than the value.
     * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
     * @param {string} [benzingaFirmIdLt] Filter less than the value.
     * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
     * @param {string} [firmName] The name of the research firm or investment bank issuing the ratings.
     * @param {string} [firmNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [firmNameGt] Filter greater than the value.
     * @param {string} [firmNameGte] Filter greater than or equal to the value.
     * @param {string} [firmNameLt] Filter less than the value.
     * @param {string} [firmNameLte] Filter less than or equal to the value.
     * @param {string} [fullName] The full name of the analyst associated with the ratings.
     * @param {string} [fullNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [fullNameGt] Filter greater than the value.
     * @param {string} [fullNameGte] Filter greater than or equal to the value.
     * @param {string} [fullNameLt] Filter less than the value.
     * @param {string} [fullNameLte] Filter less than or equal to the value.
     * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;full_name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1Analysts(benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, firmName?: string, firmNameAnyOf?: string, firmNameGt?: string, firmNameGte?: string, firmNameLt?: string, firmNameLte?: string, fullName?: string, fullNameAnyOf?: string, fullNameGt?: string, fullNameGte?: string, fullNameLt?: string, fullNameLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1Analysts(benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, firmName, firmNameAnyOf, firmNameGt, firmNameGte, firmNameLt, firmNameLte, fullName, fullNameAnyOf, fullNameGt, fullNameGte, fullNameLt, fullNameLte, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ticker The requested ticker.
     * @param {string} [date] Filter equal to the value.
     * @param {string} [dateGt] Filter greater than the value.
     * @param {string} [dateGte] Filter greater than or equal to the value.
     * @param {string} [dateLt] Filter less than the value.
     * @param {string} [dateLte] Filter less than or equal to the value.
     * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1ConsensusRatings(ticker: string, date?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1ConsensusRatings(ticker, date, dateGt, dateGte, dateLt, dateLte, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
     * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [dateGt] Filter greater than the value.
     * @param {string} [dateGte] Filter greater than or equal to the value.
     * @param {string} [dateLt] Filter less than the value.
     * @param {string} [dateLte] Filter less than or equal to the value.
     * @param {string} [ticker] The stock symbol of the company reporting earnings.
     * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [tickerGt] Filter greater than the value.
     * @param {string} [tickerGte] Filter greater than or equal to the value.
     * @param {string} [tickerLt] Filter less than the value.
     * @param {string} [tickerLte] Filter less than or equal to the value.
     * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
     * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
     * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
     * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
     * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
     * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
     * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [lastUpdatedGt] Filter greater than the value.
     * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
     * @param {string} [lastUpdatedLt] Filter less than the value.
     * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
     * @param {string} [dateStatus] Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
     * @param {string} [dateStatusAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [dateStatusGt] Filter greater than the value.
     * @param {string} [dateStatusGte] Filter greater than or equal to the value.
     * @param {string} [dateStatusLt] Filter less than the value.
     * @param {string} [dateStatusLte] Filter less than or equal to the value.
     * @param {number} [epsSurprisePercent] The percentage difference between the actual and estimated EPS. Value must be a floating point number.
     * @param {string} [epsSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
     * @param {number} [epsSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
     * @param {number} [epsSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
     * @param {number} [epsSurprisePercentLt] Filter less than the value. Value must be a floating point number.
     * @param {number} [epsSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
     * @param {number} [revenueSurprisePercent] The percentage difference between the actual and estimated revenue. Value must be a floating point number.
     * @param {string} [revenueSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
     * @param {number} [revenueSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
     * @param {number} [revenueSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
     * @param {number} [revenueSurprisePercentLt] Filter less than the value. Value must be a floating point number.
     * @param {number} [revenueSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
     * @param {number} [fiscalYear] The fiscal year in which the earnings period falls. Value must be an integer.
     * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
     * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
     * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
     * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
     * @param {string} [fiscalPeriod] The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
     * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [fiscalPeriodGt] Filter greater than the value.
     * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
     * @param {string} [fiscalPeriodLt] Filter less than the value.
     * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
     * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1Earnings(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, dateStatus?: string, dateStatusAnyOf?: string, dateStatusGt?: string, dateStatusGte?: string, dateStatusLt?: string, dateStatusLte?: string, epsSurprisePercent?: number, epsSurprisePercentAnyOf?: string, epsSurprisePercentGt?: number, epsSurprisePercentGte?: number, epsSurprisePercentLt?: number, epsSurprisePercentLte?: number, revenueSurprisePercent?: number, revenueSurprisePercentAnyOf?: string, revenueSurprisePercentGt?: number, revenueSurprisePercentGte?: number, revenueSurprisePercentLt?: number, revenueSurprisePercentLte?: number, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1Earnings(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, importance, importanceAnyOf, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, dateStatus, dateStatusAnyOf, dateStatusGt, dateStatusGte, dateStatusLt, dateStatusLte, epsSurprisePercent, epsSurprisePercentAnyOf, epsSurprisePercentGt, epsSurprisePercentGte, epsSurprisePercentLt, epsSurprisePercentLte, revenueSurprisePercent, revenueSurprisePercentAnyOf, revenueSurprisePercentGt, revenueSurprisePercentGte, revenueSurprisePercentLt, revenueSurprisePercentLte, fiscalYear, fiscalYearAnyOf, fiscalYearGt, fiscalYearGte, fiscalYearLt, fiscalYearLte, fiscalPeriod, fiscalPeriodAnyOf, fiscalPeriodGt, fiscalPeriodGte, fiscalPeriodLt, fiscalPeriodLte, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [benzingaId] The identifer used by Benzinga for this record.
     * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [benzingaIdGt] Filter greater than the value.
     * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
     * @param {string} [benzingaIdLt] Filter less than the value.
     * @param {string} [benzingaIdLte] Filter less than or equal to the value.
     * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1Firms(benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1Firms(benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
     * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [dateGt] Filter greater than the value.
     * @param {string} [dateGte] Filter greater than or equal to the value.
     * @param {string} [dateLt] Filter less than the value.
     * @param {string} [dateLte] Filter less than or equal to the value.
     * @param {string} [ticker] The stock symbol of the company issuing guidance.
     * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [tickerGt] Filter greater than the value.
     * @param {string} [tickerGte] Filter greater than or equal to the value.
     * @param {string} [tickerLt] Filter less than the value.
     * @param {string} [tickerLte] Filter less than or equal to the value.
     * @param {string} [positioning] Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are \&#39;primary\&#39; (the emphasized figure) and \&#39;secondary\&#39; (a supporting or alternate figure)
     * @param {string} [positioningAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [positioningGt] Filter greater than the value.
     * @param {string} [positioningGte] Filter greater than or equal to the value.
     * @param {string} [positioningLt] Filter less than the value.
     * @param {string} [positioningLte] Filter less than or equal to the value.
     * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
     * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
     * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
     * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
     * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
     * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
     * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [lastUpdatedGt] Filter greater than the value.
     * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
     * @param {string} [lastUpdatedLt] Filter less than the value.
     * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
     * @param {number} [fiscalYear] The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer.
     * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
     * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
     * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
     * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
     * @param {string} [fiscalPeriod] The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
     * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [fiscalPeriodGt] Filter greater than the value.
     * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
     * @param {string} [fiscalPeriodLt] Filter less than the value.
     * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
     * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1Guidance(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, positioning?: string, positioningAnyOf?: string, positioningGt?: string, positioningGte?: string, positioningLt?: string, positioningLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1Guidance(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, positioning, positioningAnyOf, positioningGt, positioningGte, positioningLt, positioningLte, importance, importanceAnyOf, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, fiscalYear, fiscalYearAnyOf, fiscalYearGt, fiscalYearGte, fiscalYearLt, fiscalYearLte, fiscalPeriod, fiscalPeriodAnyOf, fiscalPeriodGt, fiscalPeriodGte, fiscalPeriodLt, fiscalPeriodLte, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [published] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
     * @param {string} [publishedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [publishedGt] Filter greater than the value.
     * @param {string} [publishedGte] Filter greater than or equal to the value.
     * @param {string} [publishedLt] Filter less than the value.
     * @param {string} [publishedLte] Filter less than or equal to the value.
     * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
     * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [lastUpdatedGt] Filter greater than the value.
     * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
     * @param {string} [lastUpdatedLt] Filter less than the value.
     * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
     * @param {string} [tickers] Filter for arrays that contain the value.
     * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [channels] Filter for arrays that contain the value.
     * @param {string} [channelsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [channelsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [tags] Filter for arrays that contain the value.
     * @param {string} [tagsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [tagsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [author] The name of the journalist or entity that authored the news article.
     * @param {string} [authorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [authorGt] Filter greater than the value.
     * @param {string} [authorGte] Filter greater than or equal to the value.
     * @param {string} [authorLt] Filter less than the value.
     * @param {string} [authorLte] Filter less than or equal to the value.
     * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;published\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1News(published?: string, publishedAnyOf?: string, publishedGt?: string, publishedGte?: string, publishedLt?: string, publishedLte?: string, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, channels?: string, channelsAllOf?: string, channelsAnyOf?: string, tags?: string, tagsAllOf?: string, tagsAnyOf?: string, author?: string, authorAnyOf?: string, authorGt?: string, authorGte?: string, authorLt?: string, authorLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1News(published, publishedAnyOf, publishedGt, publishedGte, publishedLt, publishedLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, tickers, tickersAllOf, tickersAnyOf, channels, channelsAllOf, channelsAnyOf, tags, tagsAllOf, tagsAnyOf, author, authorAnyOf, authorGt, authorGte, authorLt, authorLte, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
     * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [dateGt] Filter greater than the value.
     * @param {string} [dateGte] Filter greater than or equal to the value.
     * @param {string} [dateLt] Filter less than the value.
     * @param {string} [dateLte] Filter less than or equal to the value.
     * @param {string} [ticker] The stock symbol of the company being rated.
     * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [tickerGt] Filter greater than the value.
     * @param {string} [tickerGte] Filter greater than or equal to the value.
     * @param {string} [tickerLt] Filter less than the value.
     * @param {string} [tickerLte] Filter less than or equal to the value.
     * @param {number} [importance] A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
     * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
     * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
     * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
     * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
     * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
     * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [lastUpdatedGt] Filter greater than the value.
     * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
     * @param {string} [lastUpdatedLt] Filter less than the value.
     * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
     * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
     * @param {string} [ratingActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [ratingActionGt] Filter greater than the value.
     * @param {string} [ratingActionGte] Filter greater than or equal to the value.
     * @param {string} [ratingActionLt] Filter less than the value.
     * @param {string} [ratingActionLte] Filter less than or equal to the value.
     * @param {string} [priceTargetAction] The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
     * @param {string} [priceTargetActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [priceTargetActionGt] Filter greater than the value.
     * @param {string} [priceTargetActionGte] Filter greater than or equal to the value.
     * @param {string} [priceTargetActionLt] Filter less than the value.
     * @param {string} [priceTargetActionLte] Filter less than or equal to the value.
     * @param {string} [benzingaId] The identifer used by Benzinga for this record.
     * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [benzingaIdGt] Filter greater than the value.
     * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
     * @param {string} [benzingaIdLt] Filter less than the value.
     * @param {string} [benzingaIdLte] Filter less than or equal to the value.
     * @param {string} [benzingaAnalystId] Filter equal to the value.
     * @param {string} [benzingaAnalystIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [benzingaAnalystIdGt] Filter greater than the value.
     * @param {string} [benzingaAnalystIdGte] Filter greater than or equal to the value.
     * @param {string} [benzingaAnalystIdLt] Filter less than the value.
     * @param {string} [benzingaAnalystIdLte] Filter less than or equal to the value.
     * @param {string} [benzingaFirmId] Filter equal to the value.
     * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [benzingaFirmIdGt] Filter greater than the value.
     * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
     * @param {string} [benzingaFirmIdLt] Filter less than the value.
     * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
     * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1Ratings(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, ratingAction?: string, ratingActionAnyOf?: string, ratingActionGt?: string, ratingActionGte?: string, ratingActionLt?: string, ratingActionLte?: string, priceTargetAction?: string, priceTargetActionAnyOf?: string, priceTargetActionGt?: string, priceTargetActionGte?: string, priceTargetActionLt?: string, priceTargetActionLte?: string, benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaAnalystId?: string, benzingaAnalystIdAnyOf?: string, benzingaAnalystIdGt?: string, benzingaAnalystIdGte?: string, benzingaAnalystIdLt?: string, benzingaAnalystIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1Ratings(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, importance, importanceAnyOf, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, ratingAction, ratingActionAnyOf, ratingActionGt, ratingActionGte, ratingActionLt, ratingActionLte, priceTargetAction, priceTargetActionAnyOf, priceTargetActionGt, priceTargetActionGte, priceTargetActionLt, priceTargetActionLte, benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, benzingaAnalystId, benzingaAnalystIdAnyOf, benzingaAnalystIdGt, benzingaAnalystIdGte, benzingaAnalystIdLt, benzingaAnalystIdLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {string} cryptoTicker The ticker symbol of the currency pair.
     * @param {number} multiplier The size of the timespan multiplier.
     * @param {GetCryptoAggregatesTimespanEnum} timespan The size of the time window.
     * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {GetCryptoAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoAggregates(cryptoTicker: string, multiplier: number, timespan: GetCryptoAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetCryptoAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoAggregates(cryptoTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {string} cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetCryptoEMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {GetCryptoEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetCryptoEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoEMA(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoEMATimespanEnum, window?: number, seriesType?: GetCryptoEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoEMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {string} cryptoTicker The ticker symbol for which to get MACD data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetCryptoMACDTimespanEnum} [timespan] The size of the aggregate time window.
     * @param {number} [shortWindow] The short window size used to calculate MACD data.
     * @param {number} [longWindow] The long window size used to calculate MACD data.
     * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
     * @param {GetCryptoMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate MACD data. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetCryptoMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoMACD(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoMACDTimespanEnum, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetCryptoMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoMACD(cryptoTicker, timestamp, timespan, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close prices of a cryptocurrency symbol on a certain day. 
     * @summary Daily Open/Close
     * @param {string} from The \&quot;from\&quot; symbol of the pair.
     * @param {string} to The \&quot;to\&quot; symbol of the pair.
     * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoOpenClose(from: string, to: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoOpenClose(from, to, date, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {string} cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetCryptoRSITimespanEnum} [timespan] The size of the aggregate time window.
     * @param {number} [window] The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {GetCryptoRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetCryptoRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoRSI(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoRSITimespanEnum, window?: number, seriesType?: GetCryptoRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoRSI(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {string} cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetCryptoSMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {GetCryptoSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetCryptoSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoSMA(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoSMATimespanEnum, window?: number, seriesType?: GetCryptoSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoSMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Gainers/Losers
     * @param {GetCryptoSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoSnapshotDirection(direction: GetCryptoSnapshotDirectionDirectionEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoSnapshotDirection(direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Ticker
     * @param {string} ticker Ticker of the snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoSnapshotTicker(ticker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoSnapshotTicker(ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary All Tickers
     * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoSnapshotTickers(tickers?: Array<string>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoSnapshotTickers(tickers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a crypto ticker symbol in a given time range.
     * @summary Trades
     * @param {string} cryptoTicker The ticker symbol to get trades for.
     * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {GetCryptoTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {GetCryptoTradesSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoTrades(cryptoTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetCryptoTradesOrderEnum, limit?: number, sort?: GetCryptoTradesSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoTrades(cryptoTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
     * @summary Real-time Currency Conversion
     * @param {string} from The \&quot;from\&quot; symbol of the pair.
     * @param {string} to The \&quot;to\&quot; symbol of the pair.
     * @param {number} [amount] The amount to convert, with a decimal.
     * @param {GetCurrencyConversionPrecisionEnum} [precision] The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrencyConversion(from: string, to: string, amount?: number, precision?: GetCurrencyConversionPrecisionEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCurrencyConversion(from, to, amount, precision, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
     * @summary Ticker Events
     * @param {string} id Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the  [Ticker Details Endpoint](https://polygon.io/docs/stocks/get_v3_reference_tickers__ticker)
     * @param {string} [types] A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEvents(id: string, types?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEvents(id, types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [date] Calendar date of the yield observation (YYYYMMDD).
     * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [dateGt] Filter greater than the value.
     * @param {string} [dateGte] Filter greater than or equal to the value.
     * @param {string} [dateLt] Filter less than the value.
     * @param {string} [dateLte] Filter less than or equal to the value.
     * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFedV1TreasuryYields(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFedV1TreasuryYields(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {string} forexTicker The ticker symbol of the currency pair.
     * @param {number} multiplier The size of the timespan multiplier.
     * @param {GetForexAggregatesTimespanEnum} timespan The size of the time window.
     * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {GetForexAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexAggregates(forexTicker: string, multiplier: number, timespan: GetForexAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetForexAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexAggregates(forexTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {string} fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetForexEMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {GetForexEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetForexEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexEMA(fxTicker: string, timestamp?: string, timespan?: GetForexEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexEMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {string} fxTicker The ticker symbol for which to get MACD data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetForexMACDTimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [shortWindow] The short window size used to calculate MACD data.
     * @param {number} [longWindow] The long window size used to calculate MACD data.
     * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
     * @param {GetForexMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetForexMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexMACD(fxTicker: string, timestamp?: string, timespan?: GetForexMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetForexMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexMACD(fxTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get BBO quotes for a ticker symbol in a given time range.
     * @summary Quotes (BBO)
     * @param {string} fxTicker The ticker symbol to get quotes for.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {GetForexQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {GetForexQuotesSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexQuotes(fxTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetForexQuotesOrderEnum, limit?: number, sort?: GetForexQuotesSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexQuotes(fxTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {string} fxTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetForexRSITimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the relative strength index (RSI).
     * @param {GetForexRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetForexRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexRSI(fxTicker: string, timestamp?: string, timespan?: GetForexRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexRSI(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {string} fxTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetForexSMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {GetForexSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetForexSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexSMA(fxTicker: string, timestamp?: string, timespan?: GetForexSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexSMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Gainers/Losers
     * @param {GetForexSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexSnapshotDirection(direction: GetForexSnapshotDirectionDirectionEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexSnapshotDirection(direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Ticker
     * @param {string} ticker The forex ticker.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexSnapshotTicker(ticker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexSnapshotTicker(ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary All Tickers
     * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexSnapshotTickers(tickers?: Array<string>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexSnapshotTickers(tickers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
     * @summary Grouped Daily (Bars)
     * @param {string} date The beginning date for the aggregate window.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGroupedCryptoAggregates(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroupedCryptoAggregates(date, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
     * @summary Grouped Daily (Bars)
     * @param {string} date The beginning date for the aggregate window.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGroupedForexAggregates(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroupedForexAggregates(date, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
     * @summary Grouped Daily (Bars)
     * @param {string} date The beginning date for the aggregate window.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGroupedStocksAggregates(date: string, adjusted?: boolean, includeOtc?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroupedStocksAggregates(date, adjusted, includeOtc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {string} indicesTicker The ticker symbol of Index.
     * @param {number} multiplier The size of the timespan multiplier.
     * @param {GetIndicesAggregatesTimespanEnum} timespan The size of the time window.
     * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetIndicesAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesAggregates(indicesTicker: string, multiplier: number, timespan: GetIndicesAggregatesTimespanEnum, from: string, to: string, sort?: GetIndicesAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesAggregates(indicesTicker, multiplier, timespan, from, to, sort, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {string} indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetIndicesEMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {GetIndicesEMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the exponential moving average (EMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetIndicesEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesEMA(indicesTicker: string, timestamp?: string, timespan?: GetIndicesEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesEMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {string} indicesTicker The ticker symbol for which to get MACD data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetIndicesMACDTimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [shortWindow] The short window size used to calculate MACD data.
     * @param {number} [longWindow] The long window size used to calculate MACD data.
     * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
     * @param {GetIndicesMACDSeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close values to  calculate the MACD.
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetIndicesMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesMACD(indicesTicker: string, timestamp?: string, timespan?: GetIndicesMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetIndicesMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesMACD(indicesTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close and afterhours values of a index symbol on a certain date. 
     * @summary Daily Open/Close
     * @param {string} indicesTicker The ticker symbol of Index.
     * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesOpenClose(indicesTicker: string, date: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesOpenClose(indicesTicker, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {string} indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetIndicesRSITimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the relative strength index (RSI).
     * @param {GetIndicesRSISeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close values to  calculate the relative strength index (RSI).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetIndicesRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesRSI(indicesTicker: string, timestamp?: string, timespan?: GetIndicesRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesRSI(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {string} indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetIndicesSMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {GetIndicesSMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the simple moving average (SMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetIndicesSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesSMA(indicesTicker: string, timestamp?: string, timespan?: GetIndicesSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesSMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Snapshot of indices data for said tickers
     * @summary Indices Snapshot
     * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
     * @param {string} [ticker] Search a range of tickers lexicographically.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {GetIndicesSnapshotOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
     * @param {GetIndicesSnapshotSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesSnapshot(tickerAnyOf?: string, ticker?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: GetIndicesSnapshotOrderEnum, limit?: number, sort?: GetIndicesSnapshotSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesSnapshot(tickerAnyOf, ticker, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the last trade tick for a cryptocurrency pair.
     * @summary Last Trade for a Crypto Pair
     * @param {string} from The \&quot;from\&quot; symbol of the pair.
     * @param {string} to The \&quot;to\&quot; symbol of the pair.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLastCryptoTrade(from: string, to: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLastCryptoTrade(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the last quote tick for a forex currency pair.
     * @summary Last Quote for a Currency Pair
     * @param {string} from The \&quot;from\&quot; symbol of the pair.
     * @param {string} to The \&quot;to\&quot; symbol of the pair.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLastCurrencyQuote(from: string, to: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLastCurrencyQuote(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent trade for a given options contract.
     * @summary Last Trade
     * @param {string} optionsTicker The ticker symbol of the options contract.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLastOptionsTrade(optionsTicker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLastOptionsTrade(optionsTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent NBBO (Quote) tick for a given stock.
     * @summary Last Quote
     * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLastStocksQuote(stocksTicker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLastStocksQuote(stocksTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent trade for a given stock.
     * @summary Last Trade
     * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLastStocksTrade(stocksTicker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLastStocksTrade(stocksTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get upcoming market holidays and their open/close times.
     * @summary Market Holidays
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarketHolidays(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMarketHolidays(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current trading status of the exchanges and overall financial markets.
     * @summary Market Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarketStatus(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMarketStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the snapshot of an option contract for a stock equity.
     * @summary Option Contract
     * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
     * @param {string} optionContract The option contract identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionContract(underlyingAsset: string, optionContract: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionContract(underlyingAsset, optionContract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {string} optionsTicker The ticker symbol of the options contract.
     * @param {number} multiplier The size of the timespan multiplier.
     * @param {GetOptionsAggregatesTimespanEnum} timespan The size of the time window.
     * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {GetOptionsAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsAggregates(optionsTicker: string, multiplier: number, timespan: GetOptionsAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetOptionsAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsAggregates(optionsTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the snapshot of all options contracts for an underlying ticker.
     * @summary Options Chain
     * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
     * @param {number} [strikePrice] Query by strike price of a contract.
     * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
     * @param {GetOptionsChainContractTypeEnum} [contractType] Query by the type of contract.
     * @param {number} [strikePriceGte] Range by strike_price.
     * @param {number} [strikePriceGt] Range by strike_price.
     * @param {number} [strikePriceLte] Range by strike_price.
     * @param {number} [strikePriceLt] Range by strike_price.
     * @param {string} [expirationDateGte] Range by expiration_date.
     * @param {string} [expirationDateGt] Range by expiration_date.
     * @param {string} [expirationDateLte] Range by expiration_date.
     * @param {string} [expirationDateLt] Range by expiration_date.
     * @param {GetOptionsChainOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
     * @param {GetOptionsChainSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsChain(underlyingAsset: string, strikePrice?: number, expirationDate?: string, contractType?: GetOptionsChainContractTypeEnum, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, order?: GetOptionsChainOrderEnum, limit?: number, sort?: GetOptionsChainSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsChain(underlyingAsset, strikePrice, expirationDate, contractType, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an options contract
     * @summary Options Contract
     * @param {string} optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://polygon.io/blog/how-to-read-a-stock-options-ticker/).
     * @param {string} [asOf] Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsContract(optionsTicker: string, asOf?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsContract(optionsTicker, asOf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {string} optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetOptionsEMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {GetOptionsEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetOptionsEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsEMA(optionsTicker: string, timestamp?: string, timespan?: GetOptionsEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsEMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {string} optionsTicker The ticker symbol for which to get MACD data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetOptionsMACDTimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [shortWindow] The short window size used to calculate MACD data.
     * @param {number} [longWindow] The long window size used to calculate MACD data.
     * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
     * @param {GetOptionsMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetOptionsMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsMACD(optionsTicker: string, timestamp?: string, timespan?: GetOptionsMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetOptionsMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsMACD(optionsTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close and afterhours prices of an options contract on a certain date. 
     * @summary Daily Open/Close
     * @param {string} optionsTicker The ticker symbol of the options contract.
     * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsOpenClose(optionsTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsOpenClose(optionsTicker, date, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get quotes for an options ticker symbol in a given time range.
     * @summary Quotes
     * @param {string} optionsTicker The ticker symbol to get quotes for.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {GetOptionsQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {GetOptionsQuotesSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsQuotes(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsQuotesOrderEnum, limit?: number, sort?: GetOptionsQuotesSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsQuotes(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {string} optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetOptionsRSITimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the relative strength index (RSI).
     * @param {GetOptionsRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetOptionsRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsRSI(optionsTicker: string, timestamp?: string, timespan?: GetOptionsRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsRSI(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {string} optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetOptionsSMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {GetOptionsSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetOptionsSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsSMA(optionsTicker: string, timestamp?: string, timespan?: GetOptionsSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsSMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for an options ticker symbol in a given time range.
     * @summary Trades
     * @param {string} optionsTicker The options ticker symbol to get trades for.
     * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {GetOptionsTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {GetOptionsTradesSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsTrades(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsTradesOrderEnum, limit?: number, sort?: GetOptionsTradesSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsTrades(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
     * @summary Previous Close
     * @param {string} cryptoTicker The ticker symbol of the currency pair.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPreviousCryptoAggregates(cryptoTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPreviousCryptoAggregates(cryptoTicker, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
     * @summary Previous Close
     * @param {string} forexTicker The ticker symbol of the currency pair.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPreviousForexAggregates(forexTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPreviousForexAggregates(forexTicker, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
     * @summary Previous Close
     * @param {string} indicesTicker The ticker symbol of Index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPreviousIndicesAggregates(indicesTicker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPreviousIndicesAggregates(indicesTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
     * @summary Previous Close
     * @param {string} optionsTicker The ticker symbol of the options contract.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPreviousOptionsAggregates(optionsTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPreviousOptionsAggregates(optionsTicker, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
     * @summary Previous Close
     * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPreviousStocksAggregates(stocksTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPreviousStocksAggregates(stocksTicker, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of tickers related to the queried ticker based on News and Returns data.
     * @summary Related Companies
     * @param {string} ticker The ticker symbol to search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRelatedCompanies(ticker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRelatedCompanies(ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
     * @summary Summaries
     * @param {string} [tickerAnyOf] Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://polygon.io/docs/stocks/get_v3_reference_tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSnapshotSummary(tickerAnyOf?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSnapshotSummary(tickerAnyOf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get snapshots for assets of all types
     * @summary Universal Snapshot
     * @param {string} [ticker] Search a range of tickers lexicographically.
     * @param {GetSnapshotsTypeEnum} [type] Query by the type of asset.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. 
     * @param {GetSnapshotsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
     * @param {GetSnapshotsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSnapshots(ticker?: string, type?: GetSnapshotsTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, tickerAnyOf?: string, order?: GetSnapshotsOrderEnum, limit?: number, sort?: GetSnapshotsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSnapshots(ticker, type, tickerGte, tickerGt, tickerLte, tickerLt, tickerAnyOf, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {number} multiplier The size of the timespan multiplier.
     * @param {GetStocksAggregatesTimespanEnum} timespan The size of the time window.
     * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {GetStocksAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksAggregates(stocksTicker: string, multiplier: number, timespan: GetStocksAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetStocksAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksAggregates(stocksTicker, multiplier, timespan, from, to, adjusted, sort, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetStocksEMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {GetStocksEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetStocksEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksEMA(stockTicker: string, timestamp?: string, timespan?: GetStocksEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksEMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetStocksMACDTimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [shortWindow] The short window size used to calculate MACD data.
     * @param {number} [longWindow] The long window size used to calculate MACD data.
     * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
     * @param {GetStocksMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetStocksMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksMACD(stockTicker: string, timestamp?: string, timespan?: GetStocksMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetStocksMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksMACD(stockTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close and afterhours prices of a stock symbol on a certain date. 
     * @summary Daily Open/Close
     * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
     * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksOpenClose(stocksTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksOpenClose(stocksTicker, date, adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get NBBO quotes for a ticker symbol in a given time range.
     * @summary Quotes (NBBO)
     * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {GetStocksQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {GetStocksQuotesSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksQuotes(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksQuotesOrderEnum, limit?: number, sort?: GetStocksQuotesSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksQuotes(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetStocksRSITimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the relative strength index (RSI).
     * @param {GetStocksRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetStocksRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksRSI(stockTicker: string, timestamp?: string, timespan?: GetStocksRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksRSI(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
     * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param {GetStocksSMATimespanEnum} [timespan] The size of the aggregate time window.
     * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @param {GetStocksSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
     * @param {GetStocksSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksSMA(stockTicker: string, timestamp?: string, timespan?: GetStocksSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksSMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
     * @summary Gainers/Losers
     * @param {GetStocksSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
     * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksSnapshotDirection(direction: GetStocksSnapshotDirectionDirectionEnum, includeOtc?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksSnapshotDirection(direction, includeOtc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary Ticker
     * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksSnapshotTicker(stocksTicker: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksSnapshotTicker(stocksTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary All Tickers
     * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
     * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksSnapshotTickers(tickers?: Array<string>, includeOtc?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksSnapshotTickers(tickers, includeOtc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a ticker symbol in a given time range.
     * @summary Trades
     * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @param {string} [timestampGte] Range by timestamp.
     * @param {string} [timestampGt] Range by timestamp.
     * @param {string} [timestampLte] Range by timestamp.
     * @param {string} [timestampLt] Range by timestamp.
     * @param {GetStocksTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
     * @param {GetStocksTradesSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksTrades(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksTradesOrderEnum, limit?: number, sort?: GetStocksTradesSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksTrades(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [ticker] The primary ticker symbol for the stock.
     * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [tickerGt] Filter greater than the value.
     * @param {string} [tickerGte] Filter greater than or equal to the value.
     * @param {string} [tickerLt] Filter less than the value.
     * @param {string} [tickerLte] Filter less than or equal to the value.
     * @param {number} [daysToCover] Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number.
     * @param {string} [daysToCoverAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
     * @param {number} [daysToCoverGt] Filter greater than the value. Value must be a floating point number.
     * @param {number} [daysToCoverGte] Filter greater than or equal to the value. Value must be a floating point number.
     * @param {number} [daysToCoverLt] Filter less than the value. Value must be a floating point number.
     * @param {number} [daysToCoverLte] Filter less than or equal to the value. Value must be a floating point number.
     * @param {string} [settlementDate] The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
     * @param {string} [settlementDateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [settlementDateGt] Filter greater than the value.
     * @param {string} [settlementDateGte] Filter greater than or equal to the value.
     * @param {string} [settlementDateLt] Filter less than the value.
     * @param {string} [settlementDateLte] Filter less than or equal to the value.
     * @param {number} [avgDailyVolume] The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer.
     * @param {string} [avgDailyVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @param {number} [avgDailyVolumeGt] Filter greater than the value. Value must be an integer.
     * @param {number} [avgDailyVolumeGte] Filter greater than or equal to the value. Value must be an integer.
     * @param {number} [avgDailyVolumeLt] Filter less than the value. Value must be an integer.
     * @param {number} [avgDailyVolumeLte] Filter less than or equal to the value. Value must be an integer.
     * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksV1ShortInterest(ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, daysToCover?: number, daysToCoverAnyOf?: string, daysToCoverGt?: number, daysToCoverGte?: number, daysToCoverLt?: number, daysToCoverLte?: number, settlementDate?: string, settlementDateAnyOf?: string, settlementDateGt?: string, settlementDateGte?: string, settlementDateLt?: string, settlementDateLte?: string, avgDailyVolume?: number, avgDailyVolumeAnyOf?: string, avgDailyVolumeGt?: number, avgDailyVolumeGte?: number, avgDailyVolumeLt?: number, avgDailyVolumeLte?: number, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksV1ShortInterest(ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, daysToCover, daysToCoverAnyOf, daysToCoverGt, daysToCoverGte, daysToCoverLt, daysToCoverLte, settlementDate, settlementDateAnyOf, settlementDateGt, settlementDateGte, settlementDateLt, settlementDateLte, avgDailyVolume, avgDailyVolumeAnyOf, avgDailyVolumeGt, avgDailyVolumeGte, avgDailyVolumeLt, avgDailyVolumeLte, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [ticker] The primary ticker symbol for the stock.
     * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [tickerGt] Filter greater than the value.
     * @param {string} [tickerGte] Filter greater than or equal to the value.
     * @param {string} [tickerLt] Filter less than the value.
     * @param {string} [tickerLte] Filter less than or equal to the value.
     * @param {string} [date] The date of trade activity reported in the format YYYY-MM-DD
     * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @param {string} [dateGt] Filter greater than the value.
     * @param {string} [dateGte] Filter greater than or equal to the value.
     * @param {string} [dateLt] Filter less than the value.
     * @param {string} [dateLte] Filter less than or equal to the value.
     * @param {number} [shortVolumeRatio] The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number.
     * @param {string} [shortVolumeRatioAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
     * @param {number} [shortVolumeRatioGt] Filter greater than the value. Value must be a floating point number.
     * @param {number} [shortVolumeRatioGte] Filter greater than or equal to the value. Value must be a floating point number.
     * @param {number} [shortVolumeRatioLt] Filter less than the value. Value must be a floating point number.
     * @param {number} [shortVolumeRatioLte] Filter less than or equal to the value. Value must be a floating point number.
     * @param {number} [totalVolume] Total reported volume across all venues for the ticker on the given date. Value must be an integer.
     * @param {string} [totalVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @param {number} [totalVolumeGt] Filter greater than the value. Value must be an integer.
     * @param {number} [totalVolumeGte] Filter greater than or equal to the value. Value must be an integer.
     * @param {number} [totalVolumeLt] Filter less than the value. Value must be an integer.
     * @param {number} [totalVolumeLte] Filter less than or equal to the value. Value must be an integer.
     * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksV1ShortVolume(ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, shortVolumeRatio?: number, shortVolumeRatioAnyOf?: string, shortVolumeRatioGt?: number, shortVolumeRatioGte?: number, shortVolumeRatioLt?: number, shortVolumeRatioLte?: number, totalVolume?: number, totalVolumeAnyOf?: string, totalVolumeGt?: number, totalVolumeGte?: number, totalVolumeLt?: number, totalVolumeLte?: number, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksV1ShortVolume(ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, shortVolumeRatio, shortVolumeRatioAnyOf, shortVolumeRatioGt, shortVolumeRatioGte, shortVolumeRatioLt, shortVolumeRatioLte, totalVolume, totalVolumeAnyOf, totalVolumeGt, totalVolumeGte, totalVolumeLt, totalVolumeLte, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
     * @summary Ticker Details v3
     * @param {string} ticker The ticker symbol of the asset.
     * @param {string} [date] Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTicker(ticker: string, date?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTicker(ticker, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all conditions that Polygon.io uses.
     * @summary Conditions
     * @param {ListConditionsAssetClassEnum} [assetClass] Filter for conditions within a given asset class.
     * @param {ListConditionsDataTypeEnum} [dataType] Filter by data type.
     * @param {number} [id] Filter for conditions with a given ID.
     * @param {ListConditionsSipEnum} [sip] Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
     * @param {ListConditionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListConditionsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listConditions(assetClass?: ListConditionsAssetClassEnum, dataType?: ListConditionsDataTypeEnum, id?: number, sip?: ListConditionsSipEnum, order?: ListConditionsOrderEnum, limit?: number, sort?: ListConditionsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listConditions(assetClass, dataType, id, sip, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
     * @summary Dividends v3
     * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {string} [exDividendDate] Query by ex-dividend date with the format YYYY-MM-DD.
     * @param {string} [recordDate] Query by record date with the format YYYY-MM-DD.
     * @param {string} [declarationDate] Query by declaration date with the format YYYY-MM-DD.
     * @param {string} [payDate] Query by pay date with the format YYYY-MM-DD.
     * @param {ListDividendsFrequencyEnum} [frequency] Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
     * @param {number} [cashAmount] Query by the cash amount of the dividend.
     * @param {ListDividendsDividendTypeEnum} [dividendType] Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {string} [exDividendDateGte] Range by ex_dividend_date.
     * @param {string} [exDividendDateGt] Range by ex_dividend_date.
     * @param {string} [exDividendDateLte] Range by ex_dividend_date.
     * @param {string} [exDividendDateLt] Range by ex_dividend_date.
     * @param {string} [recordDateGte] Range by record_date.
     * @param {string} [recordDateGt] Range by record_date.
     * @param {string} [recordDateLte] Range by record_date.
     * @param {string} [recordDateLt] Range by record_date.
     * @param {string} [declarationDateGte] Range by declaration_date.
     * @param {string} [declarationDateGt] Range by declaration_date.
     * @param {string} [declarationDateLte] Range by declaration_date.
     * @param {string} [declarationDateLt] Range by declaration_date.
     * @param {string} [payDateGte] Range by pay_date.
     * @param {string} [payDateGt] Range by pay_date.
     * @param {string} [payDateLte] Range by pay_date.
     * @param {string} [payDateLt] Range by pay_date.
     * @param {number} [cashAmountGte] Range by cash_amount.
     * @param {number} [cashAmountGt] Range by cash_amount.
     * @param {number} [cashAmountLte] Range by cash_amount.
     * @param {number} [cashAmountLt] Range by cash_amount.
     * @param {ListDividendsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListDividendsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listDividends(ticker?: string, exDividendDate?: string, recordDate?: string, declarationDate?: string, payDate?: string, frequency?: ListDividendsFrequencyEnum, cashAmount?: number, dividendType?: ListDividendsDividendTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, exDividendDateGte?: string, exDividendDateGt?: string, exDividendDateLte?: string, exDividendDateLt?: string, recordDateGte?: string, recordDateGt?: string, recordDateLte?: string, recordDateLt?: string, declarationDateGte?: string, declarationDateGt?: string, declarationDateLte?: string, declarationDateLt?: string, payDateGte?: string, payDateGt?: string, payDateLte?: string, payDateLt?: string, cashAmountGte?: number, cashAmountGt?: number, cashAmountLte?: number, cashAmountLt?: number, order?: ListDividendsOrderEnum, limit?: number, sort?: ListDividendsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listDividends(ticker, exDividendDate, recordDate, declarationDate, payDate, frequency, cashAmount, dividendType, tickerGte, tickerGt, tickerLte, tickerLt, exDividendDateGte, exDividendDateGt, exDividendDateLte, exDividendDateLt, recordDateGte, recordDateGt, recordDateLte, recordDateLt, declarationDateGte, declarationDateGt, declarationDateLte, declarationDateLt, payDateGte, payDateGt, payDateLte, payDateLt, cashAmountGte, cashAmountGt, cashAmountLte, cashAmountLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all exchanges that Polygon.io knows about.
     * @summary Exchanges
     * @param {ListExchangesAssetClassEnum} [assetClass] Filter by asset class.
     * @param {ListExchangesLocaleEnum} [locale] Filter by locale.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listExchanges(assetClass?: ListExchangesAssetClassEnum, locale?: ListExchangesLocaleEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listExchanges(assetClass, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
     * @summary Stock Financials vX
     * @param {string} [ticker] Query by company ticker.
     * @param {string} [cik] Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number
     * @param {string} [companyName] Query by company name.
     * @param {string} [sic] Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;)
     * @param {string} [filingDate] Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01
     * @param {string} [periodOfReportDate] The period of report for the filing with financials data in YYYY-MM-DD format.
     * @param {ListFinancialsTimeframeEnum} [timeframe] Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
     * @param {boolean} [includeSources] Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default.
     * @param {string} [companyNameSearch] Search by company_name.
     * @param {string} [filingDateGte] Search by filing_date.
     * @param {string} [filingDateGt] Search by filing_date.
     * @param {string} [filingDateLte] Search by filing_date.
     * @param {string} [filingDateLt] Search by filing_date.
     * @param {string} [periodOfReportDateGte] Search by period_of_report_date.
     * @param {string} [periodOfReportDateGt] Search by period_of_report_date.
     * @param {string} [periodOfReportDateLte] Search by period_of_report_date.
     * @param {string} [periodOfReportDateLt] Search by period_of_report_date.
     * @param {ListFinancialsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 100.
     * @param {ListFinancialsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listFinancials(ticker?: string, cik?: string, companyName?: string, sic?: string, filingDate?: string, periodOfReportDate?: string, timeframe?: ListFinancialsTimeframeEnum, includeSources?: boolean, companyNameSearch?: string, filingDateGte?: string, filingDateGt?: string, filingDateLte?: string, filingDateLt?: string, periodOfReportDateGte?: string, periodOfReportDateGt?: string, periodOfReportDateLte?: string, periodOfReportDateLt?: string, order?: ListFinancialsOrderEnum, limit?: number, sort?: ListFinancialsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFinancials(ticker, cik, companyName, sic, filingDate, periodOfReportDate, timeframe, includeSources, companyNameSearch, filingDateGte, filingDateGt, filingDateLte, filingDateLt, periodOfReportDateGte, periodOfReportDateGt, periodOfReportDateLte, periodOfReportDateLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
     * @summary IPOs
     * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc.
     * @param {string} [usCode] Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
     * @param {string} [isin] Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
     * @param {string} [listingDate] Specify a listing date. This is the first trading date for the newly listed entity.
     * @param {ListIPOsIpoStatusEnum} [ipoStatus] Specify an IPO status.
     * @param {string} [listingDateGte] Range by listing_date.
     * @param {string} [listingDateGt] Range by listing_date.
     * @param {string} [listingDateLte] Range by listing_date.
     * @param {string} [listingDateLt] Range by listing_date.
     * @param {ListIPOsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListIPOsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listIPOs(ticker?: string, usCode?: string, isin?: string, listingDate?: string, ipoStatus?: ListIPOsIpoStatusEnum, listingDateGte?: string, listingDateGt?: string, listingDateLte?: string, listingDateLt?: string, order?: ListIPOsOrderEnum, limit?: number, sort?: ListIPOsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listIPOs(ticker, usCode, isin, listingDate, ipoStatus, listingDateGte, listingDateGt, listingDateLte, listingDateLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
     * @summary Ticker News
     * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {ListNewsPublishedUtcParameter} [publishedUtc] Return results published on, before, or after this date.
     * @param {string} [tickerGte] Search by ticker.
     * @param {string} [tickerGt] Search by ticker.
     * @param {string} [tickerLte] Search by ticker.
     * @param {string} [tickerLt] Search by ticker.
     * @param {ListNewsPublishedUtcParameter} [publishedUtcGte] Search by published_utc.
     * @param {ListNewsPublishedUtcParameter} [publishedUtcGt] Search by published_utc.
     * @param {ListNewsPublishedUtcParameter} [publishedUtcLte] Search by published_utc.
     * @param {ListNewsPublishedUtcParameter} [publishedUtcLt] Search by published_utc.
     * @param {ListNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListNewsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNews(ticker?: string, publishedUtc?: ListNewsPublishedUtcParameter, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, publishedUtcGte?: ListNewsPublishedUtcParameter, publishedUtcGt?: ListNewsPublishedUtcParameter, publishedUtcLte?: ListNewsPublishedUtcParameter, publishedUtcLt?: ListNewsPublishedUtcParameter, order?: ListNewsOrderEnum, limit?: number, sort?: ListNewsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listNews(ticker, publishedUtc, tickerGte, tickerGt, tickerLte, tickerLt, publishedUtcGte, publishedUtcGt, publishedUtcLte, publishedUtcLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query for historical options contracts. This provides both active and expired options contracts.
     * @summary Options Contracts
     * @param {string} [underlyingTicker] Query for contracts relating to an underlying stock ticker.
     * @param {string} [ticker] This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://polygon.io/docs/options/get_v3_reference_options_contracts__options_ticker).
     * @param {ListOptionsContractsContractTypeEnum} [contractType] Query by the type of contract.
     * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
     * @param {string} [asOf] Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
     * @param {number} [strikePrice] Query by strike price of a contract.
     * @param {boolean} [expired] Query for expired contracts. Default is false.
     * @param {string} [underlyingTickerGte] Range by underlying_ticker.
     * @param {string} [underlyingTickerGt] Range by underlying_ticker.
     * @param {string} [underlyingTickerLte] Range by underlying_ticker.
     * @param {string} [underlyingTickerLt] Range by underlying_ticker.
     * @param {string} [expirationDateGte] Range by expiration_date.
     * @param {string} [expirationDateGt] Range by expiration_date.
     * @param {string} [expirationDateLte] Range by expiration_date.
     * @param {string} [expirationDateLt] Range by expiration_date.
     * @param {number} [strikePriceGte] Range by strike_price.
     * @param {number} [strikePriceGt] Range by strike_price.
     * @param {number} [strikePriceLte] Range by strike_price.
     * @param {number} [strikePriceLt] Range by strike_price.
     * @param {ListOptionsContractsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListOptionsContractsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOptionsContracts(underlyingTicker?: string, ticker?: string, contractType?: ListOptionsContractsContractTypeEnum, expirationDate?: string, asOf?: string, strikePrice?: number, expired?: boolean, underlyingTickerGte?: string, underlyingTickerGt?: string, underlyingTickerLte?: string, underlyingTickerLt?: string, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, order?: ListOptionsContractsOrderEnum, limit?: number, sort?: ListOptionsContractsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listOptionsContracts(underlyingTicker, ticker, contractType, expirationDate, asOf, strikePrice, expired, underlyingTickerGte, underlyingTickerGt, underlyingTickerLte, underlyingTickerLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
     * @summary Stock Splits v3
     * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param {string} [executionDate] Query by execution date with the format YYYY-MM-DD.
     * @param {boolean | null} [reverseSplit] Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {string} [executionDateGte] Range by execution_date.
     * @param {string} [executionDateGt] Range by execution_date.
     * @param {string} [executionDateLte] Range by execution_date.
     * @param {string} [executionDateLt] Range by execution_date.
     * @param {ListStockSplitsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
     * @param {ListStockSplitsSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listStockSplits(ticker?: string, executionDate?: string, reverseSplit?: boolean | null, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, executionDateGte?: string, executionDateGt?: string, executionDateLte?: string, executionDateLt?: string, order?: ListStockSplitsOrderEnum, limit?: number, sort?: ListStockSplitsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listStockSplits(ticker, executionDate, reverseSplit, tickerGte, tickerGt, tickerLte, tickerLt, executionDateGte, executionDateGt, executionDateLte, executionDateLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all ticker types that Polygon.io has.
     * @summary Ticker Types
     * @param {ListTickerTypesAssetClassEnum} [assetClass] Filter by asset class.
     * @param {ListTickerTypesLocaleEnum} [locale] Filter by locale.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTickerTypes(assetClass?: ListTickerTypesAssetClassEnum, locale?: ListTickerTypesLocaleEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listTickerTypes(assetClass, locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
     * @summary Tickers
     * @param {string} [ticker] Specify a ticker symbol. Defaults to empty string which queries all tickers.
     * @param {ListTickersTypeEnum} [type] Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types). Defaults to empty string which queries all types.
     * @param {ListTickersMarketEnum} [market] Filter by market type. By default all markets are included.
     * @param {string} [exchange] Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes [at the ISO org website](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges.
     * @param {string} [cusip] Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
     * @param {string} [cik] Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs.
     * @param {string} [date] Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.
     * @param {string} [search] Search for terms within the ticker and/or company name.
     * @param {boolean} [active] Specify if the tickers returned should be actively traded on the queried date. Default is true.
     * @param {string} [tickerGte] Range by ticker.
     * @param {string} [tickerGt] Range by ticker.
     * @param {string} [tickerLte] Range by ticker.
     * @param {string} [tickerLt] Range by ticker.
     * @param {ListTickersOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
     * @param {number} [limit] Limit the number of results returned, default is 100 and max is 1000.
     * @param {ListTickersSortEnum} [sort] Sort field used for ordering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTickers(ticker?: string, type?: ListTickersTypeEnum, market?: ListTickersMarketEnum, exchange?: string, cusip?: string, cik?: string, date?: string, search?: string, active?: boolean, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: ListTickersOrderEnum, limit?: number, sort?: ListTickersSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listTickers(ticker, type, market, exchange, cusip, cik, date, search, active, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum GetCryptoAggregatesTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoAggregatesSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoSnapshotDirectionDirectionEnum {
    Gainers = 'gainers',
    Losers = 'losers'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoTradesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoTradesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCurrencyConversionPrecisionEnum {
    NUMBER_0 = 0,
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3,
    NUMBER_4 = 4
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexAggregatesTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexAggregatesSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexQuotesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexQuotesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexSnapshotDirectionDirectionEnum {
    Gainers = 'gainers',
    Losers = 'losers'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesAggregatesTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesAggregatesSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesSnapshotOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesSnapshotSortEnum {
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsAggregatesTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsAggregatesSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsChainContractTypeEnum {
    Call = 'call',
    Put = 'put'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsChainOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsChainSortEnum {
    Ticker = 'ticker',
    ExpirationDate = 'expiration_date',
    StrikePrice = 'strike_price'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsQuotesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsQuotesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsTradesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsTradesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum GetSnapshotsTypeEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx',
    Indices = 'indices'
}
/**
  * @export
  * @enum {string}
  */
export enum GetSnapshotsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetSnapshotsSortEnum {
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksAggregatesTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksAggregatesSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksQuotesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksQuotesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksSnapshotDirectionDirectionEnum {
    Gainers = 'gainers',
    Losers = 'losers'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksTradesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksTradesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsDataTypeEnum {
    Trade = 'trade',
    Bbo = 'bbo',
    Nbbo = 'nbbo'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsSipEnum {
    Cta = 'CTA',
    Utp = 'UTP',
    Opra = 'OPRA'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsSortEnum {
    AssetClass = 'asset_class',
    Id = 'id',
    Type = 'type',
    Name = 'name',
    DataTypes = 'data_types',
    Legacy = 'legacy'
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsFrequencyEnum {
    NUMBER_0 = 0,
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_4 = 4,
    NUMBER_12 = 12,
    NUMBER_24 = 24,
    NUMBER_52 = 52
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsDividendTypeEnum {
    Cd = 'CD',
    Sc = 'SC',
    Lt = 'LT',
    St = 'ST'
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsSortEnum {
    ExDividendDate = 'ex_dividend_date',
    PayDate = 'pay_date',
    DeclarationDate = 'declaration_date',
    RecordDate = 'record_date',
    CashAmount = 'cash_amount',
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum ListExchangesAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx'
}
/**
  * @export
  * @enum {string}
  */
export enum ListExchangesLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
  * @export
  * @enum {string}
  */
export enum ListFinancialsTimeframeEnum {
    Annual = 'annual',
    Quarterly = 'quarterly',
    Ttm = 'ttm'
}
/**
  * @export
  * @enum {string}
  */
export enum ListFinancialsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListFinancialsSortEnum {
    FilingDate = 'filing_date',
    PeriodOfReportDate = 'period_of_report_date'
}
/**
  * @export
  * @enum {string}
  */
export enum ListIPOsIpoStatusEnum {
    DirectListingProcess = 'direct_listing_process',
    History = 'history',
    New = 'new',
    Pending = 'pending',
    Postponed = 'postponed',
    Rumor = 'rumor',
    Withdrawn = 'withdrawn'
}
/**
  * @export
  * @enum {string}
  */
export enum ListIPOsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListIPOsSortEnum {
    ListingDate = 'listing_date',
    Ticker = 'ticker',
    LastUpdated = 'last_updated',
    SecurityType = 'security_type',
    IssuerName = 'issuer_name',
    CurrencyCode = 'currency_code',
    Isin = 'isin',
    UsCode = 'us_code',
    FinalIssuePrice = 'final_issue_price',
    MinSharesOffered = 'min_shares_offered',
    MaxSharesOffered = 'max_shares_offered',
    LowestOfferPrice = 'lowest_offer_price',
    HighestOfferPrice = 'highest_offer_price',
    TotalOfferSize = 'total_offer_size',
    SharesOutstanding = 'shares_outstanding',
    PrimaryExchange = 'primary_exchange',
    LotSize = 'lot_size',
    SecurityDescription = 'security_description',
    IpoStatus = 'ipo_status',
    AnnouncedDate = 'announced_date'
}
/**
  * @export
  * @enum {string}
  */
export enum ListNewsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListNewsSortEnum {
    PublishedUtc = 'published_utc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListOptionsContractsContractTypeEnum {
    Call = 'call',
    Put = 'put'
}
/**
  * @export
  * @enum {string}
  */
export enum ListOptionsContractsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListOptionsContractsSortEnum {
    Ticker = 'ticker',
    UnderlyingTicker = 'underlying_ticker',
    ExpirationDate = 'expiration_date',
    StrikePrice = 'strike_price'
}
/**
  * @export
  * @enum {string}
  */
export enum ListStockSplitsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListStockSplitsSortEnum {
    ExecutionDate = 'execution_date',
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickerTypesAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx',
    Indices = 'indices'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickerTypesLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersTypeEnum {
    Cs = 'CS',
    Adrc = 'ADRC',
    Adrp = 'ADRP',
    Adrr = 'ADRR',
    Unit = 'UNIT',
    Right = 'RIGHT',
    Pfd = 'PFD',
    Fund = 'FUND',
    Sp = 'SP',
    Warrant = 'WARRANT',
    Index = 'INDEX',
    Etf = 'ETF',
    Etn = 'ETN',
    Os = 'OS',
    Gdr = 'GDR',
    Other = 'OTHER',
    Nyrs = 'NYRS',
    Agen = 'AGEN',
    Eqlk = 'EQLK',
    Bond = 'BOND',
    Adrw = 'ADRW',
    Basket = 'BASKET',
    Lt = 'LT'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersMarketEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Fx = 'fx',
    Otc = 'otc',
    Indices = 'indices'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersSortEnum {
    Ticker = 'ticker',
    Name = 'name',
    Market = 'market',
    Locale = 'locale',
    PrimaryExchange = 'primary_exchange',
    Type = 'type',
    CurrencySymbol = 'currency_symbol',
    CurrencyName = 'currency_name',
    BaseCurrencySymbol = 'base_currency_symbol',
    BaseCurrencyName = 'base_currency_name',
    Cik = 'cik',
    CompositeFigi = 'composite_figi',
    ShareClassFigi = 'share_class_figi',
    LastUpdatedUtc = 'last_updated_utc',
    DelistedUtc = 'delisted_utc'
}


